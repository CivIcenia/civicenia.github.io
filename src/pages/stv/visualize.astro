---
/**
 * STV Election Results Visualization Page
 * 
 * This page displays animated bar charts for STV election results.
 * It can import election data from JSON files exported by the STV calculator.
 * 
 * @route /stv/visualize
 */
import PageLayout from "@layouts/page.astro";

---

<PageLayout chin={false} title="STV Results Visualization" description="Animated visualization of Single Transferable Vote election results round by round.">

    <!-- Page Header -->
    <div class="page-header">
        <h1 class="govuk-heading-xl" style="margin-bottom: 10px;">STV Results Visualization</h1>
        <p class="govuk-body-l">View animated round-by-round results of STV elections.</p>
    </div>

    <div class="govuk-width-container">
        <main class="govuk-main-wrapper govuk-body" id="main-content">
            
            <!-- Import Section -->
            <div class="import-section govuk-form-group">
                <h2 class="govuk-heading-m">Load Election Data</h2>
                <p class="govuk-body">Select a previous Icenian senate election or import a custom RCVis-format JSON file from the <a href="/stv">STV Calculator</a>.</p>
                
                <div class="govuk-form-group">
                    <label class="govuk-label govuk-label--s" for="election-selector">
                        Previous Senate Elections
                    </label>
                    <select 
                        id="election-selector" 
                        class="govuk-select"
                        style="width: 100%; max-width: 400px;"
                    >
                        <option value="">-- Select an election --</option>
                    </select>
                    <button type="button" id="load-election-btn" class="icenia-btn" style="margin-top: 0.5rem;">
                        Load Selected Election
                    </button>
                </div>
                
                <div class="govuk-form-group" style="margin-top: 2rem; padding-top: 1.5rem; border-top: 1px solid #ddd;">
                    <label class="govuk-label govuk-label--s" for="election-file">
                        Or upload custom election file (.json)
                    </label>
                    <input 
                        type="file" 
                        id="election-file" 
                        accept=".json"
                        class="govuk-file-upload"
                    />
                    <button type="button" id="load-file-btn" class="icenia-btn" style="margin-top: 0.5rem;">
                        Load Custom File
                    </button>
                </div>
                
                <!-- Error/Status Messages -->
                <div id="status-message" class="status-message" style="display: none;"></div>
            </div>
            
            <!-- Election Info -->
            <div id="election-info" class="election-info" style="display: none;">
                <h2 class="govuk-heading-m">Election Details</h2>
                <dl class="govuk-summary-list govuk-summary-list--no-border">
                    <div class="govuk-summary-list__row">
                        <dt class="govuk-summary-list__key">Contest</dt>
                        <dd class="govuk-summary-list__value" id="info-contest">-</dd>
                    </div>
                    <div class="govuk-summary-list__row">
                        <dt class="govuk-summary-list__key">Date</dt>
                        <dd class="govuk-summary-list__value" id="info-date">-</dd>
                    </div>
                    <div class="govuk-summary-list__row">
                        <dt class="govuk-summary-list__key">Quota</dt>
                        <dd class="govuk-summary-list__value" id="info-quota">-</dd>
                    </div>
                    <div class="govuk-summary-list__row">
                        <dt class="govuk-summary-list__key">Rounds</dt>
                        <dd class="govuk-summary-list__value" id="info-rounds">-</dd>
                    </div>
                    <div class="govuk-summary-list__row">
                        <dt class="govuk-summary-list__key">Candidates</dt>
                        <dd class="govuk-summary-list__value" id="info-candidates">-</dd>
                    </div>
                </dl>
            </div>
            
            <!-- Chart Container (populated dynamically) -->
            <div id="chart-wrapper" style="display: none;">
                <h2 class="govuk-heading-m">Round-by-Round Results</h2>
                <div id="dynamic-chart-container"></div>
                
                <!-- Sankey Diagram -->
                <div id="sankey-wrapper" style="display: none;">
                    <h2 class="govuk-heading-m">Vote Transfer Flow</h2>
                    <p class="govuk-body">This diagram shows how votes moved between candidates across rounds.</p>
                    <div id="dynamic-sankey-container"></div>
                </div>
                
                <!-- Results Summary -->
                <div id="results-summary" class="results-summary" style="display: none;">
                    <h3 class="govuk-heading-s">Election Outcomes</h3>
                    <div id="outcomes-list"></div>
                </div>
            </div>
            
            <!-- Instructions when no data loaded -->
            <div id="instructions" class="instructions-panel">
                <h3 class="govuk-heading-s">How to Use</h3>
                <ol class="govuk-list govuk-list--number">
                    <li>Select a previous Icenian senate election from the dropdown menu above, or</li>
                    <li>Go to the <a href="/stv">STV Calculator</a> to run your own election.</li>
                    <li>Click "Export for RCVis" to download the results JSON file.</li>
                    <li>Return here and upload that file to see the animated visualization.</li>
                </ol>
                
                <h3 class="govuk-heading-s">Expected File Format</h3>
                <p class="govuk-body">The visualization expects RCVis-compatible JSON with this structure:</p>
                <pre class="code-block"><code>{`{
  "config": {
    "contest": "Election Name",
    "date": "2025-01-09",
    "threshold": "5.000"
  },
  "results": [
    {
      "round": 1,
      "tally": {
        "Alice": "10.000",
        "Bob": "8.000",
        "Carol": "6.000"
      },
      "tallyResults": [...]
    }
  ]
}`}</code></pre>
            </div>

            <!-- =================================================================== -->
            <!-- FACTION ANALYSIS SECTION -->
            <!-- =================================================================== -->
            <div class="faction-analysis-section">
                <h2 class="govuk-heading-l" style="margin-top: 3rem; border-top: 2px solid #ccc; padding-top: 2rem;">
                    üó≥Ô∏è Faction & Similarity Analysis
                </h2>
                <p class="govuk-body-l">
                    Analyze political factions and candidate similarities based on raw ballot data. 
                    This reveals which candidates share voter bases and how votes would flow between them.
                </p>
                
                <!-- Faction Import Section -->
                <div class="import-section govuk-form-group">
                    <h3 class="govuk-heading-m">Load Raw Election Data</h3>
                    <p class="govuk-body">Import the raw STV election JSON file (with ballots) from the <a href="/stv">STV Calculator</a>.</p>
                    
                    <div class="govuk-form-group">
                    <label class="govuk-label govuk-label--s" for="faction-election-selector">
                        Previous Senate Elections
                    </label>
                    <select 
                        id="faction-election-selector" 
                        class="govuk-select"
                        style="width: 100%; max-width: 400px;"
                    >
                        <option value="">-- Select an election --</option>
                    </select>
                    <button type="button" id="load-faction-election-btn" class="icenia-btn" style="margin-top: 0.5rem;">
                        Load Selected Election
                    </button>
                </div>
                
                <div class="govuk-form-group" style="margin-top: 2rem; padding-top: 1.5rem; border-top: 1px solid #ddd;">
                    <label class="govuk-label govuk-label--s" for="faction-file">
                        Or upload custom election file (.json with ballots)
                    </label>
                    <input 
                        type="file" 
                        id="faction-file" 
                        accept=".json"
                        class="govuk-file-upload"
                    />
                    <button type="button" id="load-faction-btn" class="icenia-btn" style="margin-top: 0.5rem;">
                        Analyze Custom File
                    </div>
                    
                    <!-- Error/Status Messages -->
                    <div id="faction-status-message" class="status-message" style="display: none;"></div>
                </div>
                
                <!-- Faction Analysis Results (hidden until data loaded) -->
                <div id="faction-results" style="display: none;">
                    
                    <!-- Election Summary -->
                    <div class="faction-summary">
                        <h3 class="govuk-heading-s">Data Summary</h3>
                        <dl class="govuk-summary-list govuk-summary-list--no-border">
                            <div class="govuk-summary-list__row">
                                <dt class="govuk-summary-list__key">Total Ballots</dt>
                                <dd class="govuk-summary-list__value" id="faction-total-ballots">-</dd>
                            </div>
                            <div class="govuk-summary-list__row">
                                <dt class="govuk-summary-list__key">Candidates Analyzed</dt>
                                <dd class="govuk-summary-list__value" id="faction-candidates">-</dd>
                            </div>
                            <div class="govuk-summary-list__row">
                                <dt class="govuk-summary-list__key">Avg Rankings per Ballot</dt>
                                <dd class="govuk-summary-list__value" id="faction-avg-rankings">-</dd>
                            </div>
                        </dl>
                    </div>
                    
                    <!-- Tab Navigation -->
                    <div class="faction-tabs">
                        <button type="button" class="faction-tab active" data-tab="heatmap">
                            üî• Similarity Heatmap
                        </button>
                        <button type="button" class="faction-tab" data-tab="coalition">
                            ü§ù Coalition Strength
                        </button>
                        <button type="button" class="faction-tab" data-tab="mds">
                            üó∫Ô∏è Political Map
                        </button>
                    </div>
                    
                    <!-- Heatmap Tab -->
                    <div id="tab-heatmap" class="faction-tab-content active">
                        <h3 class="govuk-heading-s">Candidate Correlation Heatmap</h3>
                        <p class="govuk-body">
                            Shows how similar candidates' voter bases are using rank correlation.
                            <strong style="color: #10b981;">Green</strong> = voters rank both similarly (allies).
                            <strong style="color: #ef4444;">Red</strong> = opposing voter bases (rivals).
                        </p>
                        <div id="heatmap-chart" style="height: 600px; width: 100%; border: 1px solid #ddd; border-radius: 8px; background: #fff;"></div>
                    </div>

                    <!-- Coalition Strength Tab -->
                    <div id="tab-coalition" class="faction-tab-content">
                        <h3 class="govuk-heading-s">Coalition Strength Analysis</h3>
                        <p class="govuk-body">
                            Shows how often candidate pairs appear together on ballots and their average ranking proximity.
                            <strong>Higher bars</strong> = stronger coalition potential.
                            Pairs with high co-occurrence and close rankings indicate natural allies.
                        </p>
                        <div id="coalition-chart" style="height: 600px; width: 100%; border: 1px solid #ddd; border-radius: 8px; background: #fff;"></div>
                        <div class="chart-legend">
                            <span class="legend-item"><span class="legend-dot" style="background: #5470c6;"></span> Bar height = Coalition score (co-occurrence √ó ranking proximity)</span>
                        </div>
                    </div>
                    
                    <!-- MDS Map Tab -->
                    <div id="tab-mds" class="faction-tab-content" style="display: none;">
                        <h3 class="govuk-heading-s">Political Distance Map</h3>
                        <p class="govuk-body">
                            A 2D projection where <strong>distance = dissimilarity</strong>.
                            Candidates close together share voters. Candidates far apart have distinct bases.
                            The axes have no predefined meaning (like "left/right") ‚Äî they emerge from the data itself.
                        </p>
                        <div id="mds-chart" style="height: 600px; width: 100%; border: 1px solid #ddd; border-radius: 8px; background: #fff;"></div>
                    </div>
                    
                    <!-- Raw Data Table -->
                    <details class="faction-details">
                        <summary class="govuk-details__summary">
                            <span class="govuk-details__summary-text">View Transfer Probability Matrix</span>
                        </summary>
                        <div class="govuk-details__text">
                            <p class="govuk-body">
                                This table shows the probability that a vote for candidate A will transfer to candidate B 
                                (i.e., B is ranked immediately after A). Read rows as "If you voted for [row], there's X% chance your next choice is [column]."
                            </p>
                            <div id="transfer-matrix-container" style="overflow-x: auto;"></div>
                        </div>
                    </details>
                    
                </div>
                
                <!-- Instructions for Faction Analysis -->
                <div id="faction-instructions" class="instructions-panel" style="margin-top: 1rem;">
                    <h3 class="govuk-heading-s">About This Analysis</h3>
                    <p class="govuk-body">
                        This tool analyzes raw ballot data to reveal political factions and candidate relationships.
                        Unlike the RCVis visualization above (which shows round-by-round results), this analysis 
                        examines the underlying voter preferences directly.
                    </p>
                    
                    <h4 class="govuk-heading-xs">What You'll Learn:</h4>
                    <ul class="govuk-list govuk-list--bullet">
                        <li><strong>Vote Transfer Network:</strong> Who are natural coalition partners?</li>
                        <li><strong>Similarity Heatmap:</strong> Which candidates have overlapping or opposing voter bases?</li>
                        <li><strong>Political Map:</strong> Where do candidates sit in "political space"?</li>
                    </ul>
                    
                    <h4 class="govuk-heading-xs">Required File Format:</h4>
                    <p class="govuk-body">This requires the raw STV election JSON with ballot data:</p>
                    <pre class="code-block"><code>{`{
  "candidates": ["Alice", "Bob", "Carol"],
  "ballots": [
    { "voter": "voter1", "rankings": ["Alice", "Carol", "Bob"] },
    { "voter": "voter2", "rankings": ["Bob", "Alice"] }
  ],
  "nameMatches": { ... }  // Optional: for name normalization
}`}</code></pre>
                </div>
            </div>

        </main>
    </div>

</PageLayout>

<script>
    import * as echarts from 'echarts';
    import { SpeedController, buildSankeyData } from "../../lib/stv-viz";
    
    // Types
    interface SenateElection {
        id: string;
        name: string;
        date: string;
        term: number;
        rcvisUrl: string;
        fullUrl: string;
        type: 'local';
    }
    
        // DOM Elements
    const electionSelector = document.getElementById('election-selector') as HTMLSelectElement;
    const loadElectionBtn = document.getElementById('load-election-btn') as HTMLButtonElement;
        const factionElectionSelector = document.getElementById('faction-election-selector') as HTMLSelectElement;
    const fileInput = document.getElementById('election-file') as HTMLInputElement;
    const loadFileBtn = document.getElementById('load-file-btn') as HTMLButtonElement;
    const statusMessage = document.getElementById('status-message') as HTMLDivElement;
    const electionInfo = document.getElementById('election-info') as HTMLDivElement;
    const chartWrapper = document.getElementById('chart-wrapper') as HTMLDivElement;
    const instructions = document.getElementById('instructions') as HTMLDivElement;
    const dynamicChartContainer = document.getElementById('dynamic-chart-container') as HTMLDivElement;
    const dynamicSankeyContainer = document.getElementById('dynamic-sankey-container') as HTMLDivElement;
    const sankeyWrapper = document.getElementById('sankey-wrapper') as HTMLDivElement;
    const resultsSummary = document.getElementById('results-summary') as HTMLDivElement;
    const outcomesList = document.getElementById('outcomes-list') as HTMLDivElement;
    
    // Chart instances
    let chartInstance: echarts.ECharts | null = null;
    let sankeyInstance: echarts.ECharts | null = null;
    
    // Senate elections data - load at runtime
    let senateElections: SenateElection[] = [];
    
    // Global speed controller instance
    const speedController = new SpeedController();
    
    /**
     * Show a status message to the user
     */
    function showStatus(message: string, type: 'success' | 'error' | 'info' = 'info') {
        statusMessage.textContent = message;
        statusMessage.className = `status-message status-${type}`;
        statusMessage.style.display = 'block';
        
        // Auto-hide success messages
        if (type === 'success') {
            setTimeout(() => {
                statusMessage.style.display = 'none';
            }, 3000);
        }
    }
    
    /**
     * Parse and validate election data from JSON
     * Supports dynamic quota per round for IcenianSTV
     */
    function parseElectionData(jsonData: any): { 
        roundResults: Array<{ round: number; tally: { [key: string]: number }; quota?: number; exhausted?: number; isFinalRound?: boolean }>;
        config: any;
        outcomes: Array<{ type: 'elected' | 'eliminated'; candidate: string; round: number }>;
    } | null {
        try {
            // Validate structure
            if (!jsonData.results || !Array.isArray(jsonData.results)) {
                throw new Error('Invalid format: missing "results" array');
            }
            
            const outcomes: Array<{ type: 'elected' | 'eliminated'; candidate: string; round: number }> = [];
            
            // Convert results to the expected format
            const roundResults = jsonData.results.map((round: any, index: number) => {
                if (!round.tally || typeof round.tally !== 'object') {
                    throw new Error(`Invalid format: round ${index + 1} missing "tally" object`);
                }
                
                // Convert string votes to numbers
                const tally: { [key: string]: number } = {};
                for (const [candidate, votes] of Object.entries(round.tally)) {
                    tally[candidate] = typeof votes === 'string' ? parseFloat(votes) : votes as number;
                }
                
                // Extract outcomes
                if (round.tallyResults && Array.isArray(round.tallyResults)) {
                    for (const result of round.tallyResults) {
                        if (result.elected) {
                            outcomes.push({ type: 'elected', candidate: result.elected, round: round.round });
                        }
                        if (result.eliminated) {
                            outcomes.push({ type: 'eliminated', candidate: result.eliminated, round: round.round });
                        }
                    }
                }
                
                return {
                    round: round.round || index + 1,
                    tally,
                    quota: round.quota !== undefined ? (typeof round.quota === 'string' ? parseFloat(round.quota) : round.quota) : undefined,
                    exhausted: round.exhausted !== undefined ? (typeof round.exhausted === 'string' ? parseFloat(round.exhausted) : round.exhausted) : undefined,
                    isFinalRound: round.isFinalRound || false
                };
            });
            
            return {
                roundResults,
                config: jsonData.config || {},
                outcomes
            };
        } catch (e) {
            console.error('Parse error:', e);
            showStatus(`Error parsing data: ${(e as Error).message}`, 'error');
            return null;
        }
    }
    
    /**
     * Extract all unique candidates from round results (excludes final round winners-only)
     */
    function extractCandidates(roundResults: Array<{ round: number; tally: { [key: string]: number }; isFinalRound?: boolean }>): string[] {
        const candidateSet = new Set<string>();
        roundResults.forEach(round => {
            // Skip final round for candidate extraction as it only shows winners
            if (!round.isFinalRound) {
                Object.keys(round.tally).forEach(candidate => candidateSet.add(candidate));
            }
        });
        return Array.from(candidateSet);
    }
    
    /**
     * Create and initialize the ECharts chart
     * Supports dynamic quota per round (IcenianSTV style)
     */
    function createChart(
        roundResults: Array<{ round: number; tally: { [key: string]: number }; quota?: number; exhausted?: number; isFinalRound?: boolean }>,
        candidates: string[],
        fallbackQuota?: number,
        outcomes?: Array<{ type: 'elected' | 'eliminated'; candidate: string; round: number }>
    ) {
        // Clean up existing chart
        if (chartInstance) {
            chartInstance.dispose();
        }
        
        // Create container HTML
        dynamicChartContainer.innerHTML = `
            <div id="echart-container" style="height: 500px; width: 100%;"></div>
            <div class="chart-controls">
                <div class="playback-controls">
                    <button type="button" class="control-btn" id="prev-btn" title="Previous Round">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M6 6h2v12H6zm3.5 6l8.5 6V6z"/>
                        </svg>
                    </button>
                    <button type="button" class="control-btn play-btn" id="play-btn" title="Play/Pause">
                        <svg class="play-icon" width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M8 5v14l11-7z"/>
                        </svg>
                        <svg class="pause-icon" width="20" height="20" viewBox="0 0 24 24" fill="currentColor" style="display: none;">
                            <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>
                        </svg>
                    </button>
                    <button type="button" class="control-btn" id="next-btn" title="Next Round">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"/>
                        </svg>
                    </button>
                </div>
                <div class="slider-container">
                    <label for="round-slider" class="slider-label">Round: <span id="round-display">1</span> of ${roundResults.length}</label>
                    <input type="range" id="round-slider" class="round-slider" min="1" max="${roundResults.length}" value="1" />
                </div>
                <div class="speed-control">
                    <label for="speed-slider">Speed: <span id="speed-display">1.0x</span></label>
                    <input type="range" id="speed-slider" class="speed-slider" min="0" max="100" value="23" step="1" />
                    <div style="display: flex; justify-content: space-between; font-size: 0.7rem; color: #666; margin-top: 2px;">
                        <span>0.5x</span>
                        <span>~2x</span>
                        <span>10x</span>
                    </div>
                </div>
                <button type="button" class="control-btn download-btn" id="download-btn" title="Download as PNG">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/>
                    </svg>
                </button>
            </div>
        `;
        
        // Initialize ECharts
        const container = document.getElementById('echart-container')!;
        chartInstance = echarts.init(container);
        
        // Color palette
        const colors = [
            '#5470c6', '#91cc75', '#fac858', '#ee6666', '#73c0de',
            '#3ba272', '#fc8452', '#9a60b4', '#ea7ccc', '#48b8d0'
        ];
        
        // State
        let currentRound = 0;
        let isPlaying = false;
        let playInterval: number | null = null;
        // Speed is now managed by the global speedController
        
        // Get controls
        const slider = document.getElementById('round-slider') as HTMLInputElement;
        const roundDisplay = document.getElementById('round-display')!;
        const playBtn = document.getElementById('play-btn')!;
        const prevBtn = document.getElementById('prev-btn')!;
        const nextBtn = document.getElementById('next-btn')!;
        const speedSlider = document.getElementById('speed-slider') as HTMLInputElement;
        const speedDisplay = document.getElementById('speed-display')!;
        const downloadBtn = document.getElementById('download-btn')!;
        
        const maxVoteValue = Math.max(...roundResults.flatMap(r => Object.values(r.tally)));
        
        // Track candidate states across rounds
        const winnerStates = new Map<string, { round: number; votes: number; surplus: number }>(); // candidate -> when they won
        const eliminatedStates = new Map<string, { round: number; votes: number }>(); // candidate -> when eliminated
        
        /**
         * Calculate vote transfers when a candidate is elected or eliminated
         * Returns array of { from, to, amount, fromIndex, toIndex }
         * 'to' can be 'EXHAUSTED' for votes that ran out of preferences
         */
        function calculateVoteTransfers(
            currentRoundIndex: number
        ): Array<{ from: string; to: string; amount: number; fromIndex: number; toIndex: number }> | null {
            if (currentRoundIndex >= roundResults.length - 1) return null;
            if (!outcomes) return null;
            
            const currentRound = roundResults[currentRoundIndex];
            const nextRound = roundResults[currentRoundIndex + 1];
            
            // Get the dynamic quota for this round
            const currentQuota = currentRound.quota ?? fallbackQuota ?? 0;
            if (currentQuota <= 0) return null;
            
            // Special handling for transition to final round (only winners + exhausted)
            if (nextRound.isFinalRound) {
                // In final round transition, only the last winner's surplus goes to exhausted
                const lastElected = outcomes.filter(o => o.type === 'elected' && o.round === currentRound.round);
                if (lastElected.length > 0) {
                    const winner = lastElected[0].candidate;
                    const currentVotes = currentRound.tally[winner] || 0;
                    const surplus = currentVotes - currentQuota;
                    
                    if (surplus > 0.001) {
                        // Only transfer surplus to exhausted
                        return [{
                            from: winner,
                            to: 'EXHAUSTED',
                            amount: surplus,
                            fromIndex: candidates.indexOf(winner),
                            toIndex: -1
                        }];
                    }
                }
                return null; // No other transfers in final round transition
            }
            
            // Check if anyone was elected or eliminated in current round
            const electedInThisRound = outcomes.filter(o => 
                o.type === 'elected' && o.round === currentRound.round
            );
            const eliminatedInThisRound = outcomes.filter(o => 
                o.type === 'eliminated' && o.round === currentRound.round
            );
            
            if (electedInThisRound.length === 0 && eliminatedInThisRound.length === 0) return null;
            
            const transfers: Array<{ from: string; to: string; amount: number; fromIndex: number; toIndex: number }> = [];
            
            // Handle elected candidates (surplus transfers)
            for (const elected of electedInThisRound) {
                const winner = elected.candidate;
                const currentVotes = currentRound.tally[winner] || 0;
                const surplus = currentVotes - currentQuota;
                
                if (surplus <= 0.001) continue; // No meaningful surplus
                
                // Calculate where votes went in next round
                const winnerIndexInCandidates = candidates.indexOf(winner);
                
                // For each remaining candidate, calculate their gain
                for (const candidate of candidates) {
                    if (candidate === winner) continue;
                    
                    const currentCandidateVotes = currentRound.tally[candidate] || 0;
                    const nextCandidateVotes = nextRound.tally[candidate] || 0;
                    const gain = nextCandidateVotes - currentCandidateVotes;
                    
                    if (gain > 0.001) { // Received votes
                        transfers.push({
                            from: winner,
                            to: candidate,
                            amount: gain,
                            fromIndex: winnerIndexInCandidates,
                            toIndex: candidates.indexOf(candidate)
                        });
                    }
                }
            }
            
            // Handle eliminated candidates (all votes transfer)
            for (const eliminated of eliminatedInThisRound) {
                const loser = eliminated.candidate;
                const currentVotes = currentRound.tally[loser] || 0;
                
                if (currentVotes <= 0.001) continue; // No votes to transfer
                
                const loserIndexInCandidates = candidates.indexOf(loser);
                
                let totalTransferred = 0;
                
                // For each remaining candidate, calculate their gain
                for (const candidate of candidates) {
                    if (candidate === loser) continue;
                    
                    const currentCandidateVotes = currentRound.tally[candidate] || 0;
                    const nextCandidateVotes = nextRound.tally[candidate] || 0;
                    const gain = nextCandidateVotes - currentCandidateVotes;
                    
                    if (gain > 0.001) { // Received votes
                        transfers.push({
                            from: loser,
                            to: candidate,
                            amount: gain,
                            fromIndex: loserIndexInCandidates,
                            toIndex: candidates.indexOf(candidate)
                        });
                        totalTransferred += gain;
                    }
                }
                
                // Calculate exhausted votes (votes that didn't transfer to anyone)
                const exhausted = currentVotes - totalTransferred;
                if (exhausted > 0.001) {
                    transfers.push({
                        from: loser,
                        to: 'EXHAUSTED',
                        amount: exhausted,
                        fromIndex: loserIndexInCandidates,
                        toIndex: -1 // Special index for exhausted bin
                    });
                }
            }
            
            return transfers.length > 0 ? transfers : null;
        }
        
        /**
         * Generate chart options for a specific round
         * Uses dynamic quota per round if available
         */
        function getChartOption(roundIndex: number): echarts.EChartsOption {
            const roundData = roundResults[roundIndex];
            if (!roundData) return {};
            
            // Get dynamic quota for this round, fallback to config threshold
            const currentQuota = roundData.quota ?? fallbackQuota ?? 0;
            
            // Prepare data for stacked bars (base, transferred gray, surplus)
            const baseParts: number[] = [];
            const transferredParts: number[] = []; // Gray section for winners' surplus or eliminated votes
            const surplusParts: number[] = []; // Additional surplus if any
            
            candidates.forEach(c => {
                const totalVotes = roundData.tally[c] ?? 0;
                const isWinner = winnerStates.has(c);
                const isEliminated = eliminatedStates.has(c);
                
                if (isEliminated) {
                    // Eliminated: show last known votes in gray (preserve gray bar)
                    const eliminatedInfo = eliminatedStates.get(c)!;
                    baseParts.push(0);
                    transferredParts.push(eliminatedInfo.votes);
                    surplusParts.push(0);
                } else if (roundData.isFinalRound && !isWinner && !roundData.tally[c]) {
                    // In final round, show candidates not in tally (eliminated) with gray bars
                    const lastRoundIndex = roundResults.length - 2; // Second to last round
                    const lastRegularRound = roundResults[lastRoundIndex];
                    const lastVotes = lastRegularRound?.tally[c] || 0;
                    baseParts.push(0);
                    transferredParts.push(lastVotes);
                    surplusParts.push(0);
                } else if (isWinner) {
                    // Winner: green up to their winning quota (dynamic), gray for surplus
                    const winnerInfo = winnerStates.get(c)!;
                    // Find the quota at the round they won
                    const winRound = roundResults.find(r => r.round === winnerInfo.round);
                    const winningQuota = winRound?.quota ?? fallbackQuota ?? 0;
                    baseParts.push(winningQuota);
                    transferredParts.push(Math.max(0, winnerInfo.votes - winningQuota));
                    surplusParts.push(0);
                } else if (totalVotes > currentQuota && currentQuota > 0) {
                    // Has surplus but not yet marked as winner
                    baseParts.push(currentQuota);
                    transferredParts.push(0);
                    surplusParts.push(totalVotes - currentQuota);
                } else {
                    // Regular candidate
                    baseParts.push(totalVotes);
                    transferredParts.push(0);
                    surplusParts.push(0);
                }
            });
            
            const barColors = candidates.map((_, i) => colors[i % colors.length]);
            
            // Calculate max value for consistent y-axis scaling (use max quota across all rounds)
            const maxQuota = Math.max(...roundResults.map(r => r.quota ?? 0), fallbackQuota ?? 0);
            const yAxisMax = Math.max(maxVoteValue * 1.1, maxQuota * 1.2);
            
            const option: echarts.EChartsOption = {
                title: {
                    text: 'Election Results by Round',
                    subtext: `Round ${roundData.round} of ${roundResults.length}${currentQuota > 0 ? ` ‚Ä¢ Quota: ${currentQuota.toFixed(2)}` : ''}`,
                    left: 'center',
                    textStyle: { fontSize: 18, fontWeight: 'bold' },
                    subtextStyle: { fontSize: 14 }
                },
                tooltip: {
                    trigger: 'axis',
                    axisPointer: { type: 'shadow' },
                    formatter: (params: any) => {
                        if (!Array.isArray(params)) return '';
                        const candidate = params[0].name;
                        const totalVotes = roundData.tally[candidate] ?? 0;
                        const surplus = Math.max(0, totalVotes - currentQuota);
                        
                        let result = `<strong>${candidate}</strong><br/>`;
                        result += `Total Votes: ${totalVotes.toFixed(3)}<br/>`;
                        if (currentQuota > 0) {
                            result += `Round Quota: ${currentQuota.toFixed(3)}<br/>`;
                        }
                        if (surplus > 0.001 && currentQuota > 0) {
                            result += `<span style="color: #6b7280;">Surplus: ${surplus.toFixed(3)}</span>`;
                        }
                        return result;
                    }
                },
                grid: {
                    left: '3%',
                    right: '140px', // Make room for exhausted bin
                    bottom: '15%',
                    top: '15%',
                    containLabel: true
                },
                xAxis: {
                    type: 'category',
                    data: candidates,
                    axisLabel: {
                        rotate: candidates.length > 6 ? 45 : 0,
                        interval: 0,
                        fontSize: 12
                    }
                },
                yAxis: {
                    type: 'value',
                    name: 'Votes',
                    nameLocation: 'middle',
                    nameGap: 50,
                    max: yAxisMax,
                    axisLabel: { formatter: (v: number) => v.toFixed(1) }
                },
                series: [
                    {
                        name: 'Base Votes',
                        type: 'bar',
                        stack: 'total',
                        data: baseParts.map((value, index) => {
                            const candidate = candidates[index];
                            const isWinner = winnerStates.has(candidate);
                            const isEliminated = eliminatedStates.has(candidate);
                            return {
                                value,
                                itemStyle: {
                                    color: isWinner ? '#10b981' : (isEliminated ? 'transparent' : barColors[index]),
                                    opacity: value === 0 ? 0 : (isWinner ? 0.85 : 1)
                                }
                            };
                        }),
                        animationDuration: speedController.chartAnimation,
                        animationDurationUpdate: speedController.chartUpdate,
                        animationEasing: 'cubicInOut',
                        animationEasingUpdate: 'cubicInOut',
                        barWidth: '60%',
                        label: { show: false }
                    },
                    {
                        name: 'Transferred/Surplus',
                        type: 'bar',
                        stack: 'total',
                                                data: transferredParts.map((value) => {
                            return {
                                value,
                                itemStyle: {
                                    color: value > 0 ? '#9ca3af' : 'transparent',
                                    opacity: 0.6
                                }
                            };
                        }),
                        animationDuration: speedController.chartAnimation,
                        animationDurationUpdate: speedController.chartUpdate,
                        animationEasing: 'cubicInOut',
                        animationEasingUpdate: 'cubicInOut',
                        barWidth: '60%',
                        label: { show: false }
                    },
                    {
                        name: 'Excess',
                        type: 'bar',
                        stack: 'total',
                        data: surplusParts.map((value, index) => {
                            return {
                                value,
                                itemStyle: {
                                    color: value > 0 ? barColors[index] : 'transparent',
                                    opacity: 0.9
                                }
                            };
                        }),
                        animationDuration: speedController.chartAnimation,
                        animationDurationUpdate: speedController.chartUpdate,
                        animationEasing: 'cubicInOut',
                        animationEasingUpdate: 'cubicInOut',
                        barWidth: '60%',
                        label: {
                            show: true,
                            position: 'top',
                            formatter: (params: any) => {
                                const candidate = candidates[params.dataIndex];
                                const totalVotes = roundData.tally[candidate] ?? 0;
                                const isWinner = winnerStates.has(candidate);
                                const isEliminated = eliminatedStates.has(candidate);
                                if (totalVotes === 0) return '';
                                
                                let label = totalVotes.toFixed(2);
                                
                                // Check if won or eliminated THIS round
                                const wonThisRound = outcomes?.some(o => 
                                    o.type === 'elected' && 
                                    o.candidate === candidate && 
                                    o.round === roundData.round
                                );
                                const eliminatedThisRound = outcomes?.some(o => 
                                    o.type === 'eliminated' && 
                                    o.candidate === candidate && 
                                    o.round === roundData.round
                                );
                                
                                if (wonThisRound) label += ' ‚úì ELECTED';
                                else if (eliminatedThisRound) label += ' ‚úó ELIMINATED';
                                else if (isWinner) label += ' üîí';
                                else if (isEliminated) label += ' üíÄ';
                                
                                return label;
                            },
                            fontSize: 10,
                            fontWeight: 'bold',
                            color: '#000'
                        }
                    }
                ]
            };
            
            // Add quota line if specified (dynamic quota per round)
            if (currentQuota > 0) {
                (option.series as any[]).push({
                    name: 'Quota',
                    type: 'line',
                    markLine: {
                        silent: true,
                        symbol: 'none',
                        lineStyle: { color: '#ff4444', type: 'dashed', width: 2 },
                        data: [{ yAxis: currentQuota, label: { formatter: `Quota: ${currentQuota.toFixed(2)}`, position: 'end' } }]
                    }
                });
            }
            
            // Get current round's exhausted votes
            const currentExhausted = roundData.exhausted ?? 0;
            
            // Add exhausted votes bin graphic in top-right
            (option as any).graphic = [
                {
                    type: 'group',
                    right: 20,
                    top: 60,
                    children: [
                        // Bin container
                        {
                            type: 'rect',
                            shape: { x: 0, y: 0, width: 80, height: 70, r: 4 },
                            style: {
                                fill: '#f3f4f6',
                                stroke: '#9ca3af',
                                lineWidth: 2
                            }
                        },
                        // Bin icon/label
                        {
                            type: 'text',
                            style: {
                                text: 'üóëÔ∏è',
                                x: 40,
                                y: 18,
                                textAlign: 'center',
                                fontSize: 18
                            }
                        },
                        // "Exhausted" label
                        {
                            type: 'text',
                            style: {
                                text: 'Exhausted',
                                x: 40,
                                y: 40,
                                textAlign: 'center',
                                fontSize: 10,
                                fill: '#6b7280',
                                fontWeight: 'bold'
                            }
                        },
                        // Exhausted count
                        {
                            type: 'text',
                            style: {
                                text: currentExhausted > 0 ? currentExhausted.toFixed(2) : '0.00',
                                x: 40,
                                y: 58,
                                textAlign: 'center',
                                fontSize: 11,
                                fill: '#374151',
                                fontWeight: 'bold'
                            }
                        }
                    ]
                }
            ];
            
            return option;
        }
        
        /**
         * Animate vote transfers using ECharts graphics with multi-stage flow
         * Shows bars "flying" from source to recipients
         * 
         * TIMING ARCHITECTURE (all values scaled by speedController):
         * 1. Gold bars spawn and fade in at origin (goldBarSpawnPause)
         * 2. Gold bars fly to destination (goldBarFlight)
         * 3. Gold bars pause at destination, chart updates midway (goldBarLandingPause)
         * 4. Gold bars fade out and are cleaned up
         */
        function animateVoteTransfers(
            transfers: Array<{ from: string; to: string; amount: number; fromIndex: number; toIndex: number }>,
            fromRoundIndex: number,
            callback: () => void
        ) {
            if (!chartInstance) return callback();
            
            const fromRound = roundResults[fromRoundIndex];
            
            // Calculate actual bar width from chart
            const containerWidth = (chartInstance.getDom() as HTMLElement).offsetWidth;
            const availableWidth = containerWidth - 140; // Account for exhausted bin area
            const calculatedBarWidth = Math.max(20, Math.min(80, availableWidth / candidates.length * 0.6));
            
            // Get timing values from speed controller (all properly scaled)
            const spawnPause = speedController.goldBarSpawnPause;
            const flightDuration = speedController.goldBarFlight;
            const landingPause = speedController.goldBarLandingPause;
            const totalDuration = speedController.goldBarTotalDuration;
            
            // Calculate keyframe percentages
            const spawnEndPercent = spawnPause / totalDuration;
            const flightEndPercent = (spawnPause + flightDuration) / totalDuration;
            const fadeStartPercent = (spawnPause + flightDuration + landingPause * 0.7) / totalDuration;
            
            // Group transfers by source candidate to calculate stacking
            const transfersBySource = new Map<number, Array<typeof transfers[0]>>();
            transfers.forEach(transfer => {
                if (!transfersBySource.has(transfer.fromIndex)) {
                    transfersBySource.set(transfer.fromIndex, []);
                }
                transfersBySource.get(transfer.fromIndex)!.push(transfer);
            });
            
            // Sort each group by destination index (leftmost = bottom, rightmost = top)
            transfersBySource.forEach(group => {
                group.sort((a, b) => a.toIndex - b.toIndex);
            });
            
            // Create graphics for each transfer
            const graphics: any[] = [];
            
            transfers.forEach((transfer, idx) => {
                // Get the actual data values from the chart series
                const chartOption: any = chartInstance!.getOption();
                const baseSeriesData = chartOption.series[0].data;
                const transferredSeriesData = chartOption.series[1].data;
                
                // Extract the numeric value from the data object
                                const baseDataItem = baseSeriesData[transfer.fromIndex];
                const baseValue = (typeof baseDataItem === 'object' && baseDataItem !== null) ? baseDataItem.value : (baseDataItem || 0);
                // Get all transfers from this source to calculate stacking
                const sourceTransfers = transfersBySource.get(transfer.fromIndex)!;
                const transferIndexInStack = sourceTransfers.findIndex(t => t === transfer);
                
                // Calculate this bar's position in the stack
                const grayBottomY = baseValue;
                let cumulativeHeightBelow = 0;
                for (let i = 0; i < transferIndexInStack; i++) {
                    cumulativeHeightBelow += sourceTransfers[i].amount;
                }
                
                const thisBarBottomY = grayBottomY + cumulativeHeightBelow;
                const thisBarTopY = thisBarBottomY + transfer.amount;
                
                // Convert to pixel coordinates
                const fromPointBottom = chartInstance!.convertToPixel({ seriesIndex: 0 }, [transfer.fromIndex, thisBarBottomY]);
                const fromPointTop = chartInstance!.convertToPixel({ seriesIndex: 0 }, [transfer.fromIndex, thisBarTopY]);
                
                if (!fromPointBottom || !fromPointTop) return;
                
                // Calculate source bar position
                const barX = fromPointTop[0] - calculatedBarWidth / 2;
                const barHeight = Math.abs(fromPointTop[1] - fromPointBottom[1]);
                const barY = Math.min(fromPointBottom[1], fromPointTop[1]);
                
                // Calculate destination position
                let destX: number, destY: number;
                
                if (transfer.to === 'EXHAUSTED') {
                    // Destination: exhausted bin in top-right
                    const chartDom = chartInstance!.getDom() as HTMLElement;
                    const binX = chartDom.offsetWidth - 100;
                    const binY = 60;
                    const binWidth = 80;
                    const binHeight = 60;
                    destX = binX + binWidth / 2 - calculatedBarWidth / 2;
                    destY = binY + binHeight / 2 - barHeight / 2;
                } else {
                    // Destination: on top of receiving candidate's bar
                    const destCurrentVotes = fromRound.tally[transfer.to] || 0;
                    const toPoint = chartInstance!.convertToPixel({ seriesIndex: 0 }, [transfer.toIndex, destCurrentVotes]);
                    if (!toPoint) return;
                    destX = toPoint[0] - calculatedBarWidth / 2;
                    destY = toPoint[1] - barHeight;
                }
                
                // Create flying gold bar with keyframe animation
                const flyingBar = {
                    id: `transfer-${idx}`,
                    type: 'rect',
                    shape: {
                        x: barX,
                        y: barY,
                        width: calculatedBarWidth,
                        height: barHeight,
                        r: 2
                    },
                    style: {
                        fill: '#fbbf24',
                        opacity: 0,
                        shadowBlur: 20,
                        shadowColor: '#f59e0b',
                        shadowOffsetX: 0,
                        shadowOffsetY: 4
                    },
                    keyframeAnimation: [{
                        duration: totalDuration,
                        easing: 'linear',
                        loop: false,
                        keyframes: [
                            // Start: invisible at origin
                            {
                                percent: 0,
                                shape: { x: barX, y: barY },
                                style: { opacity: 0 }
                            },
                            // Fade in at origin (first half of spawn pause)
                            {
                                percent: spawnEndPercent * 0.5,
                                shape: { x: barX, y: barY },
                                style: { opacity: 0.95, shadowBlur: 25 }
                            },
                            // Hold at origin (end of spawn pause)
                            {
                                percent: spawnEndPercent,
                                shape: { x: barX, y: barY },
                                style: { opacity: 0.95, shadowBlur: 25 }
                            },
                            // Arrive at destination (end of flight)
                            {
                                percent: flightEndPercent,
                                shape: { x: destX, y: destY },
                                style: { opacity: 0.95, shadowBlur: 20 }
                            },
                            // Start fading at destination
                            {
                                percent: fadeStartPercent,
                                shape: { x: destX, y: destY },
                                style: { opacity: 0.95, shadowBlur: 25 }
                            },
                            // Fully faded out
                            {
                                percent: 1,
                                shape: { x: destX, y: destY },
                                style: { opacity: 0 }
                            }
                        ]
                    }]
                };
                
                graphics.push(flyingBar);
            });
            
            // Get exhausted count for current display
            const currentExhausted = fromRound.exhausted ?? 0;
            
            // Exhausted bin graphic (preserved throughout)
            const exhaustedBinGraphic = {
                type: 'group',
                right: 20,
                top: 60,
                children: [
                    {
                        type: 'rect',
                        shape: { x: 0, y: 0, width: 80, height: 70, r: 4 },
                        style: {
                            fill: '#f3f4f6',
                            stroke: '#9ca3af',
                            lineWidth: 2
                        }
                    },
                    {
                        type: 'text',
                        style: {
                            text: 'üóëÔ∏è',
                            x: 40,
                            y: 18,
                            textAlign: 'center',
                            fontSize: 18
                        }
                    },
                    {
                        type: 'text',
                        style: {
                            text: 'Exhausted',
                            x: 40,
                            y: 40,
                            textAlign: 'center',
                            fontSize: 10,
                            fill: '#6b7280',
                            fontWeight: 'bold'
                        }
                    },
                    {
                        type: 'text',
                        style: {
                            text: currentExhausted > 0 ? currentExhausted.toFixed(2) : '0.00',
                            x: 40,
                            y: 58,
                            textAlign: 'center',
                            fontSize: 11,
                            fill: '#374151',
                            fontWeight: 'bold'
                        }
                    }
                ]
            };
            
            // Add graphics to chart
            chartInstance.setOption({
                graphic: [exhaustedBinGraphic, ...graphics]
            }, { replaceMerge: ['graphic'] });
            
            // Schedule chart update during landing pause (bars are at destination but still visible)
            const chartUpdateTime = speedController.chartUpdateTriggerTime;
            setTimeout(() => {
                // Update chart to next round - bars will animate to new heights
                callback();
                
                // Remove gold bars after they've faded out
                setTimeout(() => {
                    chartInstance!.setOption({
                        graphic: [exhaustedBinGraphic]
                    }, { replaceMerge: ['graphic'] });
                }, speedController.goldBarCleanupDelay);
            }, chartUpdateTime);
        }
        
        /**
         * Show a specific round and update frozen winners
         * With animated vote transfers when applicable
         * 
         * TIMING FLOW (all scaled by speedController):
         * 1. Display current round briefly (preAnimationDisplay)
         * 2. Mark winners/eliminated, update chart to show gray sections
         * 3. Start gold bar animation (goldBarTotalDuration)
         *    - During landing pause, chart updates to new round
         * 4. Gold bars fade, cleanup, signal completion
         * 
         * @param roundIndex - The round to show
         * @param skipAnimation - Whether to skip animation
         * @param onComplete - Callback when round display is fully complete
         */
        function showRound(roundIndex: number, skipAnimation: boolean = false, onComplete?: () => void) {
            if (roundIndex < 0 || roundIndex >= roundResults.length) {
                if (onComplete) onComplete();
                return;
            }
            
            // Check if we're moving forward by one round and should show transfer animation
            // Use dynamic quota - check if any quota exists for current round
            const currentRoundQuota = roundResults[currentRound]?.quota ?? fallbackQuota ?? 0;
            const shouldAnimate = !skipAnimation && 
                                  roundIndex === currentRound + 1 && 
                                  currentRoundQuota > 0 && 
                                  outcomes;
            
            if (shouldAnimate) {
                // Check for vote transfers
                const transfers = calculateVoteTransfers(currentRound);
                
                if (transfers && transfers.length > 0) {
                    // Phase 1: Show current round in original colors with labels
                    chartInstance!.setOption(getChartOption(currentRound), { notMerge: false });
                    
                    // Phase 2: After brief display, start animation sequence
                    setTimeout(() => {
                        // Mark winners and eliminated from this round
                        const currentRoundData = roundResults[currentRound];
                        const roundQuota = currentRoundData.quota ?? fallbackQuota ?? 0;
                        outcomes!.forEach(outcome => {
                            if (outcome.type === 'elected' && outcome.round === currentRoundData.round) {
                                const votes = currentRoundData.tally[outcome.candidate] || 0;
                                winnerStates.set(outcome.candidate, {
                                    round: currentRoundData.round,
                                    votes: votes,
                                    surplus: Math.max(0, votes - roundQuota)
                                });
                            }
                            if (outcome.type === 'eliminated' && outcome.round === currentRoundData.round) {
                                eliminatedStates.set(outcome.candidate, {
                                    round: currentRoundData.round,
                                    votes: currentRoundData.tally[outcome.candidate] || 0
                                });
                            }
                        });
                        
                        // Update chart to show gray sections (this happens instantly before gold bars spawn)
                        chartInstance!.setOption(getChartOption(currentRound), { notMerge: false });
                        
                        // Start gold bar animation - callback will update chart to next round
                        animateVoteTransfers(transfers, currentRound, () => {
                            updateRoundDisplay(roundIndex);
                            
                            // Signal completion after cleanup delay
                            setTimeout(() => {
                                if (onComplete) onComplete();
                            }, speedController.goldBarCleanupDelay);
                        });
                    }, speedController.preAnimationDisplay);
                    
                    return; // Exit early, callback will handle completion
                }
            }
            
            // No animation needed, just show the round
            updateRoundDisplay(roundIndex);
            if (onComplete) onComplete();
        }
        
        /**
         * Helper to display round
         */
        function updateRoundDisplay(roundIndex: number) {
            // Update winner and eliminated states up to this round
            winnerStates.clear();
            eliminatedStates.clear();
            
            if (outcomes) {
                outcomes.forEach(outcome => {
                    const outcomeRound = outcome.round;
                    if (outcomeRound <= roundResults[roundIndex].round) {
                        if (outcome.type === 'elected') {
                            // Find the round where they were elected to get their votes and quota
                            const electedRoundIndex = roundResults.findIndex(r => r.round === outcomeRound);
                            if (electedRoundIndex >= 0) {
                                const electedRoundData = roundResults[electedRoundIndex];
                                const votes = electedRoundData.tally[outcome.candidate] || 0;
                                const roundQuota = electedRoundData.quota ?? fallbackQuota ?? 0;
                                winnerStates.set(outcome.candidate, {
                                    round: outcomeRound,
                                    votes: votes,
                                    surplus: Math.max(0, votes - roundQuota)
                                });
                            }
                        } else if (outcome.type === 'eliminated') {
                            const eliminatedRoundIndex = roundResults.findIndex(r => r.round === outcomeRound);
                            if (eliminatedRoundIndex >= 0) {
                                eliminatedStates.set(outcome.candidate, {
                                    round: outcomeRound,
                                    votes: roundResults[eliminatedRoundIndex].tally[outcome.candidate] || 0
                                });
                            }
                        }
                    }
                });
            }
            
            currentRound = roundIndex;
            chartInstance!.setOption(getChartOption(roundIndex), { notMerge: false });
            slider.value = String(roundIndex + 1);
            roundDisplay.textContent = String(roundIndex + 1);
        }
        
        /**
         * Toggle play/pause
         */
        function togglePlay() {
            if (isPlaying) {
                stopPlay();
            } else {
                startPlay();
            }
        }
        
        function startPlay() {
            isPlaying = true;
            updatePlayButton();
            
            // Function to advance to next round - only called after previous round completes
            function advanceRound() {
                if (!isPlaying) return; // Stop if user paused
                
                const nextRound = currentRound < roundResults.length - 1 ? currentRound + 1 : 0;
                
                // Show the round and wait for completion before scheduling next
                showRound(nextRound, false, () => {
                    // This callback fires when the round display is fully complete
                    // Only schedule next round if still playing
                    if (isPlaying) {
                        // Pause between rounds (scaled by speed)
                        playInterval = window.setTimeout(advanceRound, speedController.betweenRoundsPause);
                    }
                });
            }
            
            // Start the first advance
            advanceRound();
        }
        
        function stopPlay() {
            isPlaying = false;
            updatePlayButton();
            if (playInterval) {
                clearTimeout(playInterval);
                playInterval = null;
            }
        }
        
        function updatePlayButton() {
            const playIcon = playBtn.querySelector('.play-icon') as HTMLElement;
            const pauseIcon = playBtn.querySelector('.pause-icon') as HTMLElement;
            playIcon.style.display = isPlaying ? 'none' : 'block';
            pauseIcon.style.display = isPlaying ? 'block' : 'none';
        }
        
        // Event listeners
        slider.addEventListener('input', () => { stopPlay(); showRound(parseInt(slider.value, 10) - 1, true); }); // Skip animation on manual slider
        playBtn.addEventListener('click', togglePlay);
        prevBtn.addEventListener('click', () => { stopPlay(); if (currentRound > 0) showRound(currentRound - 1, true); }); // Skip animation going backward
        nextBtn.addEventListener('click', () => { stopPlay(); if (currentRound < roundResults.length - 1) showRound(currentRound + 1); }); // Show animation going forward
        speedSlider.addEventListener('input', () => {
            const sliderValue = parseInt(speedSlider.value, 10);
            
            // Convert slider value to speed multiplier using the SpeedController
            const newSpeed = SpeedController.sliderToSpeed(sliderValue);
            speedController.speedMultiplier = newSpeed;
            
            speedDisplay.textContent = `${newSpeed.toFixed(1)}x`;
            
            // If playing, restart to apply new speed
            if (isPlaying) { 
                stopPlay(); 
                startPlay(); 
            }
        });
        downloadBtn.addEventListener('click', () => {
            const dataUrl = chartInstance!.getDataURL({ type: 'png', pixelRatio: 2, backgroundColor: '#ffffff' });
            const link = document.createElement('a');
            link.download = `election-round-${currentRound + 1}.png`;
            link.href = dataUrl;
            link.click();
        });
        
        // Handle resize
        const resizeObserver = new ResizeObserver(() => chartInstance?.resize());
        resizeObserver.observe(container);
        
        // Initialize speed controller from slider default value
        const initialSliderValue = parseInt(speedSlider.value, 10);
        const initialSpeed = SpeedController.sliderToSpeed(initialSliderValue);
        speedController.speedMultiplier = initialSpeed;
        speedDisplay.textContent = `${initialSpeed.toFixed(1)}x`;
        
        // Initial render (skip animation on first load)
        showRound(0, true);
    }
    
        function createSankeyDiagram(
        roundResults: any[],
        candidates: string[],
        fallbackQuota: number = 0,
        outcomes?: any[]
    ) {
        if (sankeyInstance) sankeyInstance.dispose();
        dynamicSankeyContainer.innerHTML = `<div id="sankey-chart" style="height: 700px; width: 100%;"></div>`;
        const container = document.getElementById('sankey-chart')!;
        sankeyInstance = echarts.init(container);
        const sankeyData = buildSankeyData(roundResults, candidates, fallbackQuota, outcomes || []);
        const option: any = {
            tooltip: {
                trigger: 'item',
                triggerOn: 'mousemove',
                formatter: (p: any) => p.dataType === 'edge' ? `${p.data.source} ‚Üí ${p.data.target}<br/>Votes: ${p.value.toFixed(2)}` : `${p.name}<br/>Total: ${p.value.toFixed(2)} votes`
            },
            series: [{
                type: 'sankey', emphasis: { focus: 'adjacency' }, nodeAlign: 'left', nodeGap: 12, nodeWidth: 25, layoutIterations: 0,
                data: sankeyData.nodes, links: sankeyData.links,
                lineStyle: { color: 'gradient', curveness: 0.5, opacity: 0.3 },
                label: {
                    fontSize: 11,
                    formatter: (p: any) => {
                        const match = p.name.match(/^R\d+: (.+)$/);
                        if (match) return match[1] === 'Exhausted' ? 'üóëÔ∏è Exhausted' : match[1];
                        return p.name.startsWith('Final: ') ? (p.name.substring(7) === 'Exhausted' ? 'üóëÔ∏è Exhausted' : `‚úì ${p.name.substring(7)}`) : p.name;
                    }
                }
            }]
        };
        sankeyInstance.setOption(option);
        const resizeObserver = new ResizeObserver(() => sankeyInstance?.resize());
        resizeObserver.observe(container);
        sankeyWrapper.style.display = 'block';
    }
    
    /**
     * Display election information
     */
    function displayElectionInfo(config: any, roundResults: Array<{ round: number; tally: { [key: string]: number }; quota?: number }>, candidates: string[]) {
        const infoContest = document.getElementById('info-contest')!;
        const infoDate = document.getElementById('info-date')!;
        const infoQuota = document.getElementById('info-quota')!;
        const infoRounds = document.getElementById('info-rounds')!;
        const infoCandidates = document.getElementById('info-candidates')!;
        
        infoContest.textContent = config.contest || 'Unknown';
        infoDate.textContent = config.date || 'Unknown';
        
        // Show quota info - prefer dynamic quota range if available
        const quotas = roundResults.map(r => r.quota).filter(q => q !== undefined && q > 0) as number[];
        if (quotas.length > 0) {
            const minQuota = Math.min(...quotas);
            const maxQuota = Math.max(...quotas);
            if (Math.abs(maxQuota - minQuota) > 0.01) {
                infoQuota.textContent = `${minQuota.toFixed(3)} - ${maxQuota.toFixed(3)} (dynamic)`;
            } else {
                infoQuota.textContent = maxQuota.toFixed(3);
            }
        } else if (config.threshold) {
            infoQuota.textContent = parseFloat(config.threshold).toFixed(3);
        } else {
            infoQuota.textContent = 'Not specified';
        }
        
        infoRounds.textContent = String(roundResults.length);
        infoCandidates.textContent = candidates.join(', ');
        
        electionInfo.style.display = 'block';
    }
    
    /**
     * Display election outcomes
     */
    function displayOutcomes(outcomes: Array<{ type: 'elected' | 'eliminated'; candidate: string; round: number }>) {
        if (outcomes.length === 0) {
            resultsSummary.style.display = 'none';
            return;
        }
        
        const html = outcomes.map(outcome => {
            const icon = outcome.type === 'elected' ? '‚úì' : '‚úó';
            const cssClass = outcome.type === 'elected' ? 'outcome-elected' : 'outcome-eliminated';
            const label = outcome.type === 'elected' ? 'Elected' : 'Eliminated';
            return `<div class="outcome-item ${cssClass}">
                <span class="outcome-icon">${icon}</span>
                <span class="outcome-candidate">${outcome.candidate}</span>
                <span class="outcome-label">${label} in Round ${outcome.round}</span>
            </div>`;
        }).join('');
        
        outcomesList.innerHTML = html;
        resultsSummary.style.display = 'block';
    }
    
    /**
     * Load and display election data
     */
    function loadElectionData(data: any) {
        const parsed = parseElectionData(data);
        if (!parsed) return;
        
        const { roundResults, config, outcomes } = parsed;
        const candidates = extractCandidates(roundResults);
        
        // Use the threshold from the config as fallback (initial quota)
        // But prefer per-round quotas for IcenianSTV dynamic quota support
        let quota: number | undefined;
        if (config.threshold) {
            quota = parseFloat(config.threshold);
        }
        
        // Update UI
        displayElectionInfo(config, roundResults, candidates);
        createChart(roundResults, candidates, quota, outcomes);
        createSankeyDiagram(roundResults, candidates, quota, outcomes);
        displayOutcomes(outcomes);
        
        // Show chart, hide instructions
        chartWrapper.style.display = 'block';
        instructions.style.display = 'none';
        statusMessage.style.display = 'none';
        
        showStatus('Election data loaded successfully!', 'success');
    }
    
    // Wait for DOM to be fully loaded
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initializeHandlers);
    } else {
        initializeHandlers();
    }
    
        function populateElectionDropdown() {
        const options = senateElections.map(e => `<option value="${e.rcvisUrl}">${e.name} (${e.date})</option>`).join('');
        if (electionSelector) electionSelector.innerHTML += options;
        if (factionElectionSelector) factionElectionSelector.innerHTML += options;
    }

    function initializeHandlers() {
        // Load senate elections data
        fetch('/stv-data/senate-elections.json')
            .then(res => res.json())
            .then((data: SenateElection[]) => {
                senateElections = data;
                populateElectionDropdown();
            })
            .catch(err => {
                console.error('Failed to load elections list:', err);
            });

        loadElectionBtn.addEventListener('click', () => {
            const url = electionSelector.value;
            if (!url) return showStatus('Please select an election.', 'error');
            fetch(url).then(r => r.json()).then(loadElectionData).catch(() => showStatus('Failed to load election.', 'error'));
        });
        
        // Load custom file
        loadFileBtn.addEventListener('click', () => {
            const file = fileInput.files?.[0];
            if (!file) {
                showStatus('Please select a file first.', 'error');
                return;
            }
        
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target?.result as string);
                    loadElectionData(data);
                } catch (err) {
                    showStatus('Invalid JSON file. Please check the file format.', 'error');
                }
            };
            reader.onerror = () => {
                showStatus('Error reading file.', 'error');
            };
            reader.readAsText(file);
        });
    }
     
