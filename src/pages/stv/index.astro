---
import PageLayout from "@layouts/page.astro";
---

<PageLayout chin={false} title="Icenian STV Calculator" description="This calculator implements Single Transferable Vote (STV) as used in Icenian elections.">

    <!-- Page Header -->
    <div class="page-header">
        <h1 class="govuk-heading-xl" style="margin-bottom: 10px;">Icenian STV Calculator</h1>
        <p class="govuk-body-l">This calculator implements Single Transferable Vote (STV) as used in Icenian elections.</p>
    </div>

    <div class="govuk-width-container">
        <main class="govuk-main-wrapper govuk-body" id="main-content">
            
            <!-- Mode Selection -->
            <div class="mode-selection govuk-form-group">
                <fieldset class="govuk-fieldset">
                    <legend class="govuk-fieldset__legend govuk-fieldset__legend--s">
                        Input Mode
                    </legend>
                    <div class="govuk-radios govuk-radios--inline">
                        <div class="govuk-radios__item">
                            <input class="govuk-radios__input" id="mode-simple" name="input-mode" type="radio" value="simple" checked>
                            <label class="govuk-label govuk-radios__label" for="mode-simple">
                                Simple Format
                            </label>
                        </div>
                        <div class="govuk-radios__item">
                            <input class="govuk-radios__input" id="mode-discord" name="input-mode" type="radio" value="discord">
                            <label class="govuk-label govuk-radios__label" for="mode-discord">
                                Discord Paste
                            </label>
                        </div>
                    </div>
                </fieldset>
                
                <!-- Import Election -->
                <div class="govuk-!-margin-top-6" id="import-section">
                    <h2 class="govuk-heading-s">Or Import Previous Election</h2>
                    <p class="govuk-body-s">Load a previously exported election file to resume your work.</p>
                    <input
                        type="file"
                        id="import-file-input"
                        accept=".json"
                        style="display: none;"
                    />
                    <div class="icenia-button-group">
                        <button class="icenia-btn icenia-btn-secondary" id="import-election-button" type="button">
                            Import Election File
                        </button>
                        <button class="icenia-btn icenia-btn-warning" id="clear-session-start" type="button">
                            Clear Session
                        </button>
                    </div>
                </div>
            </div>

            <!-- Simple Mode (original interface) -->
            <div id="simple-mode" class="stv-calculator">
                <div class="govuk-form-group">
                    <label class="govuk-label govuk-label--s" for="candidates">
                        Candidates (one per line)
                    </label>
                    <textarea 
                        class="icenia-textarea" 
                        id="candidates" 
                        rows="8"
                        placeholder="Enter candidate names, one per line"
                    ></textarea>
                </div>
                
                <div class="govuk-form-group">
                    <label class="govuk-label govuk-label--s" for="seats">
                        Number of Seats to Fill
                    </label>
                    <input 
                        class="icenia-input govuk-input--width-5" 
                        id="seats" 
                        type="number" 
                        value="5"
                        min="1"
                    />
                </div>
                
                <div class="govuk-form-group">
                    <label class="govuk-label govuk-label--s" for="ballots">
                        Ballots (one per line, format: "voter: cand1, cand2, cand3")
                    </label>
                    <textarea 
                        class="icenia-textarea" 
                        id="ballots" 
                        rows="15"
                        placeholder="recycler: Ratat0ing, Dr_Bacon_hair, hsmnewfriend&#10;alzubloxxer11: Dr_Bacon_hair, hsmnewfriend, Ratat0ing"
                    ></textarea>
                </div>
                
                <button class="icenia-btn" id="calculate" type="button">
                    Calculate Results
                </button>
                
                <button class="icenia-btn icenia-btn-secondary" id="loadExample" type="button">
                    Load Example Data
                </button>
            </div>

            <!-- Discord Mode -->
            <div id="discord-mode" class="stv-calculator" style="display: none;">
                <div class="govuk-form-group">
                    <label class="govuk-label govuk-label--s" for="discord-candidates">
                        Official Candidates (paste from Discord, one per line)
                    </label>
                    <div class="govuk-hint">
                        Include @mentions or plain names. Example: @Mayor Ratat0ing or DinoCompactor
                    </div>
                    <textarea 
                        class="icenia-textarea" 
                        id="discord-candidates" 
                        rows="10"
                        placeholder="@DinoCompactor&#10;@IsraelGPT&#10;@CreepilyCreep&#10;@Dr Bacon Hair(real)"
                    ></textarea>
                </div>

                <div class="govuk-form-group">
                    <label class="govuk-label govuk-label--s" for="discord-seats">
                        Number of Seats to Fill
                    </label>
                    <input 
                        class="icenia-input govuk-input--width-5" 
                        id="discord-seats" 
                        type="number" 
                        value="5"
                        min="1"
                    />
                </div>
                
                <div class="govuk-form-group">
                    <label class="govuk-label govuk-label--s" for="discord-ballots">
                        Raw Discord Ballot Data (paste entire voting channel)
                    </label>
                    <div class="govuk-hint">
                        Copy and paste the entire Discord channel content including usernames, timestamps, and votes
                    </div>
                    <textarea 
                        class="icenia-textarea" 
                        id="discord-ballots" 
                        rows="20"
                        placeholder="Ex-Councilor TheRecycler — 03/01/2026 06:12&#10;Ratat0ing&#10;Dr Bacon Hair&#10;HsmNewfriend"
                    ></textarea>
                </div>
                
                <button class="icenia-btn" id="parse-discord" type="button">
                    Parse Discord Data
                </button>
            </div>

            <!-- Name Matching Interface -->
            <div id="name-matching" style="display: none;">
                <div class="icenia-button-group govuk-!-margin-bottom-6">
                    <button class="icenia-btn icenia-btn-secondary" id="export-election" type="button">
                        Export Election
                    </button>
                    <button class="icenia-btn icenia-btn-warning" id="clear-session" type="button">
                        Clear Session
                    </button>
                </div>
                
                <h2 class="govuk-heading-m">Review Candidate Name Matches</h2>
                <p class="govuk-body">
                    The following names were found in ballots. Please confirm matches or mark as invalid.
                </p>
                
                <!-- Correlation Table -->
                <div id="correlation-table-section" style="display: none;" class="govuk-!-margin-bottom-6">
                    <details class="govuk-details">
                        <summary class="govuk-details__summary">
                            <span class="govuk-details__summary-text">
                                View Learned Name Correlations (<span id="correlation-count">0</span>)
                            </span>
                        </summary>
                        <div class="govuk-details__text">
                            <p class="govuk-body-s">These name patterns have been learned during this session:</p>
                            <table class="govuk-table">
                                <thead class="govuk-table__head">
                                    <tr class="govuk-table__row">
                                        <th scope="col" class="govuk-table__header">Voter Name Pattern</th>
                                        <th scope="col" class="govuk-table__header">Matched Candidate</th>
                                    </tr>
                                </thead>
                                <tbody class="govuk-table__body" id="correlation-table-body">
                                </tbody>
                            </table>
                        </div>
                    </details>
                </div>
                
                <div id="name-match-list"></div>
                <div class="icenia-button-group govuk-!-margin-top-6">
                    <button class="icenia-btn icenia-btn-secondary" id="back-to-discord" type="button">
                        ← Back to Edit
                    </button>
                    <!-- <button class="icenia-btn" id="confirm-matches" type="button">
                        Review Ballots →
                    </button> -->
                </div>
            </div>
            
            <!-- Duplicate Voter Resolution Interface -->
            <div id="duplicate-voters" style="display: none;">
                <h2 class="govuk-heading-m">Resolve Duplicate Voters</h2>
                <p class="govuk-body">
                    Some voters submitted multiple ballots. Please select which ballot to use for each voter.
                </p>
                
                <div id="duplicate-voters-content"></div>
                
                <div class="icenia-button-group govuk-!-margin-top-6">
                    <button class="icenia-btn icenia-btn-secondary" id="back-to-name-matching-from-duplicates" type="button">
                        ← Back to Name Matching
                    </button>
                    <button class="icenia-btn" id="proceed-to-ballot-review" type="button">
                        Proceed to Ballot Review →
                    </button>
                </div>
            </div>
            
            <!-- Ballot Review Interface -->
            <div id="ballot-review" style="display: none;">
                <div class="icenia-button-group govuk-!-margin-bottom-6">
                    <button class="icenia-btn icenia-btn-secondary" id="export-election-review" type="button">
                        Export Election
                    </button>
                    <button class="icenia-btn icenia-btn-warning" id="clear-session-review" type="button">
                        Clear Session
                    </button>
                </div>
                
                <h2 class="govuk-heading-m">Review Ballots</h2>
                <p class="govuk-body">
                    Review each voter's ballot with the name mappings applied. You can edit mappings using the dropdowns.
                </p>
                
                <div id="ballot-review-progress" class="match-progress"></div>
                <div id="ballot-review-content"></div>
                
                <div class="icenia-button-group govuk-!-margin-top-6">
                    <button class="icenia-btn icenia-btn-secondary" id="back-to-name-matching" type="button">
                        ← Back
                    </button>
                    <!-- <button class="icenia-btn" id="calculate-from-review" type="button">
                        Calculate Results →
                    </button> -->
                </div>
            </div>
                
                <div id="results" style="display: none;">
                    <h2 class="govuk-heading-m">Results</h2>

                    <div class="govuk-form-group" style="max-width: 480px; margin-bottom: 20px;">
                        <label class="govuk-label" for="election-name">
                            Election name (for exports)
                        </label>
                        <div class="govuk-hint">Used in exported file names and RCVis metadata.</div>
                        <input class="govuk-input" id="election-name" name="election-name" type="text" placeholder="e.g. 2026-01 Senate Election">
                    </div>
                    
                    <div class="govuk-form-group" style="max-width: 300px; margin-bottom: 20px;">
                        <label class="govuk-label" for="results-seats">
                            Number of winners
                        </label>
                        <input class="govuk-input" id="results-seats" name="results-seats" type="number" min="1" value="5" style="width: 100px;">
                        <button class="icenia-btn" id="recalculate-results" type="button" style="margin-left: 10px;">
                            Recalculate
                        </button>
                    </div>
                    
                    <div id="log" class="stv-log"></div>
                    <div id="winners" class="stv-winners"></div>
                    
                    <div class="icenia-button-group govuk-!-margin-top-6">
                        <button class="icenia-btn" id="export-results" type="button">
                            Export Election
                        </button>
                        <button class="icenia-btn" id="export-rcvis" type="button">
                            Export for RCVis
                        </button>
                        <button class="icenia-btn icenia-btn-secondary" id="return-to-start" type="button">
                            Return to Start (Remember to Export!)
                        </button>
                    </div>
                </div>
            </div>
        </main>
    </div>
    
    <style is:global>
        .stv-calculator {
            max-width: 800px;
        }
        
        .mode-selection {
            max-width: 800px;
            margin-bottom: 30px;
        }
        
        .stv-log {
            background: #f3f2f1;
            padding: 20px;
            border-radius: 4px;
            margin: 20px 0;
            font-family: monospace;
            white-space: pre-wrap;
            max-height: none;
            overflow: visible;
        }

        .stv-winners {
            background: #00703c;
            color: white !important;
            padding: 20px;
            border-radius: 4px;
            font-weight: bold !important;
        }

        .stv-winners strong {
            font-weight: 900 !important;
            color: white !important;
        }
        
        .stv-log-win {
            color: #00703c;
            font-weight: 700;
        }
        
        .stv-log-elim {
            color: #d4351c;
        }

        #name-matching {
            max-width: 900px;
        }

        .name-match-item {
            background: white;
            border: 2px solid #1d70b8;
            padding: 25px;
            margin-bottom: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .match-progress {
            text-align: center;
            margin-bottom: 20px;
            font-size: 1.1em;
            color: #505a5f;
            font-weight: bold;
        }

        .match-navigation {
            margin-top: 25px;
        }

        .icenia-button-group {
            display: flex !important;
            gap: 16px !important;
            flex-wrap: wrap;
            align-items: center;
        }

        .match-navigation.icenia-button-group {
            display: flex;
            gap: 16px;
        }

        .icenia-button-group > button {
            margin: 0 !important;
        }

        .icenia-button-group button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .match-nav-button {
            flex: 1;
            max-width: 200px;
        }

        .match-nav-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .confirmation-list {
            max-height: 500px;
            overflow-y: auto;
            border: 1px solid #b1b4b6;
            border-radius: 4px;
            padding: 15px;
            background: #f8f8f8;
        }

        .confirmation-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            margin-bottom: 10px;
            background: white;
            border-radius: 4px;
            border: 1px solid #ddd;
        }

        .confirmation-item .found-name {
            font-weight: bold;
            color: #0b0c0c;
        }

        .confirmation-item .arrow {
            color: #505a5f;
            margin: 0 10px;
        }

        .confirmation-item .matched-name {
            color: #00703c;
            font-weight: 600;
        }

        .confirmation-item .matched-name.invalid {
            color: #d4351c;
            font-style: italic;
        }

        .confirmation-item .edit-link {
            cursor: pointer;
            color: #1d70b8;
            text-decoration: underline;
            font-size: 0.9em;
        }

        .confirmation-item .edit-link:hover {
            color: #003078;
        }

        .name-match-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .found-name {
            font-weight: bold;
            font-size: 1.1em;
        }

        .match-count {
            color: #505a5f;
            font-size: 0.9em;
        }

        .match-options {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }

        .match-option {
            padding: 8px 12px;
            border: 2px solid #b1b4b6;
            border-radius: 4px;
            background: white;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            font-weight: normal;
        }

        .match-option:hover,
        .match-option:focus {
            border-color: #1d70b8;
            background: #f3f6fc;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            outline: none;
        }

        .match-option.selected {
            background: #1d70b8 !important;
            color: white !important;
            border-color: #1d70b8 !important;
            font-weight: bold !important;
            box-shadow: 0 2px 6px rgba(29, 112, 184, 0.3) !important;
        }

        .match-option.selected::before {
            content: '✓ ';
            font-weight: bold;
            margin-right: 4px;
        }

        .match-option.invalid {
            background: #d4351c !important;
            color: white !important;
            border-color: #d4351c !important;
            font-weight: bold !important;
            box-shadow: 0 2px 6px rgba(212, 53, 28, 0.3) !important;
        }

        .match-option.invalid::before {
            content: '✗ ';
            font-weight: bold;
            margin-right: 4px;
        }

        .match-option.not-ballot.selected,
        .match-option.not-ballot.selected::before {
            /* Make not-ballot selected visually similar to invalid selected */
        }

        .match-option.not-ballot.selected {
            background: #d4351c !important;
            color: white !important;
            border-color: #d4351c !important;
            font-weight: bold !important;
            box-shadow: 0 2px 6px rgba(212, 53, 28, 0.3) !important;
        }

        .match-option.not-ballot.selected::before {
            content: '✗ ';
            font-weight: bold;
            margin-right: 4px;
        }

        .correlation-warning {
            background: #fff3cd;
            border-left: 3px solid #ffc107;
            padding: 4px 8px;
            margin: 0;
            display: inline-block;
            font-size: 0.85em;
        }

        .correlation-warning::before {
            content: '⚠ ';
            color: #856404;
        }

        .correlation-warning-text {
            color: #856404;
        }

        .correlation-warning-text {
            color: #856404;
            font-weight: 600;
            flex: 1;
        }

        .manual-select-wrapper {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #ddd;
        }

        .manual-select-wrapper label {
            display: block;
            font-size: 0.9em;
            color: #505a5f;
            margin-bottom: 5px;
        }

        /* Duplicate Voters Styles */
        #duplicate-voters {
            max-width: 1200px;
        }

        .duplicate-voter-card {
            background: white;
            border: 2px solid #f47738;
            border-radius: 8px;
            margin-bottom: 30px;
            padding: 20px;
        }

        .duplicate-voter-card h3 {
            margin-top: 0;
            color: #f47738;
            font-size: 1.25em;
        }

        .duplicate-ballot-option {
            border: 2px solid #b1b4b6;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 15px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .duplicate-ballot-option:hover {
            border-color: #1d70b8;
            background: #f3f2f1;
        }

        .duplicate-ballot-option.selected {
            border-color: #1d70b8;
            background: #e8f4f8;
            border-width: 3px;
        }

        .duplicate-ballot-option.selected::before {
            content: '✓ ';
            color: #1d70b8;
            font-weight: bold;
            font-size: 1.2em;
        }

        .duplicate-ballot-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .duplicate-ballot-timestamp {
            color: #66d9ef;
            font-family: monospace;
        }

        .duplicate-ballot-rankings {
            background: #2b2b2b;
            color: #f8f8f2;
            padding: 10px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            max-height: 200px;
            overflow-y: auto;
        }

        .duplicate-ballot-rankings div {
            padding: 2px 0;
        }

        .duplicate-ballot-warning {
            color: #d4351c;
            font-style: italic;
            margin-top: 5px;
        }

        /* Ballot Review Styles */
        #ballot-review {
            max-width: 1200px;
        }

        .ballot-review-card {
            background: white;
            border: 2px solid #1d70b8;
            border-radius: 8px;
            margin-bottom: 20px;
            overflow: hidden;
        }

        .ballot-review-header {
            background: #1d70b8;
            color: white;
            padding: 15px 20px;
            font-weight: bold;
            font-size: 1.1em;
        }

        .ballot-column {
            min-width: 0; /* Ensure columns can shrink */
            /* No width or display properties here to avoid conflicts */
        }

        .ballot-column-header {
            font-weight: bold;
            font-size: 0.9em;
            color: #505a5f;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .ballot-original {
            background: #f8f8f8;
            border: 1px solid #ddd;
            border-radius: 6px;
            padding: 15px;
            box-sizing: border-box;
        }

        .ballot-mapping {
            background: #f3f6fc;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            padding: 15px 10px;
            min-width: 200px;
        }

        .ballot-result {
            background: white;
            border-left: 1px solid #ddd;
        }

        .ballot-original-entry {
            padding: 8px 10px;
            margin-bottom: 5px;
            background: white;
            border-radius: 4px;
            border: 1px solid #ddd;
            font-family: monospace;
            font-size: 0.9em;
            width: 100%;
        }

        .ballot-mapping-row {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 0;
            width: 100%;
            border-bottom: 1px solid #e0e6f0;
        }

        .ballot-mapping-row:last-child {
            border-bottom: none;
        }

        .mapping-arrow {
            color: #1d70b8;
            font-size: 1.2em;
            flex-shrink: 0;
        }

        .mapping-count {
            background: #e0e6f0;
            color: #1d70b8;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.75em;
            font-weight: bold;
            flex-shrink: 0;
        }

        .mapping-dropdown {
            flex: 1;
            font-size: 0.85em;
            padding: 4px 6px;
            border: 1px solid #b1b4b6;
            border-radius: 4px;
            max-width: 150px;
        }

        .ballot-result-entry {
            padding: 8px 10px;
            margin-bottom: 5px;
            background: #e8f5e9;
            border-radius: 4px;
            border: 1px solid #c8e6c9;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .ballot-result-rank {
            background: #00703c;
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.85em;
            flex-shrink: 0;
        }

        .ballot-result-name {
            color: #00703c;
            font-weight: 600;
        }

        .ballot-result-skipped {
            background: #fff3cd;
            border-color: #ffc107;
        }

        .ballot-result-skipped .ballot-result-name {
            color: #856404;
            font-style: italic;
        }

        .ballot-result-removed {
            background: #f8d7da;
            border-color: #f5c6cb;
        }

        .ballot-result-removed .ballot-result-name {
            color: #721c24;
            font-style: italic;
            text-decoration: line-through;
        }

        .ballot-nav-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
        }

        .ballot-summary {
            background: #f3f2f1;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 20px;
        }

        .ballot-summary-stat {
            display: inline-block;
            margin-right: 20px;
        }

        .ballot-summary-stat strong {
            color: #1d70b8;
        }

        /* NEW: Redesigned Ballot Review Styles */
        .ballot-review-card {
            max-width: 100%;
        }

        .ballot-review-card.ballot-modified {
            border-color: #ffc107;
        }

        .ballot-review-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modified-badge {
            background: #ffc107;
            color: #000;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 0.85em;
            font-weight: bold;
        }

        .ballot-review-body {
            display: flex !important;
            flex-direction: column !important;
            gap: 0 !important;
            width: 100% !important;
            max-width: 100% !important;
        }
        
        .ballot-row {
            display: grid !important;
            grid-template-columns: 1fr 1fr !important;
            gap: 0 !important;
            width: 100% !important;
        }

        /* Header row styling to position column titles correctly */
        .ballot-row.ballot-row-header {
            border-bottom: 2px solid #ddd !important;
            background: transparent !important;
        }

        .ballot-row.ballot-row-header .ballot-row-original,
        .ballot-row.ballot-row-header .ballot-row-structured {
            padding: 12px 10px !important;
            align-items: flex-end !important;
            border-bottom: none !important;
            min-height: auto !important;
            display: flex !important;
            align-items: center !important;
        }

        .ballot-row-original,
        .ballot-row-structured {
            padding: 2px 10px !important;
            border-bottom: 1px solid #444 !important;
            min-height: 28px !important;
            display: flex !important;
            align-items: center !important;
        }

        .ballot-row-original {
            background: #2b2b2b !important;
            color: #f8f8f2 !important;
            font-family: 'Courier New', Consolas, monospace !important;
            font-size: 0.85em !important;
            white-space: pre-wrap !important;
            overflow-wrap: anywhere !important;
        }

        .ballot-row-structured {
            background: #1e1e1e !important;
            color: #e0e0e0 !important;
        }

        .ballot-original-full {
            background: #2b2b2b;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 6px;
            font-family: 'Courier New', Consolas, monospace;
            font-size: 0.9em;
            white-space: pre-wrap;
            line-height: 1.6;
            max-height: 500px;
            overflow-y: auto;
            overflow-x: auto;
            min-width: 0; /* Allow to shrink */
        }

        .voter-line {
            color: #66d9ef;
            font-weight: bold;
            min-height: 28px;
            display: flex;
            align-items: center;
        }

        .ranking-line {
            color: #f8f8f2;
            min-height: 44px;
            display: flex;
            align-items: center;
            padding: 8px 0;
        }

        .ballot-structured {
            background: #ffffff;
            padding: 0px;
            border-radius: 6px;
            border: 2px solid #1d70b8;
            min-width: 0 !important; /* Allow to shrink */
            box-sizing: border-box;
        }

        .structured-header {
            display: none; /* Hidden since voter is now in header */
        }

        .structured-rankings {
            max-height: 450px;
            overflow-y: auto;
        }

        .rank-row {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            background: white;
            border-radius: 4px;
            border: 1px solid #ddd;
            min-height: 44px;
            width: 100%;
            box-sizing: border-box;
        }

        /* Candidate - Green */
        .rank-row-candidate {
            background: #e8f5e9 !important;
            border-color: #c8e6c9 !important;
        }

        .rank-row-candidate .rank-number {
            background: #00703c;
            color: white;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.95em;
        }

        /* Duplicate - Yellow/Orange */
        .rank-row-duplicate {
            background: #fff3cd !important;
            border-color: #ffc107 !important;
        }

        .rank-row-duplicate .rank-number-duplicate {
            background: #ffc107;
            color: #000;
            padding: 4px 8px;
            border-radius: 12px;
            font-weight: bold;
            font-size: 0.75em;
        }

        /* Empty Line - Light Gray */
        .rank-row-empty {
            background: #f8f8f8 !important;
            border-color: #e0e0e0 !important;
            opacity: 0.7;
        }

        .rank-row-empty .rank-dropdown {
            color: #999;
            font-style: italic;
        }

        /* Voter Header - Blue */
        .rank-row-voter {
            background: #e3f2fd !important;
            border-color: #90caf9 !important;
        }

        .rank-row-voter .rank-dropdown {
            color: #1976d2;
            font-weight: 600;
        }

        /* Timecode - Purple */
        .rank-row-timecode {
            background: #f3e5f5 !important;
            border-color: #ce93d8 !important;
        }

        .rank-row-timecode .rank-dropdown {
            color: #7b1fa2;
            font-family: monospace;
        }

        /* Not a Candidate - Red with strikethrough */
        .rank-row-not-candidate {
            background: #ffebee !important;
            border-color: #ef9a9a !important;
        }

        .rank-row-not-candidate .rank-dropdown {
            color: #c62828;
            text-decoration: line-through;
            font-style: italic;
        }

        /* Not a Ballot Entry - Pink with strikethrough */
        .rank-row-not-ballot {
            background: #fce4ec !important;
            border-color: #f48fb1 !important;
        }

        .rank-row-not-ballot .rank-dropdown {
            color: #880e4f;
            text-decoration: line-through;
            font-style: italic;
        }

        .rank-number {
            font-weight: bold;
            color: #1d70b8;
            width: 30px;
            flex-shrink: 0;
        }

        .rank-dropdown {
            flex: 1;
            padding: 6px 8px;
            border: 1px solid #b1b4b6;
            border-radius: 4px;
            font-size: 0.9em;
            width: 100%;
        }

        .rank-move-btn {
            background: #f3f2f1;
            border: 1px solid #b1b4b6;
            border-radius: 4px;
            width: 28px;
            height: 28px;
            cursor: pointer;
            font-size: 1em;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .rank-move-btn:hover:not(:disabled) {
            background: #e0e0e0;
        }

        .rank-move-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .rank-remove {
            background: #d4351c;
            color: white;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            cursor: pointer;
            font-weight: bold;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .rank-remove:hover {
            background: #942514;
        }

        .add-ranking-container {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px dashed #ddd;
            display: flex;
            gap: 10px;
        }

        .add-ranking-dropdown {
            flex: 1;
            padding: 8px;
            border: 1px solid #b1b4b6;
            border-radius: 4px;
            font-size: 0.9em;
        }

        .add-ranking {
            padding: 8px 16px;
            background: #00703c;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            flex-shrink: 0;
        }

        .add-ranking:hover {
            background: #005a30;
        }

        .reset-ballot-btn {
            margin-top: 15px;
            width: 100%;
            padding: 10px;
            background: #505a5f;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        }

        .reset-ballot-btn:hover {
            background: #383f43;
        }

    </style>

    <script>
        import { Ballot, STV, getCandidateNumber } from "../../lib/stv";
        import { cleanCandidateName, simplifyVoterName, extractVoterName, parseDiscordBallots } from "../../lib/discord-parser";

        // State for Discord mode
        let inputMode: 'simple' | 'discord' = 'simple';
        let currentBallotIndex = 0;
        
        type StructuredLineType = 'candidate' | 'empty' | 'voter' | 'timecode' | 'not-candidate' | 'not-ballot' | 'duplicate';
        type StructuredLine = { type: StructuredLineType; value?: string };

        let parsedData: {
            candidates: string[];
            ballots: Array<{voter: string, rankings: string[]}>;
            seats: number;
            electionName: string;
            nameMatches: Map<string, string | null>;
            uniqueNames: string[];
            currentNameIndex: number;
            nameCounts: Map<string, number>;
            learnedCorrelations: Map<string, string | null>;
            correlationInfluences: Map<string, Set<string>>;
            hasCorrelationWarning: boolean;
            ballotOverrides: Map<string, {rank: number, candidate: string}[]>;
            originalBallotText: Map<string, string>;
            reviewedNames: Set<string>;
            duplicateSelections: Map<string, number>;
            ballotStructuredLines: Map<string, StructuredLine[]>;
            ballotManuallyModified: Set<string>;
            roundResults?: any[];
        } = {
            candidates: [],
            ballots: [],
            seats: 5,
            electionName: '',
            nameMatches: new Map(),
            uniqueNames: [],
            currentNameIndex: 0,
            nameCounts: new Map(),
            learnedCorrelations: new Map(),
            correlationInfluences: new Map(),
            hasCorrelationWarning: false,
            ballotOverrides: new Map(),
            originalBallotText: new Map(),
            reviewedNames: new Set(),
            duplicateSelections: new Map(),
            ballotStructuredLines: new Map(),
            ballotManuallyModified: new Set()
        };

        // --- Helper Functions ---

        function getElectionName(): string {
            const input = document.getElementById('election-name') as HTMLInputElement;
            const name = (input?.value || parsedData.electionName || '').trim();
            parsedData.electionName = name;
            return name;
        }

        function slugifyElectionName(name: string): string {
            return name
                .toLowerCase()
                .replace(/[^a-z0-9]+/gi, '-')
                .replace(/-{2,}/g, '-')
                .replace(/^-+|-+$/g, '');
        }

        function buildExportFilename(prefix: string, extension = 'json'): string {
            const name = getElectionName();
            const dateStr = new Date().toISOString().split('T')[0];
            const slug = slugifyElectionName(name);
            const base = slug ? `${prefix}-${slug}` : `${prefix}-${dateStr}`;
            return `${base}.${extension}`;
        }

        function parseOfficialCandidatesLocal(text: string) {
            const lines = text.split('\n').map(l => l.trim()).filter(l => l.length > 0);
            const candidates: string[] = [];
            for (let line of lines) {
                const cleaned = cleanCandidateName(line);
                if (cleaned) candidates.push(cleaned);
            }
            return candidates;
        }

        function fuzzyMatch(name1: string, name2: string) {
            const normalizeChars = (str: string) => str
                .replace(/0/g, 'o')
                .replace(/1/g, 'i')
                .replace(/3/g, 'e')
                .replace(/5/g, 's')
                .replace(/7/g, 't');
            
            const n1 = normalizeChars(name1.toLowerCase()).replace(/[^a-z0-9]/g, '');
            const n2 = normalizeChars(name2.toLowerCase()).replace(/[^a-z0-9]/g, '');
            
            if (n1 === n2) return 1.0;
            if (n1.includes(n2) || n2.includes(n1)) return 0.95;
            
            const words1 = name1.toLowerCase().split(/\s+/);
            const words2 = name2.toLowerCase().split(/\s+/);
            const shorter = n1.length < n2.length ? n1 : n2;
            const longer = n1.length < n2.length ? n2 : n1;
            
            if (shorter.length >= 3 && shorter.length <= 5 && longer.includes(shorter)) {
                if (longer.startsWith(shorter)) return 0.9;
                return 0.85;
            }
            
            if (longer.startsWith(shorter) && shorter.length >= 3) return 0.88;
            if (shorter.length >= 4 && longer.includes(shorter)) return 0.82;
            
            let matchedWords = 0;
            let totalWords = Math.max(words1.length, words2.length);
            
            for (let w1 of words1) {
                for (let w2 of words2) {
                    const cleanW1 = w1.replace(/[^a-z0-9]/g, '');
                    const cleanW2 = w2.replace(/[^a-z0-9]/g, '');
                    if (cleanW1 === cleanW2 && cleanW1.length > 0) {
                        matchedWords++;
                        break;
                    }
                    if (cleanW1.length >= 4 && cleanW2.length >= 4) {
                        if (cleanW1.includes(cleanW2) || cleanW2.includes(cleanW1)) {
                            matchedWords += 0.7;
                            break;
                        }
                        if (cleanW1.startsWith(cleanW2) || cleanW2.startsWith(cleanW1)) {
                            matchedWords += 0.6;
                            break;
                        }
                    }
                }
            }
            
            if (matchedWords > 0) return Math.min(0.75, 0.4 + (matchedWords / totalWords) * 0.5);
            
            let commonChars = 0;
            const chars1 = n1.split('');
            const chars2 = n2.split('');
            for (let char of chars1) {
                if (chars2.includes(char)) commonChars++;
            }
            const overlapRatio = commonChars / Math.max(n1.length, n2.length);
            if (overlapRatio > 0.6) return 0.5;
            
            return 0.0;
        }

        // --- UI Rendering Functions ---

        function updateCorrelationTable() {
            const tableBody = document.getElementById('correlation-table-body');
            const section = document.getElementById('correlation-table-section');
            const countEl = document.getElementById('correlation-count');
            if (!tableBody || !section || !countEl) return;
            
            const correlations = Array.from(parsedData.learnedCorrelations.entries());
            countEl.textContent = correlations.length.toString();
            
            if (correlations.length === 0) {
                section.style.display = 'none';
                return;
            }
            
            section.style.display = 'block';
            tableBody.innerHTML = correlations.map(([pattern, candidate]) => {
                const display = candidate === null
                    ? '<em style="color: #d4351c;">(Not a candidate)</em>'
                    : candidate === '__NOT_A_BALLOT__'
                        ? '<em style="color: #505a5f;">(Not a ballot entry)</em>'
                        : candidate;
                return `
                <tr class="govuk-table__row">
                    <td class="govuk-table__cell">${pattern}</td>
                    <td class="govuk-table__cell">${display}</td>
                </tr>
            `;
            }).join('');
        }

        function renderCurrentName() {
            const container = document.getElementById('name-match-list');
            if (!container) return;
            
            if (parsedData.currentNameIndex >= parsedData.uniqueNames.length) {
                checkForDuplicates();
                return;
            }
            
            const foundName = parsedData.uniqueNames[parsedData.currentNameIndex];
            const count = parsedData.nameCounts.get(foundName) || 0;
            
            // Find suggestions
            const suggestions = parsedData.candidates
                .map(c => ({ name: c, score: fuzzyMatch(foundName, c) }))
                .filter(s => s.score > 0.5)
                .sort((a, b) => b.score - a.score);
            
            const currentMatch = parsedData.nameMatches.get(foundName);
            
            // Auto-select best match if not already set
            if (currentMatch === undefined && suggestions.length > 0 && suggestions[0].score > 0.7) {
                parsedData.nameMatches.set(foundName, suggestions[0].name);
                parsedData.learnedCorrelations.set(foundName, suggestions[0].name);
            }
            
            const effectiveMatch = parsedData.nameMatches.get(foundName);
            
            container.innerHTML = `
                <div class="match-progress">
                    Reviewing name ${parsedData.currentNameIndex + 1} of ${parsedData.uniqueNames.length}
                </div>
                
                <div class="govuk-inset-text" style="margin-top: 10px; font-size: 0.85em;">
                    <strong>Keyboard shortcuts:</strong>
                    <span style="display: block; margin-top: 5px;">
                        <kbd style="background: #f3f2f1; padding: 2px 6px; border: 1px solid #b1b4b6; border-radius: 3px; font-family: monospace;">←</kbd><kbd style="background: #f3f2f1; padding: 2px 6px; border: 1px solid #b1b4b6; border-radius: 3px; font-family: monospace;">→</kbd> or <kbd style="background: #f3f2f1; padding: 2px 6px; border: 1px solid #b1b4b6; border-radius: 3px; font-family: monospace;">Enter</kbd><kbd style="background: #f3f2f1; padding: 2px 6px; border: 1px solid #b1b4b6; border-radius: 3px; font-family: monospace;">Shift+Enter</kbd> Navigate • 
                        <kbd style="background: #f3f2f1; padding: 2px 6px; border: 1px solid #b1b4b6; border-radius: 3px; font-family: monospace;">1</kbd>-<kbd style="background: #f3f2f1; padding: 2px 6px; border: 1px solid #b1b4b6; border-radius: 3px; font-family: monospace;">9</kbd> Quick select
                        <br>
                        <kbd style="background: #f3f2f1; padding: 2px 6px; border: 1px solid #b1b4b6; border-radius: 3px; font-family: monospace;">N</kbd> Not candidate • 
                        <kbd style="background: #f3f2f1; padding: 2px 6px; border: 1px solid #b1b4b6; border-radius: 3px; font-family: monospace;">M</kbd> Not Ballot Entry • 
                        <kbd style="background: #f3f2f1; padding: 2px 6px; border: 1px solid #b1b4b6; border-radius: 3px; font-family: monospace;">W</kbd> Focus dropdown
                    </span>
                </div>
                
                <div class="name-match-item">
                    <div class="name-match-header">
                        <span class="found-name">${foundName}</span>
                        <span class="match-count">Found in ${count} ballot${count === 1 ? '' : 's'}</span>
                    </div>
                    
                    <p class="govuk-body-s">Match this name to an official candidate:</p>
                    
                    <div class="match-options">
                        ${suggestions.map((s, i) => `
                            <button class="match-option ${effectiveMatch === s.name ? 'selected' : ''}" 
                                    data-index="${i + 1}"
                                    onclick="window.selectMatch('${foundName.replace(/'/g, "\\'")}', '${s.name.replace(/'/g, "\\'")}')">
                                ${i + 1}. ${s.name} (${Math.round(s.score * 100)}%)
                            </button>
                        `).join('')}

                        <button data-type="invalid" class="match-option ${effectiveMatch === null ? 'invalid selected' : ''}"
                            onclick="window.selectMatch('${foundName.replace(/'/g, "\\'")}', '__INVALID__')">
                            N. Not a Candidate (skip)
                        </button>

                        <button data-type="not-ballot" class="match-option ${effectiveMatch === '__NOT_A_BALLOT__' ? 'not-ballot selected' : ''}"
                            onclick="window.selectMatch('${foundName.replace(/'/g, "\\'")}', '__NOT_A_BALLOT__')">
                            M. Not a Ballot Entry (remove)
                        </button>
                    </div>
                    
                    <div class="manual-select-wrapper">
                        <label for="manual-select-${parsedData.currentNameIndex}">Or select manually:</label>
                        <select class="govuk-select" id="manual-select-${parsedData.currentNameIndex}" 
                                onchange="window.selectMatch('${foundName.replace(/'/g, "\\'")}', this.value)">
                            <option value="">-- Select Candidate --</option>
                            ${parsedData.candidates.map(c => `
                                <option value="${c}" ${effectiveMatch === c ? 'selected' : ''}>${c}</option>
                            `).join('')}
                            <option value="__INVALID__" ${effectiveMatch === null ? 'selected' : ''}>Not a candidate - skip ranking</option>
                            <option value="__NOT_A_BALLOT__" ${effectiveMatch === '__NOT_A_BALLOT__' ? 'selected' : ''}>Not a ballot entry - remove</option>
                        </select>
                    </div>

                    <div class="match-navigation icenia-button-group">
                        <button class="icenia-btn icenia-btn-secondary match-nav-button" onclick="window.prevName()" ${parsedData.currentNameIndex === 0 ? 'disabled' : ''}>
                            ← Previous
                        </button>
                        <button class="icenia-btn match-nav-button" onclick="window.nextName()">
                            ${parsedData.currentNameIndex === parsedData.uniqueNames.length - 1 ? 'Finish Matching →' : 'Next →'}
                        </button>
                    </div>
                </div>
            `;
        }

        function checkForDuplicates() {
            const voterBallots = new Map<string, number[]>();
            parsedData.ballots.forEach((b, index) => {
                // Extract base voter name (remove #2, #3, etc suffix)
                const baseVoter = b.voter.replace(/#\d+$/, '');
                if (!voterBallots.has(baseVoter)) voterBallots.set(baseVoter, []);
                voterBallots.get(baseVoter)!.push(index);
            });
            
            const duplicates = Array.from(voterBallots.entries()).filter(([voter, indices]) => indices.length > 1);
            
            if (duplicates.length > 0) {
                document.getElementById('name-matching')!.style.display = 'none';
                document.getElementById('duplicate-voters')!.style.display = 'block';
                renderDuplicateVoters(duplicates);
            } else {
                document.getElementById('name-matching')!.style.display = 'none';
                document.getElementById('ballot-review')!.style.display = 'block';
                renderBallotReview();
            }
        }

        function renderDuplicateVoters(duplicates: [string, number[]][]) {
            const container = document.getElementById('duplicate-voters-content');
            if (!container) return;
            
            // Store for keyboard navigation
            allDuplicateVoters = duplicates.map(([voter, indices]) => ({
                voter: voter,
                ballotIndices: indices
            }));
            
            container.innerHTML = duplicates.map(([voter, indices]) => {
                // Sort ballots by timestamp (newest first)
                const sortedIndices = [...indices].sort((a, b) => {
                    const ballotA = parsedData.ballots[a];
                    const ballotB = parsedData.ballots[b];
                    const textA = parsedData.originalBallotText.get(ballotA.voter) || '';
                    const textB = parsedData.originalBallotText.get(ballotB.voter) || '';
                    const timeA = textA.match(/—\s*(\d{1,2}\/\d{1,2}\/\d{4}\s+\d{1,2}:\d{2}\s+[ap]m)/i)?.[1];
                    const timeB = textB.match(/—\s*(\d{1,2}\/\d{1,2}\/\d{4}\s+\d{1,2}:\d{2}\s+[ap]m)/i)?.[1];
                    if (!timeA || !timeB) return 0;
                    return new Date(timeB).getTime() - new Date(timeA).getTime();
                });
                
                // Default selection: newest ballot with valid rankings
                if (!parsedData.duplicateSelections.has(voter)) {
                    let defaultIdx = -1;
                    for (const idx of sortedIndices) {
                        const ballot = parsedData.ballots[idx];
                        const validRankings = ballot.rankings.filter(name => {
                            const match = parsedData.nameMatches.get(name);
                            return match && match !== '__NOT_A_BALLOT__';
                        });
                        if (validRankings.length > 0) {
                            defaultIdx = idx;
                            break;
                        }
                    }
                    if (defaultIdx === -1 && sortedIndices.length > 0) {
                        defaultIdx = sortedIndices[0];
                    }
                    if (defaultIdx !== -1) {
                        parsedData.duplicateSelections.set(voter, defaultIdx);
                    }
                }
                
                return `
                <div class="duplicate-voter-card">
                    <h3>Voter: ${voter} (${indices.length} ballots found)</h3>
                    <p class="govuk-body-s">Select which ballot to keep:</p>
                    ${sortedIndices.map((idx, i) => {
                        const ballot = parsedData.ballots[idx];
                        const isSelected = parsedData.duplicateSelections.get(voter) === idx;
                        const originalText = parsedData.originalBallotText.get(ballot.voter) || '';
                        // Try multiple timestamp patterns. If only a time is present (e.g. "— 20:35"),
                        // assume today's date for display.
                        let timestamp = 'Unknown time';
                        const fullAmPmMatch = originalText.match(/—\s*(\d{1,2}\/\d{1,2}\/\d{4}\s+\d{1,2}:\d{2}\s*(?:am|pm))/i);
                        if (fullAmPmMatch) {
                            timestamp = fullAmPmMatch[1];
                        } else {
                            // match date + 24h time (no am/pm)
                            const full24Match = originalText.match(/—\s*(\d{1,2}\/\d{1,2}\/\d{4}\s+\d{1,2}:\d{2})/i);
                            if (full24Match) {
                                const [datePart, timePart] = full24Match[1].split(/\s+/);
                                const [hh, mm] = timePart.split(':').map(n => parseInt(n, 10));
                                const hour12 = hh % 12 === 0 ? 12 : hh % 12;
                                const ampm = hh >= 12 ? 'pm' : 'am';
                                timestamp = `${datePart} ${hour12}:${String(mm).padStart(2, '0')} ${ampm}`;
                            } else {
                                // match time-only, optionally with am/pm
                                const timeOnlyMatch = originalText.match(/—\s*(\d{1,2}:\d{2})(?:\s*(am|pm))?/i);
                                if (timeOnlyMatch) {
                                    const hh = parseInt(timeOnlyMatch[1].split(':')[0], 10);
                                    const mm = parseInt(timeOnlyMatch[1].split(':')[1], 10);
                                    const ampmPart = timeOnlyMatch[2];
                                    const now = new Date();
                                    const month = now.getMonth() + 1;
                                    const day = now.getDate();
                                    const year = now.getFullYear();
                                    let displayHour = hh;
                                    let displayAmPm = 'am';
                                    if (ampmPart) {
                                        displayAmPm = ampmPart.toLowerCase();
                                    } else {
                                        // treat as 24-hour time
                                        displayAmPm = hh >= 12 ? 'pm' : 'am';
                                        displayHour = hh % 12 === 0 ? 12 : hh % 12;
                                    }
                                    timestamp = `${month}/${day}/${year} ${displayHour}:${String(mm).padStart(2, '0')} ${displayAmPm}`;
                                }
                            }
                        }
                        
                        const validRankings = ballot.rankings.filter(name => {
                            const match = parsedData.nameMatches.get(name);
                            return match && match !== '__NOT_A_BALLOT__';
                        });
                        
                        return `
                            <div class="duplicate-ballot-option ${isSelected ? 'selected' : ''}" onclick="window.resolveDuplicate('${voter.replace(/'/g, "\\'")}', ${idx})">
                                <div class="duplicate-ballot-header">
                                    <span>Ballot #${i + 1}</span>
                                    <span class="duplicate-ballot-timestamp">${timestamp}</span>
                                </div>
                                <div class="duplicate-ballot-rankings">
                                    ${ballot.rankings.length === 0 
                                        ? '<div style="color: #999; font-style: italic;">No rankings found</div>'
                                        : ballot.rankings.map((r, rIdx) => {
                                            const match = parsedData.nameMatches.get(r);
                                            if (match && match !== '__NOT_A_BALLOT__') {
                                                return `<div style="color: #50fa7b;">${rIdx + 1}. ${r} → ${match}</div>`;
                                            } else if (match === '__NOT_A_BALLOT__') {
                                                return `<div style="color: #999;">${rIdx + 1}. ${r} → (removed)</div>`;
                                            } else {
                                                return `<div style="color: #ff5555;">${rIdx + 1}. ${r} → (invalid)</div>`;
                                            }
                                        }).join('')
                                    }
                                    ${validRankings.length > 0 ? `<div style="margin-top: 8px; color: #50fa7b; font-weight: 600;">${validRankings.length} valid ranking${validRankings.length === 1 ? '' : 's'}</div>` : '<div style="margin-top: 8px; color: #ff5555; font-weight: 600;">0 valid rankings</div>'}
                                </div>
                            </div>
                        `;
                    }).join('')}
                </div>
            `;
            }).join('');
        }

        function getBallotRankings(voter: string, ballot: {voter: string, rankings: string[]}) {
            if (parsedData.ballotOverrides.has(voter)) {
                return parsedData.ballotOverrides.get(voter)!;
            }
            return ballot.rankings
                .map(r => parsedData.nameMatches.get(r))
                .filter((r): r is string => !!r && r !== '__NOT_A_BALLOT__')
                .map((c, i) => ({ rank: i + 1, candidate: c }));
        }

        function escapeHtml(text: string) {
            if (!text) return '';
            return text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
        }

        function classifyOriginalLine(text: string, voter: string, allowVoterLine: boolean): StructuredLine {
            if (!text) return { type: 'empty' };
            const t = text.trim();
            if (t.length === 0) return { type: 'empty' };
            
            // Check if it's the voter header (only if we haven't seen one yet)
            if (allowVoterLine) {
                try {
                    const simplifiedLine = simplifyVoterName(text || '');
                    // Strip #N suffix from voter name before comparing
                    const baseVoter = (voter || '').replace(/#\d+$/, '');
                    const simplifiedVoter = simplifyVoterName(baseVoter);
                    
                    // Primary check: Extract canonical voter from original ballot text
                    const originalText = parsedData.originalBallotText.get(voter) || '';
                    const firstLine = originalText.split('\n')[0];
                    const extractedVoter = extractVoterName(firstLine);
                    const simplifiedExtracted = simplifyVoterName(extractedVoter || '');
                    
                    // Exact match or lenient startsWith/contains check
                    if (simplifiedLine && simplifiedVoter && simplifiedExtracted) {
                        if (simplifiedLine === simplifiedVoter ||
                            simplifiedLine === simplifiedExtracted ||
                            simplifiedLine.startsWith(simplifiedVoter) ||
                            simplifiedVoter.startsWith(simplifiedLine) ||
                            simplifiedLine.startsWith(simplifiedExtracted) ||
                            simplifiedExtracted.startsWith(simplifiedLine)) {
                            return { type: 'voter' };
                        }
                    } else if (simplifiedLine && simplifiedVoter) {
                        // Fallback lenient check without extracted voter
                        if (simplifiedLine === simplifiedVoter ||
                            simplifiedLine.startsWith(simplifiedVoter) ||
                            simplifiedVoter.startsWith(simplifiedLine)) {
                            return { type: 'voter' };
                        }
                    }
                } catch (e) {}
                
                // If the line looks like a voter header (contains long dash or '—' or ' - ')
                if (/[\u2013\u2014\-–—]/.test(t) && /[A-Za-z]/.test(t)) return { type: 'voter' };
            }
            
            // If the line contains a date/time pattern, treat as timecode
            if (/\d{1,2}[:\/]\d{1,2}/.test(t) || /\d{1,4}\/\d{1,4}\/\d{2,4}/.test(t)) return { type: 'timecode' };
            
            // Check if it's a candidate from name matching
            const cleaned = cleanCandidateName(text || '');
            if (cleaned) {
                const matched = parsedData.nameMatches.get(cleaned);
                if (matched && matched !== '__NOT_A_BALLOT__') {
                    return { type: 'candidate', value: matched };
                }
                if (matched === null) {
                    return { type: 'not-candidate' };
                }
                if (matched === '__NOT_A_BALLOT__') {
                    return { type: 'not-ballot' };
                }
            }
            
            // If the line contains an @mention or looks like a name, treat as candidate-like
            if (/^@?\w[\w\s\._-]{0,50}$/.test(t)) return { type: 'not-candidate' };
            // Fallback to 'other' -> treat as not-candidate
            return { type: 'not-candidate' };
        }

        function getOrInitStructuredLines(voter: string): StructuredLine[] {
            if (parsedData.ballotStructuredLines.has(voter)) {
                return parsedData.ballotStructuredLines.get(voter)!;
            }
            
            // Initialize from original ballot text
            const originalText = parsedData.originalBallotText.get(voter) || '';
            const originalLines = originalText.split('\n');
            const structured: StructuredLine[] = [];
            const usedCandidates = new Set<string>();
            let foundVoterLine = false;
            
            for (const line of originalLines) {
                const classified = classifyOriginalLine(line, voter, !foundVoterLine);
                
                // Track if we found a voter line
                if (classified.type === 'voter') {
                    foundVoterLine = true;
                }
                
                // Check for duplicates
                if (classified.type === 'candidate' && classified.value) {
                    if (usedCandidates.has(classified.value)) {
                        structured.push({ type: 'duplicate', value: classified.value });
                    } else {
                        usedCandidates.add(classified.value);
                        structured.push(classified);
                    }
                } else {
                    structured.push(classified);
                }
            }
            
            parsedData.ballotStructuredLines.set(voter, structured);
            return structured;
        }

        function getUsedCandidates(structuredLines: StructuredLine[]): Set<string> {
            const used = new Set<string>();
            for (const line of structuredLines) {
                if (line.type === 'candidate' && line.value) {
                    used.add(line.value);
                }
            }
            return used;
        }

        function getAvailableCandidates(structuredLines: StructuredLine[], currentIndex: number): string[] {
            const used = getUsedCandidates(structuredLines);
            const currentValue = structuredLines[currentIndex]?.value;
            return parsedData.candidates.filter(c => c === currentValue || !used.has(c));
        }

        function getStructuredLineLabel(line: StructuredLine): string {
            switch (line.type) {
                case 'candidate': return line.value || '(unknown candidate)';
                case 'duplicate': return `Duplicate: ${line.value || '(unknown)'}`;
                case 'empty': return '(empty line)';
                case 'voter': return '(voter header)';
                case 'timecode': return '(timecode)';
                case 'not-candidate': return '(not a candidate)';
                case 'not-ballot': return '(not a ballot entry)';
                default: return '(unknown)';
            }
        }

        function getStructuredLineClass(line: StructuredLine): string {
            return `rank-row-${line.type}`;
        }

        function renderBallotReview() {
            const container = document.getElementById('ballot-review-content');
            const progressEl = document.getElementById('ballot-review-progress');
            if (!container || !progressEl) return;

            // Filter out duplicate ballots if any
            const activeBallots = parsedData.ballots.filter((b, idx) => {
                const baseVoter = b.voter.replace(/#\d+$/, '');
                const selectedIdx = parsedData.duplicateSelections.get(baseVoter);
                if (selectedIdx !== undefined) return idx === selectedIdx;
                return true;
            });

            if (currentBallotIndex >= activeBallots.length) {
                currentBallotIndex = activeBallots.length - 1;
            }
            if (currentBallotIndex < 0) currentBallotIndex = 0;

            const ballot = activeBallots[currentBallotIndex];
            const voter = ballot.voter;

            progressEl.textContent = `Ballot ${currentBallotIndex + 1} of ${activeBallots.length}`;

            const originalText = parsedData.originalBallotText.get(voter) || ballot.rankings.join('\n');
            const originalLines = originalText.split('\n');
            const structuredLines = getOrInitStructuredLines(voter);
            const isModified = parsedData.ballotManuallyModified.has(voter);

            // Build 1:1 row mapping
            let rowsHtml = '';
            let candidateRank = 0;

            for (let i = 0; i < originalLines.length; i++) {
                const originalLine = originalLines[i] || '';
                const structuredLine = structuredLines[i] || { type: 'empty' };
                const left = escapeHtml(originalLine);
                
                // Determine rank number for candidates
                let rankBadge = '';
                if (structuredLine.type === 'candidate' && structuredLine.value) {
                    candidateRank++;
                    rankBadge = `<span class="rank-number">${candidateRank}.</span>`;
                } else if (structuredLine.type === 'duplicate') {
                    rankBadge = `<span class="rank-number-duplicate">Dup</span>`;
                } else {
                    rankBadge = `<span class="rank-number">&nbsp;</span>`;
                }

                // Build dropdown options
                const availableCandidates = getAvailableCandidates(structuredLines, i);
                // Determine if there's already a voter header elsewhere (exclude current index)
                const hasVoterLine = structuredLines.some((l, idx) => l.type === 'voter' && idx !== i);
                const dropdownOptions = [
                    ...availableCandidates.map(c => `<option value="candidate:${c}" ${structuredLine.type === 'candidate' && structuredLine.value === c ? 'selected' : ''}>${c}</option>`),
                    `<option value="empty" ${structuredLine.type === 'empty' ? 'selected' : ''}>[Empty Line]</option>`,
                    `<option value="voter" ${structuredLine.type === 'voter' ? 'selected' : ''} ${hasVoterLine ? 'disabled' : ''}>[Voter Header]</option>`,
                    `<option value="timecode" ${structuredLine.type === 'timecode' ? 'selected' : ''}>[Timecode]</option>`,
                    `<option value="not-candidate" ${structuredLine.type === 'not-candidate' ? 'selected' : ''}>[Not a Candidate]</option>`,
                    `<option value="not-ballot" ${structuredLine.type === 'not-ballot' ? 'selected' : ''}>[Not a Ballot Entry]</option>`,
                    `<option value="duplicate" ${structuredLine.type === 'duplicate' ? 'selected' : ''}>[Duplicate Candidate]</option>`
                ].join('');

                const rightHtml = `
                    <div class="rank-row ${getStructuredLineClass(structuredLine)}">
                        ${rankBadge}
                        <select class="rank-dropdown" onchange="window.updateStructuredLine('${voter.replace(/'/g, "\\'").replace(/"/g, '&quot;')}', ${i}, this.value)">
                            ${dropdownOptions}
                        </select>
                        <button class="rank-move-btn" onclick="window.moveStructuredLine('${voter.replace(/'/g, "\\'").replace(/"/g, '&quot;')}', ${i}, -1)" ${i === 0 ? 'disabled' : ''}>↑</button>
                        <button class="rank-move-btn" onclick="window.moveStructuredLine('${voter.replace(/'/g, "\\'").replace(/"/g, '&quot;')}', ${i}, 1)" ${i === originalLines.length - 1 ? 'disabled' : ''}>↓</button>
                    </div>
                `;

                rowsHtml += `
                    <div class="ballot-row">
                        <div class="ballot-row-original">${left}</div>
                        <div class="ballot-row-structured">${rightHtml}</div>
                    </div>
                `;
            }

            container.innerHTML = `
                <div class="ballot-review-card ${isModified ? 'ballot-modified' : ''}">
                    <div class="ballot-review-header">
                        <span>Voter: ${voter}</span>
                        ${isModified ? '<span class="modified-badge">Modified</span>' : ''}
                    </div>
                    <div class="ballot-review-body">
                        <div class="ballot-row ballot-row-header">
                            <div class="ballot-row-original"><div class="ballot-column-header">Original Discord Text</div></div>
                            <div class="ballot-row-structured"><div class="ballot-column-header">Structured Rankings</div></div>
                        </div>
                        ${rowsHtml}
                        <div style="width:100%; padding: 15px;">
                            <button class="reset-ballot-btn" onclick="window.resetBallot('${voter.replace(/'/g, "\\'").replace(/"/g, '&quot;')}')">Reset to Auto-Detected</button>
                        </div>
                    </div>
                    <div class="ballot-nav-buttons icenia-button-group govuk-!-padding-4">
                        <button class="icenia-btn icenia-btn-secondary" onclick="window.prevBallot()" ${currentBallotIndex === 0 ? 'disabled' : ''}>Previous Ballot</button>
                        <button class="icenia-btn" onclick="window.calculateResults()">Calculate Results</button>
                        <button class="icenia-btn icenia-btn-secondary" onclick="window.nextBallot()" ${currentBallotIndex === activeBallots.length - 1 ? 'disabled' : ''}>Next Ballot</button>
                    </div>
                </div>
            `;
        }

        function proceedToBallotReview() {
            document.getElementById('duplicate-voters')!.style.display = 'none';
            document.getElementById('ballot-review')!.style.display = 'block';
            renderBallotReview();
        }

        function calculateResults() {
            const logEl = document.getElementById('log');
            const winnersEl = document.getElementById('winners');
            if (!logEl || !winnersEl) return;
            
            logEl.innerHTML = '';
            winnersEl.innerHTML = 'Calculating...';
            
            try {
                const candidateReferences = parsedData.candidates;
                
                // Filter out duplicate ballots
                const activeBallots = parsedData.ballots.filter((b, idx) => {
                    const baseVoter = b.voter.replace(/#\d+$/, '');
                    const selectedIdx = parsedData.duplicateSelections.get(baseVoter);
                    if (selectedIdx !== undefined) return idx === selectedIdx;
                    return true;
                });

                const stvBallots = activeBallots.map(b => {
                    // Extract candidates from structured lines (in order, excluding duplicates)
                    const structuredLines = getOrInitStructuredLines(b.voter);
                    const candidateNames = structuredLines
                        .filter(line => line.type === 'candidate' && line.value)
                        .map(line => line.value!);
                    
                    const rankingNumbers = candidateNames
                        .map(name => getCandidateNumber(name, candidateReferences))
                        .filter((n): n is number => n !== null && n > 0);
                    
                    return new Ballot(b.voter, rankingNumbers, 1, candidateReferences.length);
                }).filter(b => b.rankingList.length > 0);

                if (stvBallots.length === 0) {
                    winnersEl.innerHTML = `<p class="govuk-error-message">No valid ballots to calculate.</p>`;
                    return;
                }

                const logs: string[] = [];
                const { winners, roundResults } = STV(stvBallots, parsedData.seats, candidateReferences, (msg) => logs.push(msg));
                parsedData.roundResults = roundResults;
                
                winnersEl.innerHTML = `<strong>The winners are:</strong> ${winners.join(', ')}`;
                logEl.innerHTML = logs.join('');
                
                document.getElementById('ballot-review')!.style.display = 'none';
                document.getElementById('duplicate-voters')!.style.display = 'none';
                document.getElementById('results')!.style.display = 'block';
            } catch (e) {
                winnersEl.innerHTML = `<p class="govuk-error-message">Error calculating results: ${(e as Error).message}</p>`;
            }
        }

        // Expose functions to window for HTML event handlers
        (window as any).selectMatch = (foundName: string, matchedName: string) => {
            // Normalize selection values:
            // - '__INVALID__' -> null (not a candidate)
            // - '__NOT_A_BALLOT__' -> '__NOT_A_BALLOT__' (remove from ballots)
            // - '' -> null
            const value = matchedName === '' || matchedName === '__INVALID__' ? null : matchedName === '__NOT_A_BALLOT__' ? '__NOT_A_BALLOT__' : matchedName;
            parsedData.nameMatches.set(foundName, value as string | null);

            // Store learned correlations using a base pattern key
            const baseName = foundName.toLowerCase().replace(/^[\d\.\s]+/, '').replace(/[\d\s]+$/, '');
            if (matchedName === '__INVALID__') {
                parsedData.learnedCorrelations.set(baseName, null);
            } else if (matchedName === '__NOT_A_BALLOT__') {
                parsedData.learnedCorrelations.set(baseName, '__NOT_A_BALLOT__');
            } else if (matchedName && matchedName !== '') {
                parsedData.learnedCorrelations.set(baseName, matchedName);
            }

            renderCurrentName();
            updateCorrelationTable();
        };

        (window as any).nextName = () => {
            parsedData.currentNameIndex++;
            renderCurrentName();
        };

        (window as any).prevName = () => {
            if (parsedData.currentNameIndex > 0) {
                parsedData.currentNameIndex--;
                renderCurrentName();
            }
        };

        (window as any).resolveDuplicate = (voter: string, idx: number) => {
            parsedData.duplicateSelections.set(voter, idx);
            checkForDuplicates();
        };

        (window as any).updateStructuredLine = (voter: string, lineIndex: number, value: string) => {
            const structuredLines = getOrInitStructuredLines(voter);
            if (lineIndex < 0 || lineIndex >= structuredLines.length) return;
            
            parsedData.ballotManuallyModified.add(voter);
            
            if (value.startsWith('candidate:')) {
                const candidateName = value.substring('candidate:'.length);
                structuredLines[lineIndex] = { type: 'candidate', value: candidateName };
            } else if (value === 'empty') {
                structuredLines[lineIndex] = { type: 'empty' };
            } else if (value === 'voter') {
                structuredLines[lineIndex] = { type: 'voter' };
            } else if (value === 'timecode') {
                structuredLines[lineIndex] = { type: 'timecode' };
            } else if (value === 'not-candidate') {
                structuredLines[lineIndex] = { type: 'not-candidate' };
            } else if (value === 'not-ballot') {
                structuredLines[lineIndex] = { type: 'not-ballot' };
            } else if (value === 'duplicate') {
                structuredLines[lineIndex] = { type: 'duplicate' };
            }
            
            parsedData.ballotStructuredLines.set(voter, structuredLines);
            renderBallotReview();
        };

        (window as any).moveStructuredLine = (voter: string, lineIndex: number, direction: number) => {
            const structuredLines = getOrInitStructuredLines(voter);
            const originalText = parsedData.originalBallotText.get(voter) || '';
            const originalLines = originalText.split('\n');
            
            const targetIndex = lineIndex + direction;
            if (targetIndex < 0 || targetIndex >= structuredLines.length) return;
            
            parsedData.ballotManuallyModified.add(voter);
            
            // Swap structured interpretations (not original lines!)
            const temp = structuredLines[lineIndex];
            structuredLines[lineIndex] = structuredLines[targetIndex];
            structuredLines[targetIndex] = temp;
            
            parsedData.ballotStructuredLines.set(voter, structuredLines);
            renderBallotReview();
        };

        (window as any).resetBallot = (voter: string) => {
            parsedData.ballotStructuredLines.delete(voter);
            parsedData.ballotManuallyModified.delete(voter);
            renderBallotReview();
        };

        (window as any).nextBallot = () => {
            currentBallotIndex++;
            renderBallotReview();
        };

        (window as any).prevBallot = () => {
            currentBallotIndex--;
            renderBallotReview();
        };

        (window as any).calculateResults = calculateResults;

        // Track duplicate voters for keyboard navigation
        let allDuplicateVoters: Array<{voter: string, ballotIndices: number[]}> = [];
        let currentDuplicateIndex = 0;

        function navigateDuplicateBallotOption(direction: 'up' | 'down') {
            if (allDuplicateVoters.length === 0) return;
            const currentVoter = allDuplicateVoters[currentDuplicateIndex];
            if (!currentVoter) return;
            
            const selectedIdx = parsedData.duplicateSelections.get(currentVoter.voter);
            const currentPos = selectedIdx !== undefined 
                ? currentVoter.ballotIndices.indexOf(selectedIdx) 
                : currentVoter.ballotIndices.length - 1;
            
            let newPos = currentPos;
            if (direction === 'up' && currentPos > 0) newPos--;
            if (direction === 'down' && currentPos < currentVoter.ballotIndices.length - 1) newPos++;
            
            if (newPos !== currentPos) {
                parsedData.duplicateSelections.set(currentVoter.voter, currentVoter.ballotIndices[newPos]);
                checkForDuplicates();
            }
        }

        // --- Global Keyboard Navigation ---
        document.addEventListener('keydown', function(e) {
            // Don't interfere if user is typing in dropdown or another input
            if (e.target instanceof HTMLSelectElement || e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement) {
                return;
            }
            
            // Don't interfere if user is focused on a button (they might press Enter/Space on it)
            if (e.target instanceof HTMLButtonElement) {
                return;
            }
            
            // Handle duplicate voters keyboard navigation
            const duplicateVoters = document.getElementById('duplicate-voters');
            if (duplicateVoters && duplicateVoters.style.display === 'block') {
                if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    navigateDuplicateBallotOption('up');
                } else if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    navigateDuplicateBallotOption('down');
                } else if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    if (currentDuplicateIndex < allDuplicateVoters.length - 1) {
                        currentDuplicateIndex++;
                        checkForDuplicates();
                    } else {
                        proceedToBallotReview();
                    }
                } else if (e.key === 'Enter' && e.shiftKey) {
                    e.preventDefault();
                    if (currentDuplicateIndex > 0) {
                        currentDuplicateIndex--;
                        checkForDuplicates();
                    }
                } else if (e.key === 'ArrowLeft') {
                    e.preventDefault();
                    if (currentDuplicateIndex > 0) {
                        currentDuplicateIndex--;
                        checkForDuplicates();
                    }
                } else if (e.key === 'ArrowRight') {
                    e.preventDefault();
                    if (currentDuplicateIndex < allDuplicateVoters.length - 1) {
                        currentDuplicateIndex++;
                        checkForDuplicates();
                    } else {
                        proceedToBallotReview();
                    }
                }
                return;
            }
            
            // Handle ballot review keyboard navigation
            const ballotReview = document.getElementById('ballot-review');
            if (ballotReview && ballotReview.style.display === 'block') {
                if (e.key === 'ArrowLeft' || (e.key === 'Enter' && e.shiftKey)) {
                    e.preventDefault();
                    if (currentBallotIndex > 0) {
                        currentBallotIndex--;
                        renderBallotReview();
                    }
                } else if (e.key === 'ArrowRight' || e.key === 'Enter') {
                    e.preventDefault();
                    if (currentBallotIndex < parsedData.ballots.length - 1) {
                        currentBallotIndex++;
                        renderBallotReview();
                    }
                }
                return;
            }
            
            // Handle name matching keyboard navigation
            const nameMatching = document.getElementById('name-matching');
            if (!nameMatching || nameMatching.style.display !== 'block') return;
            
            // Only navigate if we're not in the confirmation screen
            if (parsedData.currentNameIndex >= parsedData.uniqueNames.length) return;
            
            // 'W' key to focus dropdown
            if (e.key === 'w' || e.key === 'W') {
                const dropdown = document.querySelector('.manual-select-wrapper select') as HTMLSelectElement;
                if (dropdown) {
                    e.preventDefault();
                    dropdown.focus();
                }
                return;
            }
            
            // Arrow keys for navigation
            if (e.key === 'ArrowLeft' && parsedData.currentNameIndex > 0) {
                e.preventDefault();
                const currentName = parsedData.uniqueNames[parsedData.currentNameIndex];
                parsedData.reviewedNames.add(currentName);
                parsedData.currentNameIndex--;
                renderCurrentName();
            } else if (e.key === 'ArrowRight' && parsedData.currentNameIndex < parsedData.uniqueNames.length) {
                e.preventDefault();
                const currentName = parsedData.uniqueNames[parsedData.currentNameIndex];
                parsedData.reviewedNames.add(currentName);
                parsedData.currentNameIndex++;
                renderCurrentName();
            }
            
            // Enter and Shift+Enter for navigation
            if (e.key === 'Enter' && !e.shiftKey && parsedData.currentNameIndex < parsedData.uniqueNames.length) {
                e.preventDefault();
                const currentName = parsedData.uniqueNames[parsedData.currentNameIndex];
                parsedData.reviewedNames.add(currentName);
                parsedData.currentNameIndex++;
                renderCurrentName();
            } else if (e.key === 'Enter' && e.shiftKey && parsedData.currentNameIndex > 0) {
                e.preventDefault();
                const currentName = parsedData.uniqueNames[parsedData.currentNameIndex];
                parsedData.reviewedNames.add(currentName);
                parsedData.currentNameIndex--;
                renderCurrentName();
            }
            
            // Number keys 1-9 to quickly select match buttons
            const numMatch = e.key.match(/^[1-9]$/);
            if (numMatch) {
                const index = parseInt(e.key) - 1;
                // Exclude invalid and not-ballot options from quick-number selects
                const matchButtons = document.querySelectorAll<HTMLButtonElement>('.match-option:not([data-type="invalid"]):not([data-type="not-ballot"])');
                if (matchButtons[index]) {
                    e.preventDefault();
                    matchButtons[index].click();
                }
            }
            
            // 'N' key for "Not a Candidate" button
            if (e.key === 'n' || e.key === 'N') {
                const matchOptions = document.querySelectorAll<HTMLButtonElement>('.match-option');
                const invalidBtn = Array.from(matchOptions).find(btn => (btn.textContent || '').toLowerCase().includes('not a candidate'));
                if (invalidBtn) {
                    e.preventDefault();
                    invalidBtn.click();
                }
            }

            // 'M' key for "Not a Ballot Entry" button
            if (e.key === 'm' || e.key === 'M') {
                const matchOptions = document.querySelectorAll<HTMLButtonElement>('.match-option');
                const notBallotBtn = Array.from(matchOptions).find(btn => (btn.textContent || '').toLowerCase().includes('not a ballot'));
                if (notBallotBtn) {
                    e.preventDefault();
                    notBallotBtn.click();
                }
            }
        });

        // --- Keyboard detection for focus-visible ---
        window.addEventListener('keydown', function(e) {
            if (e.key === 'Tab' || e.key === 'w' || e.key === 'W') {
                document.body.classList.add('is-keyboard-user');
            }
        });

        window.addEventListener('mousedown', function() {
            document.body.classList.remove('is-keyboard-user');
        });

        // --- Export/Import Logic ---

        function exportElection() {
            const electionName = getElectionName();
            let currentSection = 'import';
            if (document.getElementById('name-matching')?.style.display !== 'none') currentSection = 'name-matching';
            else if (document.getElementById('ballot-review')?.style.display !== 'none') currentSection = 'ballot-review';
            else if (document.getElementById('results')?.style.display !== 'none') currentSection = 'results';
            
            const exportData = {
                version: '3.0',
                timestamp: new Date().toISOString(),
                inputMode: inputMode,
                electionName,
                candidates: parsedData.candidates,
                ballots: parsedData.ballots ? parsedData.ballots.map((b: any) => ({
                    voter: b.voter,
                    rankings: b.rankings
                })) : [],
                rawDiscordInput: {
                    candidates: (document.getElementById('discord-candidates') as HTMLTextAreaElement)?.value || '',
                    ballots: (document.getElementById('discord-ballots') as HTMLTextAreaElement)?.value || '',
                    seats: parsedData.seats
                },
                nameMatches: Object.fromEntries(parsedData.nameMatches),
                learnedCorrelations: Object.fromEntries(parsedData.learnedCorrelations),
                ballotStructuredLines: Object.fromEntries(parsedData.ballotStructuredLines),
                ballotManuallyModified: Array.from(parsedData.ballotManuallyModified),
                originalBallotText: Object.fromEntries(parsedData.originalBallotText),
                reviewedNames: Array.from(parsedData.reviewedNames),
                uniqueNames: parsedData.uniqueNames,
                nameCounts: Object.fromEntries(parsedData.nameCounts),
                currentState: {
                    section: currentSection,
                    currentNameIndex: parsedData.currentNameIndex,
                    currentBallotIndex: currentBallotIndex
                }
            };
            
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = buildExportFilename('stv-election');
            a.click();
            URL.revokeObjectURL(url);
        }

        function exportForRCVis() {
            const roundResults = (parsedData as any).roundResults;
            if (!roundResults || roundResults.length === 0) {
                alert('No results to export. Please calculate results first.');
                return;
            }
            
            const today = new Date();
            const dateStr = today.toISOString().split('T')[0];
            const electionName = getElectionName();
            const contestName = electionName || 'Icenian Election';
            
            const rcvisData = {
                config: {
                    contest: contestName,
                    date: dateStr,
                    jurisdiction: "Icenia",
                    office: contestName,
                    threshold: (parsedData.ballots.length / (parsedData.seats + 1)).toFixed(3)
                },
                results: roundResults.map((round: any) => ({
                    round: round.round,
                    tally: Object.fromEntries(
                        Object.entries(round.tally).map(([candidate, votes]) => [
                            candidate,
                            (votes as number).toFixed(3)
                        ])
                    ),
                    quota: round.quota ? parseFloat(round.quota.toFixed(3)) : undefined,
                    exhausted: round.exhausted ? parseFloat(round.exhausted.toFixed(3)) : 0,
                    isFinalRound: round.isFinalRound || false,
                    tallyResults: round.tallyResults
                }))
            };
            
            const blob = new Blob([JSON.stringify(rcvisData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = buildExportFilename('rcvis-election');
            a.click();
            URL.revokeObjectURL(url);
        }

        function importElection(file: File) {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const importData = JSON.parse(e.target?.result as string);
                    if (importData.inputMode) {
                        inputMode = importData.inputMode;
                        localStorage.setItem('input-mode', inputMode);
                        const modeRadio = document.querySelector(`input[name="input-mode"][value="${importData.inputMode}"]`) as HTMLInputElement;
                        if (modeRadio) modeRadio.checked = true;
                        if (inputMode === 'discord') {
                            (document.getElementById('simple-mode') as HTMLElement).style.display = 'none';
                            (document.getElementById('discord-mode') as HTMLElement).style.display = 'block';
                        } else {
                            (document.getElementById('simple-mode') as HTMLElement).style.display = 'block';
                            (document.getElementById('discord-mode') as HTMLElement).style.display = 'none';
                        }
                    }
                    if (importData.rawDiscordInput) {
                        const candidatesInput = document.getElementById('discord-candidates') as HTMLTextAreaElement;
                        const ballotsInput = document.getElementById('discord-ballots') as HTMLTextAreaElement;
                        if (candidatesInput) candidatesInput.value = importData.rawDiscordInput.candidates || '';
                        if (ballotsInput) ballotsInput.value = importData.rawDiscordInput.ballots || '';
                    }
                    if (importData.learnedCorrelations) parsedData.learnedCorrelations = new Map(Object.entries(importData.learnedCorrelations));
                    if (importData.electionName) {
                        parsedData.electionName = importData.electionName;
                        const electionNameInput = document.getElementById('election-name') as HTMLInputElement;
                        if (electionNameInput) electionNameInput.value = parsedData.electionName;
                    }
                    if (importData.candidates) parsedData.candidates = importData.candidates;
                    if (importData.ballots) parsedData.ballots = importData.ballots;
                    if (importData.rawDiscordInput?.seats) parsedData.seats = importData.rawDiscordInput.seats;
                    if (importData.nameMatches) {
                        parsedData.nameMatches = new Map(Object.entries(importData.nameMatches).map(([k, v]) => [k, v === 'null' ? null : v as string | null]));
                    }
                    if (importData.ballotStructuredLines) {
                        parsedData.ballotStructuredLines = new Map(Object.entries(importData.ballotStructuredLines).map(([k, v]) => [k, v as StructuredLine[]]));
                    }
                    if (importData.ballotManuallyModified) {
                        parsedData.ballotManuallyModified = new Set(importData.ballotManuallyModified);
                    }
                    if (importData.originalBallotText) parsedData.originalBallotText = new Map(Object.entries(importData.originalBallotText).map(([k, v]) => [k, v as string]));
                    if (importData.reviewedNames) parsedData.reviewedNames = new Set(importData.reviewedNames);
                    if (importData.uniqueNames) parsedData.uniqueNames = importData.uniqueNames;
                    if (importData.nameCounts) parsedData.nameCounts = new Map(Object.entries(importData.nameCounts).map(([k, v]) => [k, v as number]));
                    
                    if (importData.currentState) {
                        parsedData.currentNameIndex = importData.currentState.currentNameIndex || 0;
                        currentBallotIndex = importData.currentState.currentBallotIndex || 0;
                        const section = importData.currentState.section;
                        document.getElementById('import-section')!.style.display = 'none';
                        document.getElementById('simple-mode')!.style.display = 'none';
                        document.getElementById('discord-mode')!.style.display = 'none';
                        if (section === 'name-matching') {
                            document.getElementById('name-matching')!.style.display = 'block';
                            renderCurrentName();
                        } else if (section === 'ballot-review') {
                            document.getElementById('ballot-review')!.style.display = 'block';
                            renderBallotReview();
                        } else if (section === 'results') {
                            document.getElementById('results')!.style.display = 'block';
                            calculateResults();
                        }
                    }
                    updateCorrelationTable();
                    alert('Election imported successfully!');
                } catch (err) {
                    alert('Failed to import election: ' + (err as Error).message);
                }
            };
            reader.readAsText(file);
        }

        function clearSession() {
            if (!confirm('Are you sure you want to clear all data?')) return;
            parsedData = {
                candidates: [], ballots: [], seats: 0, electionName: '', nameMatches: new Map(),
                uniqueNames: [], currentNameIndex: 0, learnedCorrelations: new Map(),
                correlationInfluences: new Map(), hasCorrelationWarning: false, nameCounts: new Map(),
                ballotOverrides: new Map(), originalBallotText: new Map(), reviewedNames: new Set(),
                duplicateSelections: new Map(), ballotStructuredLines: new Map(), ballotManuallyModified: new Set()
            };
            localStorage.removeItem('election-name');
            const electionNameInput = document.getElementById('election-name') as HTMLInputElement;
            if (electionNameInput) electionNameInput.value = '';
            document.getElementById('name-matching')!.style.display = 'none';
            document.getElementById('duplicate-voters')!.style.display = 'none';
            document.getElementById('ballot-review')!.style.display = 'none';
            document.getElementById('results')!.style.display = 'none';
            document.getElementById('import-section')!.style.display = 'block';
            inputMode = 'simple';
            localStorage.setItem('input-mode', 'simple');
            (document.getElementById('mode-simple') as HTMLInputElement).checked = true;
            (document.getElementById('simple-mode') as HTMLElement).style.display = 'block';
            (document.getElementById('discord-mode') as HTMLElement).style.display = 'none';
            updateCorrelationTable();
        }

        // --- Event Listeners ---

        window.addEventListener('DOMContentLoaded', function() {
            // Mode switching
            document.querySelectorAll('input[name="input-mode"]').forEach(radio => {
                radio.addEventListener('change', function(this: HTMLInputElement) {
                    inputMode = this.value as 'simple' | 'discord';
                    localStorage.setItem('input-mode', this.value);
                    document.getElementById('simple-mode')!.style.display = inputMode === 'simple' ? 'block' : 'none';
                    document.getElementById('discord-mode')!.style.display = inputMode === 'discord' ? 'block' : 'none';
                });
            });

            // Restore saved data
            const savedMode = localStorage.getItem('input-mode');
            if (savedMode) {
                const radio = document.querySelector(`input[name="input-mode"][value="${savedMode}"]`) as HTMLInputElement;
                if (radio) { radio.checked = true; radio.dispatchEvent(new Event('change')); }
            }
            const savedCandidates = localStorage.getItem('discord-candidates');
            if (savedCandidates) (document.getElementById('discord-candidates') as HTMLTextAreaElement).value = savedCandidates;
            const savedBallots = localStorage.getItem('discord-ballots');
            if (savedBallots) (document.getElementById('discord-ballots') as HTMLTextAreaElement).value = savedBallots;
            const savedElectionName = localStorage.getItem('election-name');
            if (savedElectionName) {
                (document.getElementById('election-name') as HTMLInputElement).value = savedElectionName;
                parsedData.electionName = savedElectionName;
            }

            // Input listeners
            document.getElementById('discord-candidates')?.addEventListener('input', function(this: HTMLTextAreaElement) { localStorage.setItem('discord-candidates', this.value); });
            document.getElementById('discord-ballots')?.addEventListener('input', function(this: HTMLTextAreaElement) { localStorage.setItem('discord-ballots', this.value); });
            document.getElementById('election-name')?.addEventListener('input', function(this: HTMLInputElement) {
                parsedData.electionName = this.value.trim();
                localStorage.setItem('election-name', parsedData.electionName);
            });

            // Buttons
            document.getElementById('import-election-button')?.addEventListener('click', () => (document.getElementById('import-file-input') as HTMLInputElement).click());
            document.getElementById('import-file-input')?.addEventListener('change', (e) => {
                const file = (e.target as HTMLInputElement).files?.[0];
                if (file) { importElection(file); (e.target as HTMLInputElement).value = ''; }
            });
            document.getElementById('export-election')?.addEventListener('click', exportElection);
            document.getElementById('export-election-review')?.addEventListener('click', exportElection);
            document.getElementById('export-results')?.addEventListener('click', exportElection);
            document.getElementById('export-rcvis')?.addEventListener('click', exportForRCVis);
            document.getElementById('clear-session')?.addEventListener('click', clearSession);
            document.getElementById('clear-session-start')?.addEventListener('click', clearSession);
            document.getElementById('clear-session-review')?.addEventListener('click', clearSession);
            document.getElementById('back-to-discord')?.addEventListener('click', () => {
                document.getElementById('name-matching')!.style.display = 'none';
                document.getElementById('discord-mode')!.style.display = 'block';
            });
            document.getElementById('back-to-name-matching-from-duplicates')?.addEventListener('click', () => {
                document.getElementById('duplicate-voters')!.style.display = 'none';
                document.getElementById('name-matching')!.style.display = 'block';
                parsedData.currentNameIndex = 0; renderCurrentName();
            });
            document.getElementById('proceed-to-ballot-review')?.addEventListener('click', proceedToBallotReview);
            document.getElementById('back-to-name-matching')?.addEventListener('click', () => {
                document.getElementById('ballot-review')!.style.display = 'none';
                // Check if we have any duplicates to show
                const hasDuplicates = Array.from(parsedData.duplicateSelections.keys()).length > 0;
                if (hasDuplicates) {
                    document.getElementById('duplicate-voters')!.style.display = 'block';
                    // Re-render duplicates
                    const voterBallots = new Map<string, number[]>();
                    parsedData.ballots.forEach((b, index) => {
                        const baseVoter = b.voter.replace(/#\d+$/, '');
                        if (!voterBallots.has(baseVoter)) voterBallots.set(baseVoter, []);
                        voterBallots.get(baseVoter)!.push(index);
                    });
                    const duplicates = Array.from(voterBallots.entries()).filter(([voter, indices]) => indices.length > 1);
                    renderDuplicateVoters(duplicates);
                } else {
                    document.getElementById('name-matching')!.style.display = 'block';
                    parsedData.currentNameIndex = 0; renderCurrentName();
                }
            });
            document.getElementById('recalculate-results')?.addEventListener('click', () => {
                const seatsInput = document.getElementById('results-seats') as HTMLInputElement;
                if (seatsInput) parsedData.seats = parseInt(seatsInput.value);
                calculateResults();
            });
            document.getElementById('return-to-start')?.addEventListener('click', () => {
                document.getElementById('results')!.style.display = 'none';
                document.getElementById('import-section')!.style.display = 'block';
                if (inputMode === 'simple') document.getElementById('simple-mode')!.style.display = 'block';
                else document.getElementById('discord-mode')!.style.display = 'block';
            });

            // Parse Discord
            document.getElementById('parse-discord')?.addEventListener('click', function() {
                const candidatesText = (document.getElementById('discord-candidates') as HTMLTextAreaElement).value;
                const ballotsText = (document.getElementById('discord-ballots') as HTMLTextAreaElement).value;
                const seats = parseInt((document.getElementById('discord-seats') as HTMLInputElement).value);
                if (!candidatesText.trim() || !ballotsText.trim()) { alert('Please enter candidates and ballots'); return; }
                const officialCandidates = parseOfficialCandidatesLocal(candidatesText);
                if (officialCandidates.length === 0) { alert('No valid candidates found'); return; }
                const { ballots, originalBallotText } = parseDiscordBallots(ballotsText);
                if (ballots.length === 0) { alert('No valid ballots found'); return; }
                parsedData.candidates = officialCandidates;
                parsedData.ballots = ballots;
                parsedData.seats = seats;
                parsedData.originalBallotText = originalBallotText;
                const counts = new Map<string, number>();
                const foundNamesSet = new Set<string>();
                ballots.forEach(b => b.rankings.forEach(name => {
                    counts.set(name, (counts.get(name) || 0) + 1);
                    foundNamesSet.add(name);
                }));
                parsedData.nameCounts = counts;
                parsedData.uniqueNames = Array.from(foundNamesSet).sort();
                document.getElementById('discord-mode')!.style.display = 'none';
                document.getElementById('name-matching')!.style.display = 'block';
                renderCurrentName();
                updateCorrelationTable();
            });

            // Simple Mode Calculate
            document.getElementById('calculate')?.addEventListener('click', function() {
                const candidatesText = (document.getElementById('candidates') as HTMLTextAreaElement).value;
                const ballotsText = (document.getElementById('ballots') as HTMLTextAreaElement).value;
                const seats = parseInt((document.getElementById('seats') as HTMLInputElement).value);
                if (!candidatesText.trim() || !ballotsText.trim()) { alert('Please enter candidates and ballots'); return; }
                const candidates = candidatesText.split('\n').map(c => c.trim()).filter(c => c.length > 0);
                const ballotLines = ballotsText.split('\n').map(l => l.trim()).filter(l => l.length > 0);
                const ballots: Array<{voter: string, rankings: string[]}> = [];
                const nameMatches = new Map<string, string>();
                for (let line of ballotLines) {
                    const parts = line.split(':');
                    if (parts.length < 2) continue;
                    const voter = parts[0].trim();
                    const rankings = parts[1].split(',').map(r => r.trim()).filter(r => r.length > 0);
                    ballots.push({ voter, rankings });
                    rankings.forEach(r => nameMatches.set(r, r));
                }
                parsedData.candidates = candidates;
                parsedData.ballots = ballots;
                parsedData.seats = seats;
                parsedData.nameMatches = nameMatches;
                calculateResults();
            });

            // Load Example Data
            document.getElementById('loadExample')?.addEventListener('click', function() {
                (document.getElementById('candidates') as HTMLTextAreaElement).value = "Ratat0ing\nDr_Bacon_hair\nhsmnewfriend\nCreepilyCreep\nIsraelGPT";
                (document.getElementById('ballots') as HTMLTextAreaElement).value = "recycler: Ratat0ing, Dr_Bacon_hair, hsmnewfriend\nalzubloxxer11: Dr_Bacon_hair, hsmnewfriend, Ratat0ing\nuser3: hsmnewfriend, Ratat0ing\nuser4: CreepilyCreep, IsraelGPT\nuser5: IsraelGPT, CreepilyCreep";
                (document.getElementById('seats') as HTMLInputElement).value = "2";
            });
        });
    </script>
</PageLayout>
