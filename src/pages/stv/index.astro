---
import PageLayout from "@layouts/page.astro";
---

<PageLayout chin={false} title="Icenian STV Calculator" description="This calculator implements Single Transferable Vote (STV) as used in Icenian elections.">

    <!-- Page Header -->
    <div class="page-header">
        <h1 class="govuk-heading-xl" style="margin-bottom: 10px;">Icenian STV Calculator</h1>
        <p class="govuk-body-l">This calculator implements Single Transferable Vote (STV) as used in Icenian elections.</p>
    </div>

    <div class="govuk-width-container">
        <main class="govuk-main-wrapper govuk-body" id="main-content">
            
            <!-- Mode Selection -->
            <div class="mode-selection govuk-form-group">
                <fieldset class="govuk-fieldset">
                    <legend class="govuk-fieldset__legend govuk-fieldset__legend--s">
                        Input Mode
                    </legend>
                    <div class="govuk-radios govuk-radios--inline">
                        <div class="govuk-radios__item">
                            <input class="govuk-radios__input" id="mode-simple" name="input-mode" type="radio" value="simple" checked>
                            <label class="govuk-label govuk-radios__label" for="mode-simple">
                                Simple Format
                            </label>
                        </div>
                        <div class="govuk-radios__item">
                            <input class="govuk-radios__input" id="mode-discord" name="input-mode" type="radio" value="discord">
                            <label class="govuk-label govuk-radios__label" for="mode-discord">
                                Discord Paste
                            </label>
                        </div>
                    </div>
                </fieldset>
                
                <!-- Import Election -->
                <div class="govuk-!-margin-top-6" id="import-section">
                    <h2 class="govuk-heading-s">Or Import Previous Election</h2>
                    <p class="govuk-body-s">Load a previously exported election file to resume your work.</p>
                    <input
                        type="file"
                        id="import-file-input"
                        accept=".json"
                        style="display: none;"
                    />
                    <div class="icenia-button-group">
                        <button class="icenia-btn icenia-btn-secondary" id="import-election-button" type="button">
                            Import Election File
                        </button>
                        <button class="icenia-btn icenia-btn-warning" id="clear-session-start" type="button">
                            Clear Session
                        </button>
                    </div>
                </div>
            </div>

            <!-- Simple Mode (original interface) -->
            <div id="simple-mode" class="stv-calculator">
                <div class="govuk-form-group">
                    <label class="govuk-label govuk-label--s" for="candidates">
                        Candidates (one per line)
                    </label>
                    <textarea 
                        class="icenia-textarea" 
                        id="candidates" 
                        rows="8"
                        placeholder="Enter candidate names, one per line"
                    ></textarea>
                </div>
                
                <div class="govuk-form-group">
                    <label class="govuk-label govuk-label--s" for="seats">
                        Number of Seats to Fill
                    </label>
                    <input 
                        class="icenia-input govuk-input--width-5" 
                        id="seats" 
                        type="number" 
                        value="5"
                        min="1"
                    />
                </div>
                
                <div class="govuk-form-group">
                    <label class="govuk-label govuk-label--s" for="ballots">
                        Ballots (one per line, format: "voter: cand1, cand2, cand3")
                    </label>
                    <textarea 
                        class="icenia-textarea" 
                        id="ballots" 
                        rows="15"
                        placeholder="recycler: Ratat0ing, Dr_Bacon_hair, hsmnewfriend&#10;alzubloxxer11: Dr_Bacon_hair, hsmnewfriend, Ratat0ing"
                    ></textarea>
                </div>
                
                <button class="icenia-btn" id="calculate" type="button">
                    Calculate Results
                </button>
                
                <button class="icenia-btn icenia-btn-secondary" id="loadExample" type="button">
                    Load Example Data
                </button>
            </div>

            <!-- Discord Mode -->
            <div id="discord-mode" class="stv-calculator" style="display: none;">
                <div class="govuk-form-group">
                    <label class="govuk-label govuk-label--s" for="discord-candidates">
                        Official Candidates (paste from Discord, one per line)
                    </label>
                    <div class="govuk-hint">
                        Include @mentions or plain names. Example: @Mayor Ratat0ing or DinoCompactor
                    </div>
                    <textarea 
                        class="icenia-textarea" 
                        id="discord-candidates" 
                        rows="10"
                        placeholder="@DinoCompactor&#10;@IsraelGPT&#10;@CreepilyCreep&#10;@Dr Bacon Hair(real)"
                    ></textarea>
                </div>

                <div class="govuk-form-group">
                    <label class="govuk-label govuk-label--s" for="discord-seats">
                        Number of Seats to Fill
                    </label>
                    <input 
                        class="icenia-input govuk-input--width-5" 
                        id="discord-seats" 
                        type="number" 
                        value="5"
                        min="1"
                    />
                </div>
                
                <div class="govuk-form-group">
                    <label class="govuk-label govuk-label--s" for="discord-ballots">
                        Raw Discord Ballot Data (paste entire voting channel)
                    </label>
                    <div class="govuk-hint">
                        Copy and paste the entire Discord channel content including usernames, timestamps, and votes
                    </div>
                    <textarea 
                        class="icenia-textarea" 
                        id="discord-ballots" 
                        rows="20"
                        placeholder="Ex-Councilor TheRecycler — 03/01/2026 06:12&#10;Ratat0ing&#10;Dr Bacon Hair&#10;HsmNewfriend"
                    ></textarea>
                </div>
                
                <button class="icenia-btn" id="parse-discord" type="button">
                    Parse Discord Data
                </button>
            </div>

            <!-- Name Matching Interface -->
            <div id="name-matching" style="display: none;">
                <div class="icenia-button-group govuk-!-margin-bottom-6">
                    <button class="icenia-btn icenia-btn-secondary" id="export-election" type="button">
                        Export Election
                    </button>
                    <button class="icenia-btn icenia-btn-warning" id="clear-session" type="button">
                        Clear Session
                    </button>
                </div>
                
                <h2 class="govuk-heading-m">Review Candidate Name Matches</h2>
                <p class="govuk-body">
                    The following names were found in ballots. Please confirm matches or mark as invalid.
                </p>
                
                <!-- Correlation Table -->
                <div id="correlation-table-section" style="display: none;" class="govuk-!-margin-bottom-6">
                    <details class="govuk-details">
                        <summary class="govuk-details__summary">
                            <span class="govuk-details__summary-text">
                                View Learned Name Correlations (<span id="correlation-count">0</span>)
                            </span>
                        </summary>
                        <div class="govuk-details__text">
                            <p class="govuk-body-s">These name patterns have been learned during this session:</p>
                            <table class="govuk-table">
                                <thead class="govuk-table__head">
                                    <tr class="govuk-table__row">
                                        <th scope="col" class="govuk-table__header">Voter Name Pattern</th>
                                        <th scope="col" class="govuk-table__header">Matched Candidate</th>
                                    </tr>
                                </thead>
                                <tbody class="govuk-table__body" id="correlation-table-body">
                                </tbody>
                            </table>
                        </div>
                    </details>
                </div>
                
                <div id="name-match-list"></div>
                <div class="icenia-button-group govuk-!-margin-top-6">
                    <button class="icenia-btn icenia-btn-secondary" id="back-to-discord" type="button">
                        ← Back to Edit
                    </button>
                    <!-- <button class="icenia-btn" id="confirm-matches" type="button">
                        Review Ballots →
                    </button> -->
                </div>
            </div>
            
            <!-- Duplicate Voter Resolution Interface -->
            <div id="duplicate-voters" style="display: none;">
                <h2 class="govuk-heading-m">Resolve Duplicate Voters</h2>
                <p class="govuk-body">
                    Some voters submitted multiple ballots. Please select which ballot to use for each voter.
                </p>
                
                <div id="duplicate-voters-content"></div>
                
                <div class="icenia-button-group govuk-!-margin-top-6">
                    <button class="icenia-btn icenia-btn-secondary" id="back-to-name-matching-from-duplicates" type="button">
                        ← Back to Name Matching
                    </button>
                    <button class="icenia-btn" id="proceed-to-ballot-review" type="button">
                        Proceed to Ballot Review →
                    </button>
                </div>
            </div>
            
            <!-- Ballot Review Interface -->
            <div id="ballot-review" style="display: none;">
                <div class="icenia-button-group govuk-!-margin-bottom-6">
                    <button class="icenia-btn icenia-btn-secondary" id="export-election-review" type="button">
                        Export Election
                    </button>
                    <button class="icenia-btn icenia-btn-warning" id="clear-session-review" type="button">
                        Clear Session
                    </button>
                </div>
                
                <h2 class="govuk-heading-m">Review Ballots</h2>
                <p class="govuk-body">
                    Review each voter's ballot with the name mappings applied. You can edit mappings using the dropdowns.
                </p>
                
                <div id="ballot-review-progress" class="match-progress"></div>
                <div id="ballot-review-content"></div>
                
                <div class="icenia-button-group govuk-!-margin-top-6">
                    <button class="icenia-btn icenia-btn-secondary" id="back-to-name-matching" type="button">
                        ← Back to Name Matching
                    </button>
                    <!-- <button class="icenia-btn" id="calculate-from-review" type="button">
                        Calculate Results →
                    </button> -->
                </div>
            </div>
                
                <div id="results" style="display: none;">
                    <h2 class="govuk-heading-m">Results</h2>

                    <div class="govuk-form-group" style="max-width: 480px; margin-bottom: 20px;">
                        <label class="govuk-label" for="election-name">
                            Election name (for exports)
                        </label>
                        <div class="govuk-hint">Used in exported file names and RCVis metadata.</div>
                        <input class="govuk-input" id="election-name" name="election-name" type="text" placeholder="e.g. 2026-01 Senate Election">
                    </div>
                    
                    <div class="govuk-form-group" style="max-width: 300px; margin-bottom: 20px;">
                        <label class="govuk-label" for="results-seats">
                            Number of winners
                        </label>
                        <input class="govuk-input" id="results-seats" name="results-seats" type="number" min="1" value="5" style="width: 100px;">
                        <button class="icenia-btn" id="recalculate-results" type="button" style="margin-left: 10px;">
                            Recalculate
                        </button>
                    </div>
                    
                    <div id="log" class="stv-log"></div>
                    <div id="winners" class="stv-winners"></div>
                    
                    <div class="icenia-button-group govuk-!-margin-top-6">
                        <button class="icenia-btn" id="export-results" type="button">
                            Export Election
                        </button>
                        <button class="icenia-btn" id="export-rcvis" type="button">
                            Export for RCVis
                        </button>
                        <button class="icenia-btn icenia-btn-secondary" id="return-to-start" type="button">
                            Return to Start (Remember to Export!)
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <style is:global>
        .stv-calculator {
            max-width: 800px;
        }
        
        .mode-selection {
            max-width: 800px;
            margin-bottom: 30px;
        }
        
        .stv-log {
            background: #f3f2f1;
            padding: 20px;
            border-radius: 4px;
            margin: 20px 0;
            font-family: monospace;
            white-space: pre-wrap;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .stv-winners {
            background: #00703c;
            color: white;
            padding: 20px;
            border-radius: 4px;
            font-weight: bold;
        }
        
        .stv-log-win {
            color: #00703c;
            font-weight: bold;
        }
        
        .stv-log-elim {
            color: #d4351c;
        }

        #name-matching {
            max-width: 900px;
        }

        .name-match-item {
            background: white;
            border: 2px solid #1d70b8;
            padding: 25px;
            margin-bottom: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .match-progress {
            text-align: center;
            margin-bottom: 20px;
            font-size: 1.1em;
            color: #505a5f;
            font-weight: bold;
        }

        .match-navigation {
            margin-top: 25px;
        }

        .icenia-button-group {
            display: flex !important;
            gap: 16px !important;
            flex-wrap: wrap;
            align-items: center;
        }

        .match-navigation.icenia-button-group {
            display: flex;
            gap: 16px;
        }

        .icenia-button-group > button {
            margin: 0 !important;
        }

        .icenia-button-group button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .match-nav-button {
            flex: 1;
            max-width: 200px;
        }

        .match-nav-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .confirmation-list {
            max-height: 500px;
            overflow-y: auto;
            border: 1px solid #b1b4b6;
            border-radius: 4px;
            padding: 15px;
            background: #f8f8f8;
        }

        .confirmation-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            margin-bottom: 10px;
            background: white;
            border-radius: 4px;
            border: 1px solid #ddd;
        }

        .confirmation-item .found-name {
            font-weight: bold;
            color: #0b0c0c;
        }

        .confirmation-item .arrow {
            color: #505a5f;
            margin: 0 10px;
        }

        .confirmation-item .matched-name {
            color: #00703c;
            font-weight: 600;
        }

        .confirmation-item .matched-name.invalid {
            color: #d4351c;
            font-style: italic;
        }

        .confirmation-item .edit-link {
            cursor: pointer;
            color: #1d70b8;
            text-decoration: underline;
            font-size: 0.9em;
        }

        .confirmation-item .edit-link:hover {
            color: #003078;
        }

        .name-match-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .found-name {
            font-weight: bold;
            font-size: 1.1em;
        }

        .match-count {
            color: #505a5f;
            font-size: 0.9em;
        }

        .match-options {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }

        .match-option {
            padding: 8px 12px;
            border: 2px solid #b1b4b6;
            border-radius: 4px;
            background: white;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            font-weight: normal;
        }

        .match-option:hover,
        .match-option:focus {
            border-color: #1d70b8;
            background: #f3f6fc;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            outline: none;
        }

        .match-option.selected {
            background: #1d70b8 !important;
            color: white !important;
            border-color: #1d70b8 !important;
            font-weight: bold !important;
            box-shadow: 0 2px 6px rgba(29, 112, 184, 0.3) !important;
        }

        .match-option.selected::before {
            content: '✓ ';
            font-weight: bold;
            margin-right: 4px;
        }

        .match-option.invalid {
            background: #d4351c !important;
            color: white !important;
            border-color: #d4351c !important;
            font-weight: bold !important;
            box-shadow: 0 2px 6px rgba(212, 53, 28, 0.3) !important;
        }

        .match-option.invalid::before {
            content: '✗ ';
            font-weight: bold;
            margin-right: 4px;
        }

        .correlation-warning {
            background: #fff3cd;
            border-left: 3px solid #ffc107;
            padding: 4px 8px;
            margin: 0;
            display: inline-block;
            font-size: 0.85em;
        }

        .correlation-warning::before {
            content: '⚠ ';
            color: #856404;
        }

        .correlation-warning-text {
            color: #856404;
        }

        .correlation-warning-text {
            color: #856404;
            font-weight: 600;
            flex: 1;
        }

        .manual-select-wrapper {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #ddd;
        }

        .manual-select-wrapper label {
            display: block;
            font-size: 0.9em;
            color: #505a5f;
            margin-bottom: 5px;
        }

        /* Duplicate Voters Styles */
        #duplicate-voters {
            max-width: 1200px;
        }

        .duplicate-voter-card {
            background: white;
            border: 2px solid #f47738;
            border-radius: 8px;
            margin-bottom: 30px;
            padding: 20px;
        }

        .duplicate-voter-card h3 {
            margin-top: 0;
            color: #f47738;
            font-size: 1.25em;
        }

        .duplicate-ballot-option {
            border: 2px solid #b1b4b6;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 15px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .duplicate-ballot-option:hover {
            border-color: #1d70b8;
            background: #f3f2f1;
        }

        .duplicate-ballot-option.selected {
            border-color: #1d70b8;
            background: #e8f4f8;
            border-width: 3px;
        }

        .duplicate-ballot-option.selected::before {
            content: '✓ ';
            color: #1d70b8;
            font-weight: bold;
            font-size: 1.2em;
        }

        .duplicate-ballot-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .duplicate-ballot-timestamp {
            color: #66d9ef;
            font-family: monospace;
        }

        .duplicate-ballot-rankings {
            background: #2b2b2b;
            color: #f8f8f2;
            padding: 10px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            max-height: 200px;
            overflow-y: auto;
        }

        .duplicate-ballot-rankings div {
            padding: 2px 0;
        }

        .duplicate-ballot-warning {
            color: #d4351c;
            font-style: italic;
            margin-top: 5px;
        }

        /* Ballot Review Styles */
        #ballot-review {
            max-width: 1200px;
        }

        .ballot-review-card {
            background: white;
            border: 2px solid #1d70b8;
            border-radius: 8px;
            margin-bottom: 20px;
            overflow: hidden;
        }

        .ballot-review-header {
            background: #1d70b8;
            color: white;
            padding: 15px 20px;
            font-weight: bold;
            font-size: 1.1em;
        }

        .ballot-column {
            min-width: 0; /* Ensure columns can shrink */
            /* No width or display properties here to avoid conflicts */
        }

        .ballot-column-header {
            font-weight: bold;
            font-size: 0.9em;
            color: #505a5f;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .ballot-original {
            background: #f8f8f8;
            border: 1px solid #ddd;
            border-radius: 6px;
            padding: 15px;
            box-sizing: border-box;
        }

        .ballot-mapping {
            background: #f3f6fc;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            padding: 15px 10px;
            min-width: 200px;
        }

        .ballot-result {
            background: white;
            border-left: 1px solid #ddd;
        }

        .ballot-original-entry {
            padding: 8px 10px;
            margin-bottom: 5px;
            background: white;
            border-radius: 4px;
            border: 1px solid #ddd;
            font-family: monospace;
            font-size: 0.9em;
        }

        .ballot-mapping-row {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 0;
            width: 100%;
            border-bottom: 1px solid #e0e6f0;
        }

        .ballot-mapping-row:last-child {
            border-bottom: none;
        }

        .mapping-arrow {
            color: #1d70b8;
            font-size: 1.2em;
            flex-shrink: 0;
        }

        .mapping-count {
            background: #e0e6f0;
            color: #1d70b8;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.75em;
            font-weight: bold;
            flex-shrink: 0;
        }

        .mapping-dropdown {
            flex: 1;
            font-size: 0.85em;
            padding: 4px 6px;
            border: 1px solid #b1b4b6;
            border-radius: 4px;
            max-width: 150px;
        }

        .ballot-result-entry {
            padding: 8px 10px;
            margin-bottom: 5px;
            background: #e8f5e9;
            border-radius: 4px;
            border: 1px solid #c8e6c9;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .ballot-result-rank {
            background: #00703c;
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.85em;
            flex-shrink: 0;
        }

        .ballot-result-name {
            color: #00703c;
            font-weight: 600;
        }

        .ballot-result-skipped {
            background: #fff3cd;
            border-color: #ffc107;
        }

        .ballot-result-skipped .ballot-result-name {
            color: #856404;
            font-style: italic;
        }

        .ballot-result-removed {
            background: #f8d7da;
            border-color: #f5c6cb;
        }

        .ballot-result-removed .ballot-result-name {
            color: #721c24;
            font-style: italic;
            text-decoration: line-through;
        }

        .ballot-nav-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
        }

        .ballot-summary {
            background: #f3f2f1;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 20px;
        }

        .ballot-summary-stat {
            display: inline-block;
            margin-right: 20px;
        }

        .ballot-summary-stat strong {
            color: #1d70b8;
        }

        /* NEW: Redesigned Ballot Review Styles */
        .ballot-review-card {
            max-width: 100%;
        }

        .ballot-review-card.ballot-modified {
            border-color: #ffc107;
        }

        .ballot-review-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modified-badge {
            background: #ffc107;
            color: #000;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 0.85em;
            font-weight: bold;
        }

        .ballot-review-body {
            display: flex !important;
            flex-direction: column !important;
            gap: 0 !important;
            width: 100% !important;
            max-width: 100% !important;
        }
        
        .ballot-row {
            display: grid !important;
            grid-template-columns: 1fr 1fr !important;
            gap: 0 !important;
            width: 100% !important;
        }

        .ballot-row-original,
        .ballot-row-structured {
            padding: 2px 10px !important;
            border-bottom: 1px solid #444 !important;
            min-height: 28px !important;
            display: flex !important;
            align-items: center !important;
        }

        .ballot-row-original {
            background: #2b2b2b !important;
            color: #f8f8f2 !important;
            font-family: 'Courier New', Consolas, monospace !important;
            font-size: 0.85em !important;
        }

        .ballot-row-structured {
            background: #1e1e1e !important;
            color: #e0e0e0 !important;
        }

        .ballot-original-full {
            background: #2b2b2b;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 6px;
            font-family: 'Courier New', Consolas, monospace;
            font-size: 0.9em;
            white-space: pre-wrap;
            line-height: 1.6;
            max-height: 500px;
            overflow-y: auto;
            overflow-x: auto;
            min-width: 0; /* Allow to shrink */
        }

        .voter-line {
            color: #66d9ef;
            font-weight: bold;
            min-height: 28px;
            display: flex;
            align-items: center;
        }

        .ranking-line {
            color: #f8f8f2;
            min-height: 44px;
            display: flex;
            align-items: center;
            padding: 8px 0;
        }

        .ballot-structured {
            background: #ffffff;
            padding: 15px;
            border-radius: 6px;
            border: 2px solid #1d70b8;
            min-width: 0 !important; /* Allow to shrink */
            box-sizing: border-box;
        }

        .structured-header {
            display: none; /* Hidden since voter is now in header */
        }

        .structured-rankings {
            max-height: 450px;
            overflow-y: auto;
        }

        .rank-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
            padding: 8px;
            background: white;
            border-radius: 4px;
            border: 1px solid #ddd;
            min-height: 44px;
        }

        .rank-row.modified {
            border-color: #ffc107;
            background: #fff3cd;
        }

        .rank-row.spacer {
            background: #f8f8f8;
            border: 1px dashed #999;
            padding: 8px;
            margin-bottom: 8px;
            min-height: 44px;
            opacity: 0.7;
        }

        .rank-row.spacer .rank-number {
            color: #999;
        }

        .rank-row.spacer .spacer-label {
            color: #999;
            font-style: italic;
            font-size: 0.85em;
        }

        .rank-number {
            font-weight: bold;
            color: #1d70b8;
            width: 30px;
            flex-shrink: 0;
        }

        .rank-dropdown {
            flex: 1;
            padding: 6px 8px;
            border: 1px solid #b1b4b6;
            border-radius: 4px;
            font-size: 0.9em;
        }

        .rank-move-btn {
            background: #f3f2f1;
            border: 1px solid #b1b4b6;
            border-radius: 4px;
            width: 28px;
            height: 28px;
            cursor: pointer;
            font-size: 1em;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .rank-move-btn:hover:not(:disabled) {
            background: #e0e0e0;
        }

        .rank-move-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .rank-remove {
            background: #d4351c;
            color: white;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            cursor: pointer;
            font-weight: bold;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .rank-remove:hover {
            background: #942514;
        }

        .add-ranking-container {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px dashed #ddd;
            display: flex;
            gap: 10px;
        }

        .add-ranking-dropdown {
            flex: 1;
            padding: 8px;
            border: 1px solid #b1b4b6;
            border-radius: 4px;
            font-size: 0.9em;
        }

        .add-ranking {
            padding: 8px 16px;
            background: #00703c;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            flex-shrink: 0;
        }

        .add-ranking:hover {
            background: #005a30;
        }

        .reset-ballot-btn {
            margin-top: 15px;
            width: 100%;
            padding: 10px;
            background: #505a5f;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        }

        .reset-ballot-btn:hover {
            background: #383f43;
        }

    </style>
    
    <script>
        // Detect keyboard vs mouse navigation for proper focus-visible behavior
        window.addEventListener('keydown', function(e) {
            if (e.key === 'Tab' || e.key === 'w' || e.key === 'W') {
                document.body.classList.add('is-keyboard-user');
            }
        });

        window.addEventListener('mousedown', function() {
            document.body.classList.remove('is-keyboard-user');
        });
        
        // STV Implementation in JavaScript
        
        // Track current input mode
        let inputMode: 'simple' | 'discord' = 'simple';
        
        // State for Discord mode
        let parsedData: {
            candidates: string[];
            ballots: Array<{voter: string, rankings: string[]}>;
            seats: number;
            electionName: string;
            nameMatches: Map<string, string | null>;
            uniqueNames: string[];
            currentNameIndex: number;
            nameCounts: Map<string, number>;
            learnedCorrelations: Map<string, string | null>;
            correlationInfluences: Map<string, Set<string>>;
            hasCorrelationWarning: boolean;
            ballotOverrides: Map<string, {rank: number, candidate: string}[]>;
            originalBallotText: Map<string, string>;
            reviewedNames: Set<string>; // Track which names have been reviewed by operator
            duplicateSelections: Map<string, number>; // Track selected ballot index for duplicate voters
        } = {
            candidates: [],
            ballots: [],
            seats: 5,
            electionName: '',
            nameMatches: new Map(),
            uniqueNames: [], // Ordered list of unique names to review
            currentNameIndex: 0, // Current position in uniqueNames array
            nameCounts: new Map(), // Count of each name in ballots
            learnedCorrelations: new Map(), // Store user-confirmed name correlations
            correlationInfluences: new Map(), // Track which names were influenced by each correlation
            hasCorrelationWarning: false, // Flag to indicate if a correlation changed
            ballotOverrides: new Map(), // Store manual edits made during ballot review
            originalBallotText: new Map(), // Store original raw text per voter
            reviewedNames: new Set(), // Track which names have been reviewed
            duplicateSelections: new Map() // Track selected ballot for duplicate voters
        };
        
        class Ballot {
            name: string;
            rankingList: number[];
            votingPower: number;
            candidateCount: number;
            
            constructor(name, rankingList, votingPower, candidateCount) {
                this.name = name;
                this.rankingList = [...rankingList];
                this.votingPower = votingPower;
                this.candidateCount = candidateCount;
            }
            
            getRankedChoice(num) {
                for (let c of this.rankingList) {
                    if (c !== -1) {
                        if (num === 1) {
                            return c;
                        } else {
                            num--;
                        }
                    }
                }
                return 0;
            }
            
            eliminate(candidateNumber) {
                for (let i = 0; i < this.rankingList.length; i++) {
                    if (this.rankingList[i] === candidateNumber) {
                        this.rankingList[i] = -1;
                    }
                }
            }
            
            isExhausted() {
                for (let c of this.rankingList) {
                    if (c !== -1 && c !== 0) {
                        return false;
                    }
                }
                return true;
            }
        }
        
        function ballotFromNames(name, candidateNames, candidateReferences) {
            const rankingList: number[] = [];
            
            for (let candidateName of candidateNames) {
                const num = getCandidateNumber(candidateName, candidateReferences);
                if (num > 0) {
                    rankingList.push(num);
                } else {
                    console.error(`${name}'s ballot has invalid candidate '${candidateName}'.`);
                    return null;
                }
            }
            
            // Fill remaining spots with 0
            for (let i = candidateNames.length; i < candidateReferences.length; i++) {
                rankingList.push(0);
            }
            
            return new Ballot(name, rankingList, 1, candidateReferences.length);
        }
        
        function getCandidateNumber(candidateName, candidateReferences) {
            const normalized = candidateName.trim().toLowerCase();
            for (let i = 0; i < candidateReferences.length; i++) {
                if (candidateReferences[i].toLowerCase() === normalized) {
                    return i + 1;
                }
            }
            return -2;
        }
        
        function votesInFavor(ballots, candidateNumber) {
            let primaryVotes = 0;
            let tieBreakerValue = 0;
            let counted: Ballot[] = [];
            
            for (let b of ballots) {
                // Primary Vote (Rank 1) - Strict voting power
                if (b.getRankedChoice(1) === candidateNumber) {
                    primaryVotes += b.votingPower * 1;
                    counted.push(b);
                }
                
                // Tie Breakers (Do not affect voting power sums for surplus)
                if (b.getRankedChoice(2) === candidateNumber) {
                    tieBreakerValue += b.votingPower * 0.001; // 1/1000
                }
                if (b.getRankedChoice(3) === candidateNumber) {
                    tieBreakerValue += b.votingPower * 0.000001; // 1/1,000,000
                }
            }
            
            return { 
                primaryVotes, 
                tieBreakerValue, 
                totalScore: primaryVotes + tieBreakerValue, // Used for sorting only
                counted 
            };
        }
        
        function extremeCandidate(ballots, mode) {
            if (!ballots || ballots.length === 0 || !ballots[0].rankingList) {
                return -1;
            }
            
            const candidates = new Array(ballots[0].rankingList.length).fill(0);
            
            // Calculate scores for all candidates
            for (let i = 0; i < candidates.length; i++) {
                // We use totalScore (primary + tiebreaker) for ranking comparison
                candidates[i] = votesInFavor(ballots, i + 1).totalScore;
            }
            
            // Find first candidate with non-zero votes
            let toReturn = -1;
            for (let i = 0; i < candidates.length; i++) {
                // Check if candidate exists/has non-zero score
                if (candidates[i] !== 0) {
                    toReturn = i + 1;
                    break;
                }
            }
            
            // If all candidates have 0 votes (and mode is looking for max), return -1
            if (toReturn === -1) {
                // Only error if we are looking for a winner (mode 1). 
                // If looking for loser (mode -1) and everyone is 0, just pick the first one.
                if (mode === 1) {
                    console.error("All candidates have 0 votes");
                    return -1;
                } else {
                    return 1; // Default to first candidate if everyone is at 0
                }
            }
            
            // Find extreme (min or max based on mode)
            for (let i = 0; i < candidates.length; i++) {
                // If scores are equal, we don't change 'toReturn' (stable sort effect),
                // effectively breaking further ties by Candidate ID order if strict tie.
                if (mode * candidates[i] > mode * candidates[toReturn - 1] && candidates[i] !== 0) {
                    toReturn = i + 1;
                }
            }
            
            return toReturn;
        }
        
        function eliminateCandidate(ballots, candidateNumber) {
            for (let b of ballots) {
                b.eliminate(candidateNumber);
            }
        }
        
        function STV(ballots, k, candidateReferences, logCallback) {
            logCallback(`STV with ${k} winners, ${ballots[0].rankingList.length} candidates, ${ballots.length} ballots\n\n`);
            
            const winners: string[] = [];
            let totalVote = ballots.length;
            
            // Track round-by-round results for export
            const roundResults: any[] = [];
            let roundNumber = 1;
            let cumulativeExhausted = 0; // Track total exhausted votes across all rounds
            
            while (winners.length < k) {
                logCallback(`--- Round ${roundNumber} ---\n`);
                
                // Calculate tally for this round (Visual only)
                const roundTally: Record<string, number> = {};
                for (let i = 0; i < candidateReferences.length; i++) {
                    const candidateIndex = i + 1;
                    // Use primaryVotes for display tally to be clean
                    const { primaryVotes } = votesInFavor(ballots, candidateIndex);
                    if (primaryVotes > 0) {
                        roundTally[candidateReferences[i]] = primaryVotes;
                    }
                }
                
                // Log current tally
                const tallyEntries = Object.entries(roundTally).sort((a, b) => b[1] - a[1]);
                for (const [candidate, votes] of tallyEntries) {
                    logCallback(`  ${candidate}: ${(votes as number).toFixed(3)} votes\n`);
                }
                logCallback(`\n`);
                
                const topCandidate = extremeCandidate(ballots, 1);
                
                if (topCandidate === -1) {
                    logCallback(`\nERROR: Cannot determine top candidate. Stopping election.\n`, 'error');
                    break;
                }
                
                // Get detailed vote breakdown
                const { primaryVotes: topCandidatePrimaryVotes, totalScore: topCandidateTotalScore, counted: votesForTopCandidate } = votesInFavor(ballots, topCandidate);
                
                // IcenianSTV uses float division for quota (not ceiled)
                // Note: Constitution specifies "rounded up to the nearest integer" 
                // but IcenianSTV implements it as a float comparison
                const quota = totalVote / (k + 1);
                
                const roundData: any = {
                    round: roundNumber,
                    tally: roundTally,
                    quota: quota, // Dynamic quota for this round
                    exhausted: cumulativeExhausted, // Cumulative exhausted votes
                    tallyResults: []
                };
                
                // IcenianSTV faithfulness: Use totalScore (with tie-breakers) for quota check
                // to match the original implementation's behavior
                if (topCandidateTotalScore >= quota) {
                    const candidateName = candidateReferences[topCandidate - 1];
                    winners.push(candidateName);
                    
                    logCallback(`✓ WIN: ${candidateName} (${topCandidateTotalScore.toFixed(3)} votes, Quota: ${quota.toFixed(3)})\n`, 'win');
                    
                    roundData.tallyResults.push({
                        elected: candidateName,
                        transfers: {}
                    });
                    
                    eliminateCandidate(ballots, topCandidate);
                    
                    // CORRECTED: Surplus Calculation using primaryVotes only
                    // IcenianSTV formula: (votes received - quota)/(votes received)
                    // Using primaryVotes (not totalScore) ensures tie-breaker fractions 
                    // do not create ghost voting power in surplus distribution.
                    // Note: IcenianSTV uses topCandidateVotes (with tie-breakers) in denominator
                    // but we use primaryVotes to prevent ghost voting power amplification.
                    const surplusFraction = (topCandidatePrimaryVotes - quota) / topCandidatePrimaryVotes;
                    
                    for (let b of votesForTopCandidate) {
                        b.votingPower *= surplusFraction;
                    }
                } else {
                    const bottomCandidate = extremeCandidate(ballots, -1);
                    
                    if (bottomCandidate === -1) {
                        logCallback(`\nERROR: Cannot determine bottom candidate. Stopping election.\n`, 'error');
                        break;
                    }
                    
                    const candidateName = candidateReferences[bottomCandidate - 1];
                    const { primaryVotes: bottomVotes, counted: ballotsForBottom } = votesInFavor(ballots, bottomCandidate);
                    
                    logCallback(`✗ ELIM: ${candidateName} (${bottomVotes.toFixed(3)} votes from ${ballotsForBottom.length} ballots)\n`, 'elim');
                    
                    // Log vote transfer details
                    if (ballotsForBottom.length > 0) {
                        const transferDetails: string[] = [];
                        for (let b of ballotsForBottom) {
                            const nextChoice = b.getRankedChoice(2);
                            if (nextChoice > 0) {
                                transferDetails.push(`  ${b.name} (power: ${b.votingPower.toFixed(3)}) → ${candidateReferences[nextChoice - 1]}`);
                            } else {
                                transferDetails.push(`  ${b.name} (power: ${b.votingPower.toFixed(3)}) → [exhausted]`);
                            }
                        }
                        if (transferDetails.length > 0 && transferDetails.length <= 20) {
                            logCallback(transferDetails.join('\n') + '\n');
                        } else if (transferDetails.length > 20) {
                            logCallback(`  [${transferDetails.length} ballots transferring...]\n`);
                        }
                    }
                    
                    roundData.tallyResults.push({
                        eliminated: candidateName,
                        transfers: {}
                    });
                    
                    eliminateCandidate(ballots, bottomCandidate);
                }
                
                roundResults.push(roundData);
                roundNumber++;
                
                // Handle exhausted ballots
                // Total Vote is dynamic based on non-exhausted power
                let exhaustedCount = 0;
                let exhaustedPower = 0;
                for (let b of ballots) {
                    if (b.isExhausted() && b.votingPower > 0) {
                        exhaustedCount++;
                        exhaustedPower += b.votingPower;
                        totalVote -= b.votingPower;
                        b.votingPower = 0;
                    }
                }
                cumulativeExhausted += exhaustedPower; // Add to cumulative total
                if (exhaustedCount > 0) {
                    logCallback(`  ${exhaustedCount} ballot(s) exhausted (total power: ${exhaustedPower.toFixed(3)})\n`);
                }
                logCallback(`  Total remaining voting power: ${totalVote.toFixed(3)}\n\n`);
            }
            
            // Add final round showing only winners and exhausted
            const finalRoundTally: Record<string, number> = {};
            for (const winner of winners) {
                // Winners are frozen at the quota from when they won
                const winRound = roundResults.find(r => 
                    r.tallyResults.some((tr: any) => tr.elected === winner)
                );
                if (winRound) {
                    finalRoundTally[winner] = winRound.quota;
                }
            }
            
            const finalQuota = totalVote / (k + 1);
            roundResults.push({
                round: roundNumber,
                tally: finalRoundTally,
                quota: finalQuota,
                exhausted: cumulativeExhausted,
                tallyResults: [],
                isFinalRound: true // Mark this as the final summary round
            });
            
            (parsedData as any).roundResults = roundResults;
            return winners;
        }
        
        // ===== EXPORT/IMPORT FUNCTIONS =====

        function getElectionName(): string {
            const input = document.getElementById('election-name') as HTMLInputElement;
            const name = (input?.value || parsedData.electionName || '').trim();
            parsedData.electionName = name;
            return name;
        }

        function slugifyElectionName(name: string): string {
            return name
                .toLowerCase()
                .replace(/[^a-z0-9]+/gi, '-')
                .replace(/-{2,}/g, '-')
                .replace(/^-+|-+$/g, '');
        }

        function buildExportFilename(prefix: string, extension = 'json'): string {
            const name = getElectionName();
            const dateStr = new Date().toISOString().split('T')[0];
            const slug = slugifyElectionName(name);
            const base = slug ? `${prefix}-${slug}` : `${prefix}-${dateStr}`;
            return `${base}.${extension}`;
        }
        
        // Export entire election state to JSON file
        function exportElection() {
            const electionName = getElectionName();
            // Determine current section
            let currentSection = 'import';
            if (document.getElementById('name-matching')?.style.display !== 'none') {
                currentSection = 'name-matching';
            } else if (document.getElementById('ballot-review')?.style.display !== 'none') {
                currentSection = 'ballot-review';
            } else if (document.getElementById('results')?.style.display !== 'none') {
                currentSection = 'results';
            }
            
            const exportData = {
                version: '2.1',
                timestamp: new Date().toISOString(),
                inputMode: inputMode,
                electionName,
                candidates: parsedData.candidates,
                ballots: parsedData.ballots ? parsedData.ballots.map((b: any) => ({
                    voter: b.voter,
                    rankings: b.rankings,
                    preferences: b.preferences
                })) : [],
                rawDiscordInput: {
                    candidates: (document.getElementById('discord-candidates') as HTMLTextAreaElement)?.value || '',
                    ballots: (document.getElementById('discord-ballots') as HTMLTextAreaElement)?.value || '',
                    seats: parsedData.seats
                },
                nameMatches: Object.fromEntries(parsedData.nameMatches),
                learnedCorrelations: Object.fromEntries(parsedData.learnedCorrelations),
                ballotOverrides: Object.fromEntries(parsedData.ballotOverrides),
                originalBallotText: Object.fromEntries(parsedData.originalBallotText),
                reviewedNames: Array.from(parsedData.reviewedNames),
                uniqueNames: parsedData.uniqueNames,
                nameCounts: Object.fromEntries(parsedData.nameCounts),
                // Save current position
                currentState: {
                    section: currentSection,
                    currentNameIndex: parsedData.currentNameIndex,
                    currentBallotIndex: currentBallotIndex
                }
            };
            
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = buildExportFilename('stv-election');
            a.click();
            URL.revokeObjectURL(url);
        }
        
        // Export for RCVis (Universal Tabulator format)
        function exportForRCVis() {
            const roundResults = (parsedData as any).roundResults;
            if (!roundResults || roundResults.length === 0) {
                alert('No results to export. Please calculate results first.');
                return;
            }
            
            const today = new Date();
            const dateStr = today.toISOString().split('T')[0];
            const electionName = getElectionName();
            const contestName = electionName || 'Icenian Election';
            
            const rcvisData = {
                config: {
                    contest: contestName,
                    date: dateStr,
                    jurisdiction: "Icenia",
                    office: contestName,
                    threshold: (parsedData.ballots.length / (parsedData.seats + 1)).toFixed(3)
                },
                results: roundResults.map((round: any) => ({
                    round: round.round,
                    tally: Object.fromEntries(
                        Object.entries(round.tally).map(([candidate, votes]) => [
                            candidate,
                            (votes as number).toFixed(3)
                        ])
                    ),
                    quota: round.quota ? parseFloat(round.quota.toFixed(3)) : undefined, // Dynamic quota per round
                    exhausted: round.exhausted ? parseFloat(round.exhausted.toFixed(3)) : 0, // Exhausted votes
                    isFinalRound: round.isFinalRound || false, // Final round flag
                    tallyResults: round.tallyResults
                }))
            };
            
            const blob = new Blob([JSON.stringify(rcvisData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = buildExportFilename('rcvis-election');
            a.click();
            URL.revokeObjectURL(url);
        }
        
        // Import election state from JSON file
        function importElection(file: File) {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const importData = JSON.parse(e.target?.result as string);
                    
                    // Restore input mode
                    if (importData.inputMode) {
                        inputMode = importData.inputMode;
                        localStorage.setItem('input-mode', inputMode);
                        const modeRadio = document.querySelector(`input[name="input-mode"][value="${importData.inputMode}"]`) as HTMLInputElement;
                        if (modeRadio) modeRadio.checked = true;
                        
                        // Show/hide appropriate mode
                        if (inputMode === 'discord') {
                            (document.getElementById('simple-mode') as HTMLElement).style.display = 'none';
                            (document.getElementById('discord-mode') as HTMLElement).style.display = 'block';
                        } else {
                            (document.getElementById('simple-mode') as HTMLElement).style.display = 'block';
                            (document.getElementById('discord-mode') as HTMLElement).style.display = 'none';
                        }
                    }
                    
                    // Restore Discord inputs if available
                    if (importData.rawDiscordInput) {
                        const candidatesInput = document.getElementById('discord-candidates') as HTMLTextAreaElement;
                        const ballotsInput = document.getElementById('discord-ballots') as HTMLTextAreaElement;
                        if (candidatesInput) {
                            candidatesInput.value = importData.rawDiscordInput.candidates || '';
                            localStorage.setItem('discord-candidates', candidatesInput.value);
                        }
                        if (ballotsInput) {
                            ballotsInput.value = importData.rawDiscordInput.ballots || '';
                            localStorage.setItem('discord-ballots', ballotsInput.value);
                        }
                    }
                    
                    // Restore learned correlations
                    if (importData.learnedCorrelations) {
                        parsedData.learnedCorrelations = new Map(Object.entries(importData.learnedCorrelations));
                    }

                    if (importData.electionName) {
                        parsedData.electionName = importData.electionName;
                        const electionNameInput = document.getElementById('election-name') as HTMLInputElement;
                        if (electionNameInput) {
                            electionNameInput.value = parsedData.electionName;
                        }
                        localStorage.setItem('election-name', parsedData.electionName);
                    }
                    
                    // Restore candidates
                    if (importData.candidates) {
                        parsedData.candidates = importData.candidates;
                    }
                    
                    // Restore ballots
                    if (importData.ballots && importData.ballots.length > 0) {
                        // Need to convert back to Ballot objects properly
                        // Store as raw data for now since we'd need candidates list
                        parsedData.ballots = importData.ballots;
                    }
                    
                    // Restore seats
                    if (importData.rawDiscordInput?.seats) {
                        parsedData.seats = importData.rawDiscordInput.seats;
                    }
                    
                    // Restore name matches
                    if (importData.nameMatches) {
                        parsedData.nameMatches = new Map(
                            Object.entries(importData.nameMatches).map(([k, v]) => 
                                [k, v === 'null' ? null : v as string | null]
                            )
                        );
                    }
                    
                    // Restore ballot overrides
                    if (importData.ballotOverrides) {
                        parsedData.ballotOverrides = new Map(
                            Object.entries(importData.ballotOverrides).map(([k, v]) => 
                                [k, v as {rank: number, candidate: string}[]]
                            )
                        );
                    }
                    
                    // Restore original ballot text
                    if (importData.originalBallotText) {
                        parsedData.originalBallotText = new Map(
                            Object.entries(importData.originalBallotText).map(([k, v]) => [k, v as string])
                        );
                    }
                    
                    // Restore reviewed names
                    if (importData.reviewedNames && Array.isArray(importData.reviewedNames)) {
                        parsedData.reviewedNames = new Set(importData.reviewedNames);
                    }
                    
                    // Restore uniqueNames (for name matching navigation)
                    if (importData.uniqueNames && Array.isArray(importData.uniqueNames)) {
                        parsedData.uniqueNames = importData.uniqueNames;
                    }
                    
                    // Restore nameCounts
                    if (importData.nameCounts) {
                        parsedData.nameCounts = new Map(Object.entries(importData.nameCounts).map(([k, v]) => [k, v as number]));
                    }
                    
                    // Restore current state and navigate to appropriate section
                    if (importData.currentState) {
                        // Restore indices
                        if (typeof importData.currentState.currentNameIndex === 'number') {
                            parsedData.currentNameIndex = importData.currentState.currentNameIndex;
                        }
                        if (typeof importData.currentState.currentBallotIndex === 'number') {
                            currentBallotIndex = importData.currentState.currentBallotIndex;
                        }
                        
                        // Navigate to the appropriate section
                        const section = importData.currentState.section;
                        if (section === 'name-matching' && parsedData.uniqueNames.length > 0) {
                            // Go to name matching and render
                            document.getElementById('import-section')!.style.display = 'none';
                            document.getElementById('simple-mode')!.style.display = 'none';
                            document.getElementById('discord-mode')!.style.display = 'none';
                            document.getElementById('name-matching')!.style.display = 'block';
                            document.getElementById('ballot-review')!.style.display = 'none';
                            document.getElementById('duplicate-voters')!.style.display = 'none';
                            document.getElementById('results')!.style.display = 'none';
                            renderCurrentName();
                        } else if (section === 'ballot-review' && parsedData.ballots.length > 0) {
                            // Go to ballot review and render
                            document.getElementById('import-section')!.style.display = 'none';
                            document.getElementById('simple-mode')!.style.display = 'none';
                            document.getElementById('discord-mode')!.style.display = 'none';
                            document.getElementById('name-matching')!.style.display = 'none';
                            document.getElementById('ballot-review')!.style.display = 'block';
                            document.getElementById('duplicate-voters')!.style.display = 'none';
                            document.getElementById('results')!.style.display = 'none';
                            renderBallotReview();
                        } else if (section === 'results') {
                            // Go to results and calculate
                            document.getElementById('import-section')!.style.display = 'none';
                            document.getElementById('simple-mode')!.style.display = 'none';
                            document.getElementById('discord-mode')!.style.display = 'none';
                            document.getElementById('name-matching')!.style.display = 'none';
                            document.getElementById('ballot-review')!.style.display = 'none';
                            document.getElementById('duplicate-voters')!.style.display = 'none';
                            document.getElementById('results')!.style.display = 'block';
                            calculateResults();
                        }
                    }
                    
                    // Update correlation table UI with imported data
                    updateCorrelationTable();
                    
                    alert('Election imported successfully!');
                } catch (err) {
                    alert('Failed to import election: ' + (err as Error).message);
                }
            };
            reader.readAsText(file);
        }
        
        // Clear all session data and start a new election
        function clearSession() {
            if (!confirm('Are you sure you want to clear all data and start a new election? This will reset all election data, including candidate and ballot data, and learned name correlations.')) {
                return;
            }
            
            // Clear parsed data
            parsedData = {
                candidates: [],
                ballots: [],
                seats: 0,
                electionName: '',
                nameMatches: new Map(),
                uniqueNames: [],
                currentNameIndex: 0,
                learnedCorrelations: new Map(),
                correlationInfluences: new Map(),
                hasCorrelationWarning: false,
                nameCounts: new Map(),
                ballotOverrides: new Map(),
                originalBallotText: new Map(),
                reviewedNames: new Set(),
                duplicateSelections: new Map()
            };

            localStorage.removeItem('election-name');
            const electionNameInput = document.getElementById('election-name') as HTMLInputElement;
            if (electionNameInput) {
                electionNameInput.value = '';
            }
            
            // Hide name matching, ballot review, and results
            const nameMatching = document.getElementById('name-matching');
            const ballotReview = document.getElementById('ballot-review');
            const results = document.getElementById('results');
            const importSection = document.getElementById('import-section');
            if (nameMatching) nameMatching.style.display = 'none';
            if (ballotReview) ballotReview.style.display = 'none';
            if (results) results.style.display = 'none';
            if (importSection) importSection.style.display = 'block';
            
            // Reset input mode to simple
            inputMode = 'simple';
            localStorage.setItem('input-mode', 'simple');
            const simpleRadio = document.getElementById('mode-simple') as HTMLInputElement;
            if (simpleRadio) simpleRadio.checked = true;
            
            // Show simple mode, hide discord mode
            (document.getElementById('simple-mode') as HTMLElement).style.display = 'block';
            (document.getElementById('discord-mode') as HTMLElement).style.display = 'none';
            
            // Update correlation table
            updateCorrelationTable();
        }
        
        // ===== DISCORD PARSING FUNCTIONS =====
        
        // Clean candidate name - remove @ symbols, extra spaces, and normalize
        function cleanCandidateName(name) {
            return name
                .replace(/@/g, '')
                .replace(/^\d+\.?\s*/, '') // Remove leading numbers like "2." or "3 "
                .replace(/\([^)]*\)/g, '') // Remove parentheses content
                .replace(/["']/g, '') // Remove quotes
                .trim()
                .replace(/\s+/g, ' '); // Normalize spaces
        }
        
        // Simplify voter name - remove role prefixes and normalize
        function simplifyVoterName(name) {
            // Common role prefixes to remove (case-insensitive)
            const rolePrefixes = [
                'ex-councilor', 'ex councilor',
                'councilor', 'council',
                'mayor', 'president',
                'ceo', 'speaker',
                'turbo janny',
                'senator', 'judge',
                'trial_len',
                'lord', 'sir',
            ];
            
            let simplified = name.trim();
            
            // Remove role prefixes (case-insensitive)
            for (const prefix of rolePrefixes) {
                const regex = new RegExp(`^${prefix}\\s+`, 'i');
                simplified = simplified.replace(regex, '');
            }
            
            // Remove special characters except alphanumeric and underscore
            simplified = simplified
                .replace(/[^a-zA-Z0-9_\s]/g, '')
                .replace(/\s+/g, '')
                .toLowerCase();
            
            return simplified || name.toLowerCase().replace(/[^a-z0-9]/g, '');
        }
        
        // Parse official candidates from text
        function parseOfficialCandidates(text) {
            const lines = text.split('\n').map(l => l.trim()).filter(l => l.length > 0);
            const candidates: string[] = [];
            
            for (let line of lines) {
                const cleaned = cleanCandidateName(line);
                if (cleaned) {
                    candidates.push(cleaned);
                }
            }
            
            return candidates;
        }
        
        // Extract voter name from Discord line (before timestamp)
        function extractVoterName(line) {
            // Match pattern: "Name — MM/DD/YYYY HH:MM" or "Name — Yesterday at HH:MM" or "Name — Today at HH:MM"
            const timestampMatch = line.match(/^(.+?)\s*—\s*(\d{1,2}\/\d{1,2}\/\d{4}|Yesterday at|Today at)/i);
            if (timestampMatch) {
                return timestampMatch[1].trim();
            }
            
            // Try to extract name before timestamp
            const parts = line.split(/\s*—\s*/);
            if (parts.length > 0) {
                return parts[0].trim();
            }
            
            return line.trim();
        }
        
        // Parse Discord ballot data
        function parseDiscordBallots(text, officialCandidates) {
            const lines = text.split('\n');
            const ballots: Array<{voter: string, rankings: string[]}> = [];
            const allFoundNames = new Set<string>();
            const originalBallotText = new Map<string, string>();
            
            let currentVoter: string | null = null;
            let currentRankings: string[] = [];
            let lastLineWasVoter = false;
            let ballotStartLine = 0; // Track where the current ballot started
            const voterBallotCounts = new Map<string, number>(); // Track how many ballots each voter has submitted
            
            // Helper function to check if a line looks like a timestamp line
            const isTimestampLine = (line: string) => /—\s*(\d{1,2}\/\d{1,2}\/\d{4}|Yesterday at|Today at)/i.test(line);
            
            // Helper function to look ahead and find the next non-empty line
            const getNextNonEmptyLine = (startIndex: number): { line: string, index: number } | null => {
                for (let j = startIndex + 1; j < lines.length; j++) {
                    const nextLine = lines[j].trim();
                    if (nextLine) return { line: nextLine, index: j };
                }
                return null;
            };
            
            // Helper function to save ballot with original text
            const saveBallot = (voterBaseName: string, rankings: string[], endLineIndex: number) => {
                // Track ballot count for this voter
                const count = (voterBallotCounts.get(voterBaseName) || 0) + 1;
                voterBallotCounts.set(voterBaseName, count);
                
                // Create unique voter identifier if this is not the first ballot
                const voter = count > 1 ? `${voterBaseName}#${count}` : voterBaseName;
                
                ballots.push({
                    voter: voter,
                    rankings: [...rankings]
                });
                // Store original text for this ballot
                const originalText = lines.slice(ballotStartLine, endLineIndex + 1).join('\n');
                originalBallotText.set(voter, originalText);
            };
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                
                if (!line) continue;
                
                // Check if this looks like a voter line (has timestamp or is at start of ballot)
                const hasTimestamp = isTimestampLine(line);
                const maybeCandidate = cleanCandidateName(line);
                
                // Check if this line might be a voter name followed by a timestamp on next non-empty line
                // Pattern: "jammy mie\n\n — 03/01/2026" where voter name is separate from timestamp
                let isVoterNameBeforeTimestamp = false;
                if (!hasTimestamp && maybeCandidate) {
                    const nextNonEmpty = getNextNonEmptyLine(i);
                    if (nextNonEmpty && isTimestampLine(nextNonEmpty.line)) {
                        // This line is a voter name, next line is timestamp
                        // Check if timestamp line ONLY has timestamp (no voter name in it)
                        const nextLineVoterName = extractVoterName(nextNonEmpty.line);
                        // If the extracted voter name is empty or very short, use current line as voter name
                        if (!nextLineVoterName || nextLineVoterName.length < 2 || nextLineVoterName.startsWith('—')) {
                            isVoterNameBeforeTimestamp = true;
                        }
                    }
                }
                
                // If line has timestamp or looks like start of new ballot
                // Only start new ballot on clear evidence: timestamp line or voter name before timestamp
                // Do NOT treat candidate names as new voters
                if (hasTimestamp || isVoterNameBeforeTimestamp) {
                    // Save previous ballot if exists
                    if (currentVoter && currentRankings.length > 0) {
                        saveBallot(currentVoter, currentRankings, i - 1);
                    }
                    
                    // Start new ballot - mark line as start
                    ballotStartLine = i;
                    
                    if (hasTimestamp) {
                        currentVoter = simplifyVoterName(extractVoterName(line));
                        currentRankings = [];
                        lastLineWasVoter = true;
                        
                        // Check if there's a candidate on the same line after timestamp
                        const afterTimestamp = line.split(/\d{2}:\d{2}/)[1];
                        if (afterTimestamp) {
                            const candidateName = cleanCandidateName(afterTimestamp);
                            if (candidateName && candidateName !== currentVoter) {
                                currentRankings.push(candidateName);
                                allFoundNames.add(candidateName);
                            }
                        }
                    } else if (isVoterNameBeforeTimestamp) {
                        // This line is the voter name, skip to after the timestamp line
                        currentVoter = simplifyVoterName(maybeCandidate);
                        currentRankings = [];
                        lastLineWasVoter = true;
                        // Skip to the timestamp line (it will be skipped on next iteration)
                        const nextNonEmpty = getNextNonEmptyLine(i);
                        if (nextNonEmpty) {
                            i = nextNonEmpty.index; // Skip to timestamp line
                        }
                    }
                } else {
                    // This is a candidate ranking
                    const candidateName = cleanCandidateName(line);
                    
                    // Skip if line is too short, is just punctuation, or looks like commentary
                    if (!candidateName || candidateName.length < 2) continue;
                    if (/^[\d\.\)\-]+$/.test(candidateName)) continue;
                    
                    // Skip common non-candidate phrases and commentary
                    const lowerName = candidateName.toLowerCase();
                    if (lowerName.includes('wasnt i banned') || 
                        lowerName.includes('was barred') ||
                        lowerName.includes('barred from') ||
                        lowerName.includes('write-in') ||
                        lowerName.includes('aka') ||
                        lowerName.includes('tgat what') ||
                        lowerName.includes('yay ty') ||
                        lowerName.includes('highest honor') ||
                        lowerName.includes('im dead bro') ||
                        lowerName.includes('vote this') ||
                        lowerName.includes('fight venezuela') ||
                        lowerName.includes('made a little bit') ||
                        lowerName.includes('voted in') ||
                        lowerName.includes('the order') ||
                        lowerName.includes('what im saying') ||
                        lowerName.startsWith('this') ||
                        lowerName.startsWith('that')) {
                        continue;
                    }
                    
                    if (currentVoter) {
                        currentRankings.push(candidateName);
                        allFoundNames.add(candidateName);
                    } else if (lastLineWasVoter) {
                        // First line after voter might be voter name itself if no timestamp
                        currentVoter = candidateName;
                        lastLineWasVoter = false;
                    }
                }
            }
            
            // Don't forget last ballot
            if (currentVoter && currentRankings.length > 0) {
                saveBallot(currentVoter, currentRankings, lines.length - 1);
            }
            
            return { ballots, allFoundNames: Array.from(allFoundNames), originalBallotText };
        }
        
        function startsWithNumber(str) {
            return /^\d+\.?/.test(str.trim());
        }
        
        // Fuzzy match candidate names
        function fuzzyMatch(name1, name2) {
            // Normalize: handle common character substitutions (0 vs o, etc.)
            const normalizeChars = (str: string) => str
                .replace(/0/g, 'o')
                .replace(/1/g, 'i')
                .replace(/3/g, 'e')
                .replace(/5/g, 's')
                .replace(/7/g, 't');
            
            const n1 = normalizeChars(name1.toLowerCase()).replace(/[^a-z0-9]/g, '');
            const n2 = normalizeChars(name2.toLowerCase()).replace(/[^a-z0-9]/g, '');
            
            // Exact match (ignoring special chars and character substitutions)
            if (n1 === n2) return 1.0;
            
            // One contains the other
            if (n1.includes(n2) || n2.includes(n1)) return 0.95;
            
            // Check for nickname/abbreviation matches
            const words1 = name1.toLowerCase().split(/\s+/);
            const words2 = name2.toLowerCase().split(/\s+/);
            
            // Check if shorter name is abbreviation or nickname of longer name
            const shorter = n1.length < n2.length ? n1 : n2;
            const longer = n1.length < n2.length ? n2 : n1;
            
            // Short nickname handling (e.g., "rat" -> "ratat0ing", "creep" -> "creepilycreep")
            // If the shorter name is 3-5 chars and appears in the longer name, high score
            if (shorter.length >= 3 && shorter.length <= 5 && longer.includes(shorter)) {
                // Extra boost if it's at the start
                if (longer.startsWith(shorter)) return 0.9;
                return 0.85;
            }
            
            // Abbreviation: shorter name matches start of longer (e.g., "hsm" -> "hsmnewfriend")
            if (longer.startsWith(shorter) && shorter.length >= 3) return 0.88;
            
            // Common nickname patterns (e.g., "toast" in "toasttastesprettygood")
            if (shorter.length >= 4 && longer.includes(shorter)) return 0.82;
            
            // Check word-by-word matches
            let matchedWords = 0;
            let totalWords = Math.max(words1.length, words2.length);
            
            for (let w1 of words1) {
                for (let w2 of words2) {
                    const cleanW1 = w1.replace(/[^a-z0-9]/g, '');
                    const cleanW2 = w2.replace(/[^a-z0-9]/g, '');
                    
                    if (cleanW1 === cleanW2 && cleanW1.length > 0) {
                        matchedWords++;
                        break;
                    }
                    
                    // Partial word match for longer words
                    if (cleanW1.length >= 4 && cleanW2.length >= 4) {
                        if (cleanW1.includes(cleanW2) || cleanW2.includes(cleanW1)) {
                            matchedWords += 0.7;
                            break;
                        }
                        
                        // Check if one word starts with the other
                        if (cleanW1.startsWith(cleanW2) || cleanW2.startsWith(cleanW1)) {
                            matchedWords += 0.6;
                            break;
                        }
                    }
                }
            }
            
            if (matchedWords > 0) {
                return Math.min(0.75, 0.4 + (matchedWords / totalWords) * 0.5);
            }
            
            // Check for character overlap (for typos)
            let commonChars = 0;
            const chars1 = n1.split('');
            const chars2 = n2.split('');
            
            for (let char of chars1) {
                if (chars2.includes(char)) {
                    commonChars++;
                }
            }
            
            const overlapRatio = commonChars / Math.max(n1.length, n2.length);
            if (overlapRatio > 0.6) return 0.5;
            
            return 0.0;
        }
        
        // Find best matches for a found name
        function findBestMatches(foundName, officialCandidates) {
            const matches: Array<{candidate: string, score: number}> = [];
            
            // Check learned correlations first
            // Extract base name (remove numbers and special chars at start/end)
            const baseName = foundName.toLowerCase().replace(/^[\d\.\s]+/, '').replace(/[\d\s]+$/, '');
            
            // Check if we've learned any correlations for similar names
            let learnedCandidate: string | null = null;
            let highestLearnedScore = 0;
            
            for (let [learnedName, candidate] of parsedData.learnedCorrelations) {
                // Check if the learned name is similar to this found name
                const learnedBase = learnedName.toLowerCase().replace(/^[\d\.\s]+/, '').replace(/[\d\s]+$/, '');
                
                // If learned name matches or is contained in found name
                if (baseName.includes(learnedBase) || learnedBase.includes(baseName)) {
                    const similarity = Math.min(baseName.length, learnedBase.length) / Math.max(baseName.length, learnedBase.length);
                    if (similarity > highestLearnedScore) {
                        highestLearnedScore = similarity;
                        learnedCandidate = candidate;
                    }
                }
            }
            
            // If we learned this name is "not a candidate" (null) or "not a ballot" with high confidence, set it directly
            if ((learnedCandidate === null || learnedCandidate === '__NOT_A_BALLOT__') && highestLearnedScore > 0.5) {
                parsedData.nameMatches.set(foundName, learnedCandidate as null | '__NOT_A_BALLOT__');
            }
            
            for (let candidate of officialCandidates) {
                let score = fuzzyMatch(foundName, candidate);
                
                // Boost score significantly if this matches our learned correlation
                if (learnedCandidate === candidate && highestLearnedScore > 0.5) {
                    score = Math.max(score, 0.95); // Give it a very high score
                }
                
                // Lower threshold to catch more potential matches
                if (score > 0.45) {
                    matches.push({ candidate, score });
                }
            }
            
            matches.sort((a, b) => b.score - a.score);
            // Return top 5 matches to avoid overwhelming the user
            return matches.slice(0, 5);
        }
        
        // ===== UI EVENT HANDLERS =====
        
        // Mode switching
        document.querySelectorAll('input[name="input-mode"]').forEach(radio => {
            radio.addEventListener('change', function(this: HTMLInputElement) {
                const simpleMode = document.getElementById('simple-mode');
                const discordMode = document.getElementById('discord-mode');
                const nameMatching = document.getElementById('name-matching');
                const results = document.getElementById('results');
                
                // Update the inputMode variable
                inputMode = this.value as 'simple' | 'discord';
                
                // Save mode preference to localStorage
                localStorage.setItem('input-mode', this.value);
                
                if (this.value === 'simple') {
                    if (simpleMode) simpleMode.style.display = 'block';
                    if (discordMode) discordMode.style.display = 'none';
                    if (nameMatching) nameMatching.style.display = 'none';
                    if (results) results.style.display = 'none';
                } else {
                    if (simpleMode) simpleMode.style.display = 'none';
                    if (discordMode) discordMode.style.display = 'block';
                    if (nameMatching) nameMatching.style.display = 'none';
                    if (results) results.style.display = 'none';
                }
            });
        });
        
        // Load saved discord data on page load
        window.addEventListener('DOMContentLoaded', function() {
            // Restore input mode preference
            const savedMode = localStorage.getItem('input-mode');
            if (savedMode) {
                const radioToCheck = document.querySelector(`input[name="input-mode"][value="${savedMode}"]`) as HTMLInputElement;
                if (radioToCheck) {
                    radioToCheck.checked = true;
                    // Trigger the change event to update UI
                    radioToCheck.dispatchEvent(new Event('change'));
                }
            }
            
            const savedCandidates = localStorage.getItem('discord-candidates');
            const savedBallots = localStorage.getItem('discord-ballots');
            
            if (savedCandidates) {
                const candidatesEl = document.getElementById('discord-candidates') as HTMLTextAreaElement;
                if (candidatesEl) candidatesEl.value = savedCandidates;
            }
            
            if (savedBallots) {
                const ballotsEl = document.getElementById('discord-ballots') as HTMLTextAreaElement;
                if (ballotsEl) ballotsEl.value = savedBallots;
            }

            const electionNameInput = document.getElementById('election-name') as HTMLInputElement;
            const savedElectionName = localStorage.getItem('election-name');
            if (electionNameInput) {
                if (savedElectionName) {
                    electionNameInput.value = savedElectionName;
                    parsedData.electionName = savedElectionName;
                }
                electionNameInput.addEventListener('input', () => {
                    parsedData.electionName = electionNameInput.value.trim();
                    localStorage.setItem('election-name', parsedData.electionName);
                });
            }
            
            // Setup Import Election button
            const importButton = document.getElementById('import-election-button');
            const importFileInput = document.getElementById('import-file-input') as HTMLInputElement;
            if (importButton && importFileInput) {
                importButton.addEventListener('click', () => {
                    importFileInput.click();
                });
                importFileInput.addEventListener('change', (e) => {
                    const file = (e.target as HTMLInputElement).files?.[0];
                    if (file) {
                        importElection(file);
                        // Reset file input so the same file can be imported again if needed
                        importFileInput.value = '';
                    }
                });
            }
            
            // Setup Export Election button
            const exportButton = document.getElementById('export-election');
            if (exportButton) {
                exportButton.addEventListener('click', exportElection);
            }
            
            // Setup Clear Session buttons (both on start page and name matching page)
            const clearButton = document.getElementById('clear-session');
            const clearButtonStart = document.getElementById('clear-session-start');
            const clearButtonReview = document.getElementById('clear-session-review');
            if (clearButton) {
                clearButton.addEventListener('click', clearSession);
            }
            if (clearButtonStart) {
                clearButtonStart.addEventListener('click', clearSession);
            }
            if (clearButtonReview) {
                clearButtonReview.addEventListener('click', clearSession);
            }
            
            // Setup Export Election button on ballot review page
            const exportButtonReview = document.getElementById('export-election-review');
            if (exportButtonReview) {
                exportButtonReview.addEventListener('click', exportElection);
            }
            
            // Back to name matching from duplicate voters
            const backToNameMatchingFromDuplicates = document.getElementById('back-to-name-matching-from-duplicates');
            if (backToNameMatchingFromDuplicates) {
                backToNameMatchingFromDuplicates.addEventListener('click', function() {
                    const duplicateVoters = document.getElementById('duplicate-voters');
                    const nameMatching = document.getElementById('name-matching');
                    if (duplicateVoters) duplicateVoters.style.display = 'none';
                    if (nameMatching) nameMatching.style.display = 'block';
                    // Reset to first name so user can review again
                    parsedData.currentNameIndex = 0;
                    renderCurrentName();
                });
            }
            
            // Proceed to ballot review from duplicate voters
            const proceedToBallotReviewBtn = document.getElementById('proceed-to-ballot-review');
            if (proceedToBallotReviewBtn) {
                proceedToBallotReviewBtn.addEventListener('click', proceedToBallotReview);
            }
            
            // Back to name matching from ballot review
            const backToNameMatching = document.getElementById('back-to-name-matching');
            if (backToNameMatching) {
                backToNameMatching.addEventListener('click', function() {
                    const ballotReview = document.getElementById('ballot-review');
                    const nameMatching = document.getElementById('name-matching');
                    if (ballotReview) ballotReview.style.display = 'none';
                    if (nameMatching) nameMatching.style.display = 'block';
                    // Reset to first name so user can review again
                    parsedData.currentNameIndex = 0;
                    renderCurrentName();
                });
            }
            
            // Calculate from ballot review
            const calculateFromReview = document.getElementById('calculate-from-review');
            if (calculateFromReview) {
                calculateFromReview.addEventListener('click', calculateResults);
            }
        });
        
        // Save discord data to localStorage on input
        document.getElementById('discord-candidates')?.addEventListener('input', function(this: HTMLTextAreaElement) {
            localStorage.setItem('discord-candidates', this.value);
        });
        
        document.getElementById('discord-ballots')?.addEventListener('input', function(this: HTMLTextAreaElement) {
            localStorage.setItem('discord-ballots', this.value);
        });
        
        // Parse Discord data
        document.getElementById('parse-discord')?.addEventListener('click', function() {
            const candidatesEl = document.getElementById('discord-candidates') as HTMLTextAreaElement;
            const ballotsEl = document.getElementById('discord-ballots') as HTMLTextAreaElement;
            const seatsEl = document.getElementById('discord-seats') as HTMLInputElement;
            
            if (!candidatesEl || !ballotsEl || !seatsEl) return;
            
            const candidatesText = candidatesEl.value;
            const ballotsText = ballotsEl.value;
            const seats = parseInt(seatsEl.value);
            
            if (!candidatesText.trim()) {
                alert('Please enter the official candidate list');
                return;
            }
            
            if (!ballotsText.trim()) {
                alert('Please paste the Discord ballot data');
                return;
            }
            
            // Parse official candidates
            const officialCandidates = parseOfficialCandidates(candidatesText);
            
            if (officialCandidates.length === 0) {
                alert('No valid candidates found');
                return;
            }
            
            // Parse ballots
            const { ballots, allFoundNames, originalBallotText } = parseDiscordBallots(ballotsText, officialCandidates);
            
            if (ballots.length === 0) {
                alert('No valid ballots found');
                return;
            }
            
            // Store parsed data
            // When re-parsing (e.g., after "Return to Start"), we keep learned correlations
            // and manual edits, but clear parse-specific state that needs to be rebuilt
            parsedData.candidates = officialCandidates;
            parsedData.ballots = ballots;
            parsedData.seats = seats;
            parsedData.nameMatches = new Map(); // Clear - will be rebuilt using learned correlations
            parsedData.currentNameIndex = 0; // Reset to start of review
            parsedData.originalBallotText = originalBallotText;
            // NOTE: ballotOverrides is RETAINED - these are user's manual ballot edits
            parsedData.reviewedNames = new Set(); // Clear - names to review will be different
            // NOTE: learnedCorrelations is RETAINED - these are patterns that remain valid across sessions
            parsedData.correlationInfluences = new Map(); // Clear - will be rebuilt during review
            parsedData.hasCorrelationWarning = false; // Reset warning flag
            // NOTE: duplicateSelections is RETAINED - user's choice of which duplicate ballot to keep
            
            // Count occurrences of each name
            const nameCounts = new Map();
            for (let ballot of ballots) {
                for (let name of ballot.rankings) {
                    nameCounts.set(name, (nameCounts.get(name) || 0) + 1);
                }
            }
            
            // Store counts for later use
            parsedData.nameCounts = nameCounts;
            
            // Sort names by frequency (most frequent first)
            parsedData.uniqueNames = allFoundNames.sort((a, b) => {
                const countA = nameCounts.get(a) || 0;
                const countB = nameCounts.get(b) || 0;
                return countB - countA;
            });
            
            // Build initial view
            renderCurrentName();
            
            // Update correlation table to show any existing learned correlations
            updateCorrelationTable();
            
            // Show matching interface
            const discordModeEl = document.getElementById('discord-mode');
            const nameMatchingEl = document.getElementById('name-matching');
            const importSection = document.getElementById('import-section');
            if (discordModeEl) discordModeEl.style.display = 'none';
            if (nameMatchingEl) nameMatchingEl.style.display = 'block';
            if (importSection) importSection.style.display = 'none';
        });
        
        // Render the current name being reviewed
        function renderCurrentName() {
            const nameMatchList = document.getElementById('name-match-list');
            if (!nameMatchList) return;
            nameMatchList.innerHTML = '';
            
            if (parsedData.currentNameIndex >= parsedData.uniqueNames.length) {
                // All names reviewed, show confirmation
                showConfirmation();
                return;
            }
            
            const foundName = parsedData.uniqueNames[parsedData.currentNameIndex];
            const matches = findBestMatches(foundName, parsedData.candidates);
            const count = parsedData.nameCounts.get(foundName) || 0;
            
            // Check if current selection was influenced by a correlation that might have changed
            const baseName = foundName.toLowerCase().replace(/^[\d\.\s]+/, '').replace(/[\d\s]+$/, '');
            const wasInfluenced = Array.from(parsedData.correlationInfluences.values()).some((set: Set<string>) => set.has(foundName));
            
            // Progress indicator
            const progressDiv = document.createElement('div');
            progressDiv.className = 'match-progress';
            progressDiv.textContent = `Reviewing name ${parsedData.currentNameIndex + 1} of ${parsedData.uniqueNames.length}`;
            
            // Add inline warning if a correlation was changed
            if (parsedData.hasCorrelationWarning && wasInfluenced) {
                const warningSpan = document.createElement('span');
                warningSpan.className = 'correlation-warning';
                warningSpan.innerHTML = `<span class="correlation-warning-text">Affected by earlier change</span>`;
                warningSpan.style.marginLeft = '10px';
                progressDiv.appendChild(document.createTextNode(' '));
                progressDiv.appendChild(warningSpan);
            }
            
            nameMatchList.appendChild(progressDiv);
            
            // Keyboard shortcuts help
            const helpDiv = document.createElement('div');
            helpDiv.className = 'govuk-inset-text';
            helpDiv.style.marginTop = '10px';
            helpDiv.style.fontSize = '0.85em';
            helpDiv.innerHTML = `
                <strong>Keyboard shortcuts:</strong>
                <span style="display: block; margin-top: 5px;">
                    <kbd style="background: #f3f2f1; padding: 2px 6px; border: 1px solid #b1b4b6; border-radius: 3px; font-family: monospace;">←</kbd><kbd style="background: #f3f2f1; padding: 2px 6px; border: 1px solid #b1b4b6; border-radius: 3px; font-family: monospace;">→</kbd> or <kbd style="background: #f3f2f1; padding: 2px 6px; border: 1px solid #b1b4b6; border-radius: 3px; font-family: monospace;">Enter</kbd><kbd style="background: #f3f2f1; padding: 2px 6px; border: 1px solid #b1b4b6; border-radius: 3px; font-family: monospace;">Shift+Enter</kbd> Navigate • 
                    <kbd style="background: #f3f2f1; padding: 2px 6px; border: 1px solid #b1b4b6; border-radius: 3px; font-family: monospace;">1</kbd>-<kbd style="background: #f3f2f1; padding: 2px 6px; border: 1px solid #b1b4b6; border-radius: 3px; font-family: monospace;">9</kbd> Quick select • 
                    <kbd style="background: #f3f2f1; padding: 2px 6px; border: 1px solid #b1b4b6; border-radius: 3px; font-family: monospace;">N</kbd> Not candidate • 
                    <kbd style="background: #f3f2f1; padding: 2px 6px; border: 1px solid #b1b4b6; border-radius: 3px; font-family: monospace;">M</kbd> Not ballot entry • 
                    <kbd style="background: #f3f2f1; padding: 2px 6px; border: 1px solid #b1b4b6; border-radius: 3px; font-family: monospace;">W</kbd> Dropdown
                </span>
            `;
            nameMatchList.appendChild(helpDiv);
            
            const itemDiv = document.createElement('div');
            itemDiv.className = 'name-match-item';
            
            const headerDiv = document.createElement('div');
            headerDiv.className = 'name-match-header';
            headerDiv.innerHTML = `
                <span class="found-name">${foundName}</span>
                <span class="match-count">Found in ${count} ballot${count !== 1 ? 's' : ''}</span>
            `;
            
            const optionsDiv = document.createElement('div');
            optionsDiv.className = 'match-options';
            
            // Check if this name has been reviewed before
            const hasBeenReviewed = parsedData.reviewedNames.has(foundName);
            // Check existingMatch AFTER findBestMatches, as it may have set it from learned correlations
            const existingMatch = parsedData.nameMatches.get(foundName);
            
            let autoSelected = false;
            
            // Add match options
            if (matches.length > 0) {
                for (let i = 0; i < matches.length; i++) {
                    const match = matches[i];
                    const btn = document.createElement('button');
                    btn.type = 'button';
                    btn.className = 'match-option';
                    btn.textContent = `${match.candidate} (${Math.round(match.score * 100)}% match)`;
                    btn.dataset.foundName = foundName;
                    btn.dataset.candidate = match.candidate;
                    btn.tabIndex = 0; // Make keyboard accessible
                    
                    // Auto-select logic:
                    // If already reviewed, preserve the existing selection
                    // If not reviewed, auto-select the best match (first match)
                    // BUT: Don't auto-select if findBestMatches already set a special value (null or __NOT_A_BALLOT__)
                    if (hasBeenReviewed && existingMatch === match.candidate) {
                        // Restore previous selection
                        btn.classList.add('selected');
                        btn.style.backgroundColor = '#1d70b8';
                        btn.style.color = 'white';
                        btn.style.borderColor = '#1d70b8';
                        btn.style.fontWeight = 'bold';
                        autoSelected = true;
                    } else if (!hasBeenReviewed && i === 0 && !autoSelected && existingMatch !== null && existingMatch !== '__NOT_A_BALLOT__') {
                        // First time seeing this name, auto-select best match
                        // Note: Only saves to nameMatches, not learnedCorrelations
                        // learnedCorrelations is only for explicit user confirmations
                        // Skip if learned correlation already set this to null or __NOT_A_BALLOT__
                        btn.classList.add('selected');
                        btn.style.backgroundColor = '#1d70b8';
                        btn.style.color = 'white';
                        btn.style.borderColor = '#1d70b8';
                        btn.style.fontWeight = 'bold';
                        parsedData.nameMatches.set(foundName, match.candidate);
                        autoSelected = true;
                    }
                    
                    // Handle both click and keyboard
                    const selectThisButton = function() {
                            console.log('Button selected:', btn.textContent);
                            
                            // Deselect others for this found name
                            optionsDiv.querySelectorAll<HTMLButtonElement>('.match-option').forEach(b => {
                                b.classList.remove('selected', 'invalid', 'not-ballot');
                                b.style.backgroundColor = '';
                                b.style.color = '';
                                b.style.borderColor = '';
                                b.style.fontWeight = '';
                            });
                            
                            // Select this button
                            btn.classList.add('selected');
                            // Force inline styles as backup
                            btn.style.backgroundColor = '#1d70b8';
                            btn.style.color = 'white';
                            btn.style.borderColor = '#1d70b8';
                            btn.style.fontWeight = 'bold';
                            
                            console.log('Selected class added, classes:', btn.className);
                            const selectedCandidate = btn.dataset.candidate || null;
                            
                            // Check if we're changing an existing correlation
                            const baseName = foundName.toLowerCase().replace(/^[\d\.\s]+/, '').replace(/[\d\s]+$/, '');
                            const hadPreviousCorrelation = parsedData.learnedCorrelations.has(baseName);
                            const previousCandidate = parsedData.learnedCorrelations.get(baseName);
                            
                            parsedData.nameMatches.set(foundName, selectedCandidate);
                            
                            // Store learned correlation for future matching
                            if (selectedCandidate) {
                                parsedData.learnedCorrelations.set(baseName, selectedCandidate);
                                
                                // Track which names were influenced by this correlation
                                if (!parsedData.correlationInfluences.has(baseName)) {
                                    parsedData.correlationInfluences.set(baseName, new Set());
                                }
                                parsedData.correlationInfluences.get(baseName)?.add(foundName);
                                
                                // If we changed a correlation, set warning flag
                                if (hadPreviousCorrelation && previousCandidate !== selectedCandidate) {
                                    parsedData.hasCorrelationWarning = true;
                                    console.log(`Correlation changed: ${baseName} ${previousCandidate} -> ${selectedCandidate}`);
                                } else {
                                    console.log(`Learned correlation: ${baseName} -> ${selectedCandidate}`);
                                }
                                
                                // Update correlation table
                                updateCorrelationTable();
                            }
                        };
                        
                        btn.addEventListener('click', function(e) {
                            e.preventDefault();
                            selectThisButton();
                        });
                        
                        // Keyboard support
                        btn.addEventListener('keydown', function(e) {
                            if (e.key === 'Enter' || e.key === ' ') {
                                e.preventDefault();
                                selectThisButton();
                            }
                        });
                        
                        optionsDiv.appendChild(btn);
                    }
                }
                
                // Fallback: If name was reviewed before but the previous match no longer exists,
                // auto-select the best current match to prevent blank selection
                // BUT: Don't trigger if user explicitly selected "not a candidate" (null) or "not a ballot" (__NOT_A_BALLOT__)
                if (hasBeenReviewed && !autoSelected && matches.length > 0 && existingMatch !== null && existingMatch !== '__NOT_A_BALLOT__') {
                    const firstBtn = optionsDiv.querySelector('.match-option') as HTMLButtonElement;
                    if (firstBtn && firstBtn.dataset.candidate) {
                        firstBtn.classList.add('selected');
                        firstBtn.style.backgroundColor = '#1d70b8';
                        firstBtn.style.color = 'white';
                        firstBtn.style.borderColor = '#1d70b8';
                        firstBtn.style.fontWeight = 'bold';
                        parsedData.nameMatches.set(foundName, firstBtn.dataset.candidate);
                        autoSelected = true;
                    }
                }
                
                // Add "Invalid/Not a candidate" option
                const invalidBtn = document.createElement('button');
                invalidBtn.type = 'button';
                invalidBtn.className = 'match-option';
                invalidBtn.textContent = 'Not a candidate (skip)';
                invalidBtn.dataset.foundName = foundName;
                invalidBtn.tabIndex = 0; // Make keyboard accessible
                
                // Auto-select invalid if existingMatch is null (either from review or learned correlation)
                if (existingMatch === null) {
                    invalidBtn.classList.add('invalid');
                    invalidBtn.style.backgroundColor = '#d4351c';
                    invalidBtn.style.color = 'white';
                    invalidBtn.style.borderColor = '#d4351c';
                    invalidBtn.style.fontWeight = 'bold';
                } else if (!autoSelected && !hasBeenReviewed && existingMatch === undefined) {
                    // Only auto-select "not a candidate" if no match was found AND nothing was set by learned correlations
                    invalidBtn.classList.add('invalid');
                    invalidBtn.style.backgroundColor = '#d4351c';
                    invalidBtn.style.color = 'white';
                    invalidBtn.style.borderColor = '#d4351c';
                    invalidBtn.style.fontWeight = 'bold';
                    parsedData.nameMatches.set(foundName, null);
                }
                
                const selectInvalidButton = function() {
                    console.log('Invalid button selected');
                    
                    optionsDiv.querySelectorAll<HTMLButtonElement>('.match-option').forEach(b => {
                        b.classList.remove('selected', 'invalid', 'not-ballot');
                        b.style.backgroundColor = '';
                        b.style.color = '';
                        b.style.borderColor = '';
                        b.style.fontWeight = '';
                    });
                    
                    invalidBtn.classList.add('invalid');
                    invalidBtn.style.backgroundColor = '#d4351c';
                    invalidBtn.style.color = 'white';
                    invalidBtn.style.borderColor = '#d4351c';
                    invalidBtn.style.fontWeight = 'bold';
                    
                    parsedData.nameMatches.set(foundName, null);
                    
                    // Store learned correlation as null (not a candidate)
                    const baseName = foundName.toLowerCase().replace(/^[\d\.\s]+/, '').replace(/[\d\s]+$/, '');
                    parsedData.learnedCorrelations.set(baseName, null);
                    console.log(`Learned correlation: ${baseName} -> not a candidate`);
                    updateCorrelationTable();
                };
                
                invalidBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    selectInvalidButton();
                });
                
                invalidBtn.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        selectInvalidButton();
                    }
                });
                
                optionsDiv.appendChild(invalidBtn);
                
                // Add "Not a ballot entry" option (for voter names caught as ballots, etc.)
                const notBallotBtn = document.createElement('button');
                notBallotBtn.type = 'button';
                notBallotBtn.className = 'match-option';
                notBallotBtn.textContent = 'Not a ballot entry (remove)';
                notBallotBtn.dataset.foundName = foundName;
                notBallotBtn.tabIndex = 0;
                
                // If marked as not a ballot (either from review OR from learned correlation), restore that selection
                if (existingMatch === '__NOT_A_BALLOT__') {
                    notBallotBtn.classList.add('not-ballot');
                    notBallotBtn.style.backgroundColor = '#505a5f';
                    notBallotBtn.style.color = 'white';
                    notBallotBtn.style.borderColor = '#505a5f';
                    notBallotBtn.style.fontWeight = 'bold';
                }
                
                const selectNotBallotButton = function() {
                    console.log('Not a ballot button selected');
                    
                    optionsDiv.querySelectorAll<HTMLButtonElement>('.match-option').forEach(b => {
                        b.classList.remove('selected', 'invalid', 'not-ballot');
                        b.style.backgroundColor = '';
                        b.style.color = '';
                        b.style.borderColor = '';
                        b.style.fontWeight = '';
                    });
                    
                    notBallotBtn.classList.add('not-ballot');
                    notBallotBtn.style.backgroundColor = '#505a5f';
                    notBallotBtn.style.color = 'white';
                    notBallotBtn.style.borderColor = '#505a5f';
                    notBallotBtn.style.fontWeight = 'bold';
                    
                    parsedData.nameMatches.set(foundName, '__NOT_A_BALLOT__');
                    
                    // Store learned correlation as __NOT_A_BALLOT__
                    const baseName = foundName.toLowerCase().replace(/^[\d\.\s]+/, '').replace(/[\d\s]+$/, '');
                    parsedData.learnedCorrelations.set(baseName, '__NOT_A_BALLOT__');
                    console.log(`Learned correlation: ${baseName} -> not a ballot entry`);
                    updateCorrelationTable();
                };
                
                notBallotBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    selectNotBallotButton();
                });
                
                notBallotBtn.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        selectNotBallotButton();
                    }
                });
                
                optionsDiv.appendChild(notBallotBtn);
                
                // Add manual dropdown selection
                const manualWrapper = document.createElement('div');
                manualWrapper.className = 'manual-select-wrapper';
                
                const dropdownLabel = document.createElement('label');
                dropdownLabel.textContent = 'Or select manually:';
                
                const dropdown = document.createElement('select');
                dropdown.className = 'icenia-select';
                dropdown.style.width = '100%';
                
                // Add default option
                const defaultOption = document.createElement('option');
                defaultOption.value = '';
                defaultOption.textContent = '-- Select a candidate --';
                dropdown.appendChild(defaultOption);
                
                // Add all official candidates to dropdown
                for (let candidate of parsedData.candidates) {
                    const option = document.createElement('option');
                    option.value = candidate;
                    option.textContent = candidate;
                    dropdown.appendChild(option);
                }
                
                // Add "Not a candidate" option to dropdown
                const noneOption = document.createElement('option');
                noneOption.value = '__INVALID__';
                noneOption.textContent = 'Not a candidate - skip ranking';
                dropdown.appendChild(noneOption);
                
                // Add "Not a ballot entry" option to dropdown
                const notBallotOption = document.createElement('option');
                notBallotOption.value = '__NOT_A_BALLOT__';
                notBallotOption.textContent = 'Not a ballot entry - remove';
                dropdown.appendChild(notBallotOption);
                
                const selectFromDropdown = function() {
                    if (dropdown.value) {
                        console.log('Dropdown changed to:', dropdown.value);
                        
                        // Deselect all buttons
                        optionsDiv.querySelectorAll<HTMLButtonElement>('.match-option').forEach(b => {
                            b.classList.remove('selected', 'invalid', 'not-ballot');
                            b.style.backgroundColor = '';
                            b.style.color = '';
                            b.style.borderColor = '';
                            b.style.fontWeight = '';
                        });
                        
                        const baseName = foundName.toLowerCase().replace(/^[\d\.\s]+/, '').replace(/[\d\s]+$/, '');
                        
                        if (dropdown.value === '__INVALID__') {
                            parsedData.nameMatches.set(foundName, null);
                            // Store learned correlation as null (not a candidate)
                            parsedData.learnedCorrelations.set(baseName, null);
                            console.log(`Learned correlation: ${baseName} -> not a candidate`);
                            updateCorrelationTable();
                            // Visually indicate the invalid button
                            invalidBtn.classList.add('invalid');
                            invalidBtn.style.backgroundColor = '#d4351c';
                            invalidBtn.style.color = 'white';
                            invalidBtn.style.borderColor = '#d4351c';
                            invalidBtn.style.fontWeight = 'bold';
                        } else if (dropdown.value === '__NOT_A_BALLOT__') {
                            parsedData.nameMatches.set(foundName, '__NOT_A_BALLOT__');
                            // Store learned correlation as __NOT_A_BALLOT__
                            parsedData.learnedCorrelations.set(baseName, '__NOT_A_BALLOT__');
                            console.log(`Learned correlation: ${baseName} -> not a ballot entry`);
                            updateCorrelationTable();
                            // Visually indicate the not ballot button
                            notBallotBtn.classList.add('not-ballot');
                            notBallotBtn.style.backgroundColor = '#505a5f';
                            notBallotBtn.style.color = 'white';
                            notBallotBtn.style.borderColor = '#505a5f';
                            notBallotBtn.style.fontWeight = 'bold';
                        } else {
                            parsedData.nameMatches.set(foundName, dropdown.value);
                            
                            // Store learned correlation for future matching
                            parsedData.learnedCorrelations.set(baseName, dropdown.value);
                            console.log(`Learned correlation: ${baseName} -> ${dropdown.value}`);
                            
                            // Update correlation table
                            updateCorrelationTable();
                            
                            // Find and highlight the matching button if it exists
                            optionsDiv.querySelectorAll<HTMLButtonElement>('.match-option').forEach(b => {
                                if (b.dataset.candidate === dropdown.value) {
                                    b.classList.add('selected');
                                    b.style.backgroundColor = '#1d70b8';
                                    b.style.color = 'white';
                                    b.style.borderColor = '#1d70b8';
                                    b.style.fontWeight = 'bold';
                                }
                            });
                        }
                    }
                };
                
                dropdown.addEventListener('change', selectFromDropdown);
                
                // Keyboard support: Enter key on dropdown commits selection and moves to next
                dropdown.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter' && dropdown.value) {
                        e.preventDefault();
                        selectFromDropdown();
                        // Auto-advance to next name
                        parsedData.currentNameIndex++;
                        renderCurrentName();
                    }
                });
                
                // Store reference to dropdown for global keyboard handler
                itemDiv.dataset.dropdown = 'true';
                (itemDiv as any).__dropdown = dropdown;
                
                manualWrapper.appendChild(dropdownLabel);
                manualWrapper.appendChild(dropdown);
                
                itemDiv.appendChild(headerDiv);
                itemDiv.appendChild(optionsDiv);
                itemDiv.appendChild(manualWrapper);
                
                // Navigation buttons
                const navDiv = document.createElement('div');
                navDiv.className = 'match-navigation icenia-button-group';
                
                const prevBtn = document.createElement('button');
                prevBtn.type = 'button';
                prevBtn.className = 'icenia-btn icenia-btn-secondary';
                prevBtn.textContent = '← Previous';
                prevBtn.disabled = parsedData.currentNameIndex === 0;
                
                const navigatePrevious = function() {
                    if (parsedData.currentNameIndex > 0) {
                        // Mark current name as reviewed before navigating
                        const currentName = parsedData.uniqueNames[parsedData.currentNameIndex];
                        parsedData.reviewedNames.add(currentName);
                        
                        parsedData.currentNameIndex--;
                        renderCurrentName();
                    }
                };
                
                prevBtn.addEventListener('click', navigatePrevious);
                prevBtn.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        navigatePrevious();
                    }
                });
                
                const nextBtn = document.createElement('button');
                nextBtn.type = 'button';
                nextBtn.className = 'icenia-btn';
                nextBtn.textContent = parsedData.currentNameIndex === parsedData.uniqueNames.length - 1 ? 'Review Ballots →' : 'Next →';
                
                const navigateNext = function() {
                    // Mark current name as reviewed before navigating
                    const currentName = parsedData.uniqueNames[parsedData.currentNameIndex];
                    parsedData.reviewedNames.add(currentName);
                    
                    parsedData.currentNameIndex++;
                    renderCurrentName();
                };
                
                nextBtn.addEventListener('click', navigateNext);
                nextBtn.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        navigateNext();
                    }
                });
                
                navDiv.appendChild(prevBtn);
                navDiv.appendChild(nextBtn);
                itemDiv.appendChild(navDiv);
                
                nameMatchList.appendChild(itemDiv);
        }
        
        // Update the correlation table display
        function updateCorrelationTable() {
            const tableBody = document.getElementById('correlation-table-body');
            const tableSection = document.getElementById('correlation-table-section');
            const correlationCount = document.getElementById('correlation-count');
            
            if (!tableBody || !tableSection || !correlationCount) return;
            
            const count = parsedData.learnedCorrelations.size;
            correlationCount.textContent = count.toString();
            
            if (count === 0) {
                tableSection.style.display = 'none';
                return;
            }
            
            tableSection.style.display = 'block';
            
            // Sort correlations alphabetically by voter name pattern
            const sortedCorrelations = Array.from(parsedData.learnedCorrelations.entries())
                .sort((a, b) => a[0].localeCompare(b[0]));
            
            tableBody.innerHTML = sortedCorrelations.map(([pattern, candidate]) => {
                let displayValue: string;
                if (candidate === null) {
                    displayValue = '<em style="color: #d4351c;">(Not a candidate)</em>';
                } else if (candidate === '__NOT_A_BALLOT__') {
                    displayValue = '<em style="color: #505a5f;">(Not a ballot entry)</em>';
                } else {
                    displayValue = escapeHtml(candidate);
                }
                return `
                    <tr class="govuk-table__row">
                        <td class="govuk-table__cell">${escapeHtml(pattern)}</td>
                        <td class="govuk-table__cell">${displayValue}</td>
                    </tr>
                `;
            }).join('');
        }
        
        // Escape HTML to prevent XSS
        function escapeHtml(text: string): string {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Track current ballot being reviewed
        let currentBallotIndex = 0;
        
        // ===== STRUCTURED BALLOT EDITING FUNCTIONS =====
        
        // Get structured ballot for a voter (uses override if exists, otherwise builds from mappings)
        function getStructuredBallot(voterName: string): {rank: number, candidate: string}[] {
            // Check if there's a manual override first
            const override = parsedData.ballotOverrides.get(voterName);
            if (override) {
                return [...override]; // Return copy to avoid mutation
            }
            
            // Otherwise, build from automated mappings
            const ballot = parsedData.ballots.find(b => b.voter === voterName);
            if (!ballot) return [];
            
            const result: {rank: number, candidate: string}[] = [];
            const addedCandidates = new Set<string>();
            let rank = 1;
            
            for (let name of ballot.rankings) {
                const match = parsedData.nameMatches.get(name);
                if (match && match !== '__NOT_A_BALLOT__' && match !== null && !addedCandidates.has(match)) {
                    result.push({ rank: rank++, candidate: match });
                    addedCandidates.add(match);
                }
            }
            
            return result;
        }
        
        // Update structured ballot (saves override)
        function updateStructuredBallot(voterName: string, rankings: {rank: number, candidate: string}[]) {
            parsedData.ballotOverrides.set(voterName, rankings);
            renderBallotReview(); // Re-render to show changes
        }
        
        // Remove a ranking from a ballot
        function removeRanking(voterName: string, rankIndex: number) {
            const current = getStructuredBallot(voterName);
            current.splice(rankIndex, 1);
            // Re-number ranks
            current.forEach((r, i) => r.rank = i + 1);
            updateStructuredBallot(voterName, current);
            renderBallotReview(); // Re-render to show removal
        }
        
        // Add a ranking to a ballot
        function addRanking(voterName: string, candidate: string) {
            const current = getStructuredBallot(voterName);
            current.push({ rank: current.length + 1, candidate });
            updateStructuredBallot(voterName, current);
            renderBallotReview(); // Re-render to show new ranking
        }
        
        // Move a ranking (reorder)
        function moveRanking(voterName: string, fromIndex: number, toIndex: number) {
            const current = getStructuredBallot(voterName);
            const [moved] = current.splice(fromIndex, 1);
            current.splice(toIndex, 0, moved);
            // Re-number ranks
            current.forEach((r, i) => r.rank = i + 1);
            updateStructuredBallot(voterName, current);
            renderBallotReview(); // Re-render to show updated order
        }
        
        // Change candidate for a specific rank
        function changeRankingCandidate(voterName: string, rankIndex: number, newCandidate: string) {
            const current = getStructuredBallot(voterName);
            if (rankIndex >= 0 && rankIndex < current.length) {
                current[rankIndex].candidate = newCandidate;
                updateStructuredBallot(voterName, current);
                renderBallotReview(); // Re-render to show updated candidate
            }
        }
        
        // Show ballot review screen (replaces old showConfirmation)
        function showConfirmation() {
            // First, detect duplicate voters by grouping ballots with same base name
            const voterToBallots = new Map<string, typeof parsedData.ballots>();
            for (let ballot of parsedData.ballots) {
                // Extract base voter name (remove #2, #3, etc suffix)
                const baseVoter = ballot.voter.replace(/#\d+$/, '');
                if (!voterToBallots.has(baseVoter)) {
                    voterToBallots.set(baseVoter, []);
                }
                voterToBallots.get(baseVoter)!.push(ballot);
            }
            
            // Find voters with multiple ballots
            const duplicateVoters = Array.from(voterToBallots.entries())
                .filter(([_, ballots]) => ballots.length > 1)
                .map(([voter, ballots]) => ({ voter, ballots }));
            
            if (duplicateVoters.length > 0) {
                // Show duplicate voter resolution UI
                showDuplicateVoterResolution(duplicateVoters);
            } else {
                // No duplicates, proceed directly to ballot review
                proceedToBallotReview();
            }
        }
        
        // Track current duplicate voter being resolved
        let currentDuplicateIndex = 0;
        let allDuplicateVoters: Array<{voter: string, ballots: typeof parsedData.ballots}> = [];
        
        // Show duplicate voter resolution UI
        function showDuplicateVoterResolution(duplicateVoters: Array<{voter: string, ballots: typeof parsedData.ballots}>) {
            const nameMatchingEl = document.getElementById('name-matching');
            const duplicateVotersEl = document.getElementById('duplicate-voters');
            const content = document.getElementById('duplicate-voters-content');
            
            if (nameMatchingEl) nameMatchingEl.style.display = 'none';
            if (duplicateVotersEl) duplicateVotersEl.style.display = 'block';
            if (!content) return;
            
            // Store duplicate voters globally for navigation
            allDuplicateVoters = duplicateVoters;
            currentDuplicateIndex = 0;
            
            // Store selections (default to null, will be set for each voter)
            if (!parsedData.duplicateSelections) {
                parsedData.duplicateSelections = new Map<string, number>(); // voter -> ballot index in original array
            }
            
            // Initialize default selections for all voters
            for (let { voter, ballots } of duplicateVoters) {
                // Sort ballots by timestamp (newest first)
                const sortedBallots = [...ballots].sort((a, b) => {
                    const timeA = parsedData.originalBallotText.get(a.voter)?.match(/—\s*(\d{1,2}\/\d{1,2}\/\d{4}\s+\d{1,2}:\d{2}\s+[ap]m)/i)?.[1];
                    const timeB = parsedData.originalBallotText.get(b.voter)?.match(/—\s*(\d{1,2}\/\d{1,2}\/\d{4}\s+\d{1,2}:\d{2}\s+[ap]m)/i)?.[1];
                    if (!timeA || !timeB) return 0;
                    return new Date(timeB).getTime() - new Date(timeA).getTime();
                });
                
                // Determine default selection: newest ballot with valid rankings
                let defaultIndex = -1;
                for (let i = 0; i < sortedBallots.length; i++) {
                    const ballot = sortedBallots[i];
                    const validRankings = ballot.rankings.filter(name => {
                        const match = parsedData.nameMatches.get(name);
                        return match && match !== '__NOT_A_BALLOT__';
                    });
                    if (validRankings.length > 0) {
                        defaultIndex = parsedData.ballots.indexOf(ballot);
                        break;
                    }
                }
                
                // If no valid ballots, default to newest anyway
                if (defaultIndex === -1 && sortedBallots.length > 0) {
                    defaultIndex = parsedData.ballots.indexOf(sortedBallots[0]);
                }
                
                // Set default selection
                parsedData.duplicateSelections.set(voter, defaultIndex);
            }
            
            // Render first duplicate voter
            renderCurrentDuplicateVoter();
        }
        
        // Render the current duplicate voter being resolved
        function renderCurrentDuplicateVoter() {
            const content = document.getElementById('duplicate-voters-content');
            if (!content) return;
            
            content.innerHTML = '';
            
            if (currentDuplicateIndex >= allDuplicateVoters.length) {
                // All resolved, proceed
                proceedToBallotReview();
                return;
            }
            
            const { voter, ballots } = allDuplicateVoters[currentDuplicateIndex];
            
            // Progress indicator
            const progress = document.createElement('div');
            progress.className = 'match-progress';
            progress.textContent = `Resolving duplicate ${currentDuplicateIndex + 1} of ${allDuplicateVoters.length}`;
            content.appendChild(progress);
            
            // Keyboard shortcuts help
            const helpDiv = document.createElement('div');
            helpDiv.className = 'govuk-inset-text';
            helpDiv.style.marginTop = '10px';
            helpDiv.style.fontSize = '0.85em';
            helpDiv.innerHTML = `
                <strong>Keyboard shortcuts:</strong>
                <span style="display: block; margin-top: 5px;">
                    <kbd style="background: #f3f2f1; padding: 2px 6px; border: 1px solid #b1b4b6; border-radius: 3px; font-family: monospace;">↑</kbd><kbd style="background: #f3f2f1; padding: 2px 6px; border: 1px solid #b1b4b6; border-radius: 3px; font-family: monospace;">↓</kbd> Select ballot • 
                    <kbd style="background: #f3f2f1; padding: 2px 6px; border: 1px solid #b1b4b6; border-radius: 3px; font-family: monospace;">Enter</kbd> Confirm & next • 
                    <kbd style="background: #f3f2f1; padding: 2px 6px; border: 1px solid #b1b4b6; border-radius: 3px; font-family: monospace;">Shift+Enter</kbd> Go back • 
                    <kbd style="background: #f3f2f1; padding: 2px 6px; border: 1px solid #b1b4b6; border-radius: 3px; font-family: monospace;">←</kbd><kbd style="background: #f3f2f1; padding: 2px 6px; border: 1px solid #b1b4b6; border-radius: 3px; font-family: monospace;">→</kbd> Navigate duplicates
                </span>
            `;
            content.appendChild(helpDiv);
            
            const card = document.createElement('div');
            card.className = 'duplicate-voter-card';
            
            const header = document.createElement('h3');
            header.textContent = `Voter: ${voter} (${ballots.length} ballots found)`;
            card.appendChild(header);
            
            // Sort ballots by timestamp (newest first)
            const sortedBallots = [...ballots].sort((a, b) => {
                const timeA = parsedData.originalBallotText.get(a.voter)?.match(/—\s*(\d{1,2}\/\d{1,2}\/\d{4}\s+\d{1,2}:\d{2}\s+[ap]m)/i)?.[1];
                const timeB = parsedData.originalBallotText.get(b.voter)?.match(/—\s*(\d{1,2}\/\d{1,2}\/\d{4}\s+\d{1,2}:\d{2}\s+[ap]m)/i)?.[1];
                if (!timeA || !timeB) return 0;
                return new Date(timeB).getTime() - new Date(timeA).getTime();
            });
            
            const currentSelection = parsedData.duplicateSelections.get(voter);
            
            // Render each ballot option
            for (let ballot of sortedBallots) {
                const ballotIndex = parsedData.ballots.indexOf(ballot);
                const option = document.createElement('div');
                option.className = 'duplicate-ballot-option';
                option.dataset.ballotIndex = ballotIndex.toString();
                if (ballotIndex === currentSelection) {
                    option.classList.add('selected');
                }
                
                const optionHeader = document.createElement('div');
                optionHeader.className = 'duplicate-ballot-header';
                
                // Extract timestamp from original text
                const originalText = parsedData.originalBallotText.get(ballot.voter) || '';
                const timestampMatch = originalText.match(/—\s*(\d{1,2}\/\d{1,2}\/\d{4}\s+\d{1,2}:\d{2}\s+[ap]m)/i);
                const timestamp = timestampMatch ? timestampMatch[1] : 'Unknown time';
                
                optionHeader.innerHTML = `
                    <span>Ballot ${parsedData.ballots.indexOf(ballot) + 1}</span>
                    <span class="duplicate-ballot-timestamp">${escapeHtml(timestamp)}</span>
                `;
                option.appendChild(optionHeader);
                
                // Show rankings
                const rankingsDiv = document.createElement('div');
                rankingsDiv.className = 'duplicate-ballot-rankings';
                
                if (ballot.rankings.length === 0) {
                    rankingsDiv.innerHTML = '<div style="color: #999; font-style: italic;">No rankings found</div>';
                } else {
                    for (let i = 0; i < ballot.rankings.length; i++) {
                        const name = ballot.rankings[i];
                        const match = parsedData.nameMatches.get(name);
                        const rankDiv = document.createElement('div');
                        
                        if (match && match !== '__NOT_A_BALLOT__') {
                            rankDiv.textContent = `${i + 1}. ${name} → ${match}`;
                            rankDiv.style.color = '#50fa7b';
                        } else if (match === '__NOT_A_BALLOT__') {
                            rankDiv.textContent = `${i + 1}. ${name} → (removed)`;
                            rankDiv.style.color = '#999';
                        } else {
                            rankDiv.textContent = `${i + 1}. ${name} → (invalid)`;
                            rankDiv.style.color = '#ff5555';
                        }
                        
                        rankingsDiv.appendChild(rankDiv);
                    }
                }
                option.appendChild(rankingsDiv);
                
                // Count valid rankings
                const validRankings = ballot.rankings.filter(name => {
                    const match = parsedData.nameMatches.get(name);
                    return match && match !== '__NOT_A_BALLOT__';
                });
                
                if (validRankings.length === 0) {
                    const warning = document.createElement('div');
                    warning.className = 'duplicate-ballot-warning';
                    warning.textContent = '⚠ This ballot has no valid rankings';
                    option.appendChild(warning);
                }
                
                // Click to select
                option.addEventListener('click', () => {
                    selectDuplicateBallot(ballotIndex);
                });
                
                card.appendChild(option);
            }
            
            content.appendChild(card);
            
            // Navigation buttons
            const navDiv = document.createElement('div');
            navDiv.className = 'ballot-nav-buttons icenia-button-group';
            navDiv.style.marginTop = '20px';
            
            const prevBtn = document.createElement('button');
            prevBtn.type = 'button';
            prevBtn.className = 'icenia-btn icenia-btn-secondary';
            prevBtn.textContent = '← Previous Duplicate';
            prevBtn.disabled = currentDuplicateIndex === 0;
            prevBtn.addEventListener('click', () => {
                if (currentDuplicateIndex > 0) {
                    currentDuplicateIndex--;
                    renderCurrentDuplicateVoter();
                }
            });
            
            const nextBtn = document.createElement('button');
            nextBtn.type = 'button';
            nextBtn.className = 'icenia-btn';
            nextBtn.textContent = currentDuplicateIndex === allDuplicateVoters.length - 1 ? 'Proceed to Review →' : 'Next Duplicate →';
            nextBtn.addEventListener('click', () => {
                if (currentDuplicateIndex < allDuplicateVoters.length - 1) {
                    currentDuplicateIndex++;
                    renderCurrentDuplicateVoter();
                } else {
                    // Last one, proceed to ballot review
                    proceedToBallotReview();
                }
            });
            
            navDiv.appendChild(prevBtn);
            navDiv.appendChild(nextBtn);
            content.appendChild(navDiv);
        }
        
        // Select a ballot for the current duplicate voter
        function selectDuplicateBallot(ballotIndex: number) {
            const { voter } = allDuplicateVoters[currentDuplicateIndex];
            parsedData.duplicateSelections.set(voter, ballotIndex);
            
            // Update UI
            const content = document.getElementById('duplicate-voters-content');
            if (!content) return;
            
            content.querySelectorAll('.duplicate-ballot-option').forEach(opt => {
                const element = opt as HTMLElement;
                element.classList.remove('selected');
                if (element.dataset.ballotIndex === ballotIndex.toString()) {
                    element.classList.add('selected');
                }
            });
        }
        
        // Navigate to next/previous ballot option within current duplicate
        function navigateDuplicateBallotOption(direction: 'up' | 'down') {
            const content = document.getElementById('duplicate-voters-content');
            if (!content) return;
            
            const options = Array.from(content.querySelectorAll('.duplicate-ballot-option'));
            const selectedIndex = options.findIndex(opt => opt.classList.contains('selected'));
            
            if (direction === 'up' && selectedIndex > 0) {
                const newOption = options[selectedIndex - 1] as HTMLElement;
                selectDuplicateBallot(parseInt(newOption.dataset.ballotIndex || '0'));
            } else if (direction === 'down' && selectedIndex < options.length - 1) {
                const newOption = options[selectedIndex + 1] as HTMLElement;
                selectDuplicateBallot(parseInt(newOption.dataset.ballotIndex || '0'));
            }
        }
        
        // Proceed to ballot review (after resolving duplicates or if none exist)
        function proceedToBallotReview() {
            // If we have duplicate selections, filter ballots to only include selected ones
            if (parsedData.duplicateSelections && parsedData.duplicateSelections.size > 0) {
                const originalBallots = [...parsedData.ballots];
                
                // Build set of voter IDs (with #N suffix) that should be kept
                const selectedVoterIds = new Set<string>();
                for (let [baseVoter, index] of parsedData.duplicateSelections.entries()) {
                    selectedVoterIds.add(originalBallots[index].voter);
                }
                
                // Build set of base voter names that had duplicates
                const baseVotersWithDuplicates = new Set(parsedData.duplicateSelections.keys());
                
                // Filter ballots: keep selected ones and those without duplicates
                parsedData.ballots = originalBallots.filter(b => {
                    const baseVoter = b.voter.replace(/#\d+$/, '');
                    // If this voter had duplicates, only keep if it's the selected one
                    if (baseVotersWithDuplicates.has(baseVoter)) {
                        return selectedVoterIds.has(b.voter);
                    }
                    // Otherwise keep it (no duplicates)
                    return true;
                });
                
                // Clean up voter IDs: remove #N suffix from selected ballots
                // so they appear as the base voter name
                for (let ballot of parsedData.ballots) {
                    const originalVoter = ballot.voter;
                    const baseVoter = originalVoter.replace(/#\d+$/, '');
                    if (originalVoter !== baseVoter) {
                        // Update ballot voter to base name
                        ballot.voter = baseVoter;
                        // Update originalBallotText map
                        const originalText = parsedData.originalBallotText.get(originalVoter);
                        if (originalText) {
                            parsedData.originalBallotText.set(baseVoter, originalText);
                            parsedData.originalBallotText.delete(originalVoter);
                        }
                        // Update ballotOverrides map if exists
                        const override = parsedData.ballotOverrides.get(originalVoter);
                        if (override) {
                            parsedData.ballotOverrides.set(baseVoter, override);
                            parsedData.ballotOverrides.delete(originalVoter);
                        }
                    }
                }
            }
            
            // Switch to ballot review
            const duplicateVotersEl = document.getElementById('duplicate-voters');
            const nameMatchingEl = document.getElementById('name-matching');
            const ballotReviewEl = document.getElementById('ballot-review');
            
            if (duplicateVotersEl) duplicateVotersEl.style.display = 'none';
            if (nameMatchingEl) nameMatchingEl.style.display = 'none';
            if (ballotReviewEl) ballotReviewEl.style.display = 'block';
            
            currentBallotIndex = 0;
            renderBallotReview();
        }
        
        // Render ballot review screen - REDESIGNED
        function renderBallotReview() {
            const content = document.getElementById('ballot-review-content');
            const progress = document.getElementById('ballot-review-progress');
            if (!content || !progress) return;
            
            const totalBallots = parsedData.ballots.length;
            
            // Count valid ballots (those with at least one valid ranking)
            const validBallots = parsedData.ballots.filter(b => {
                const structured = getStructuredBallot(b.voter);
                return structured.length > 0;
            }).length;
            
            // Count modified ballots
            const modifiedBallots = parsedData.ballotOverrides.size;
            
            progress.innerHTML = `
                <div class="ballot-summary">
                    <span class="ballot-summary-stat">Total Ballots: <strong>${totalBallots}</strong></span>
                    <span class="ballot-summary-stat">Valid Ballots: <strong>${validBallots}</strong></span>
                    <span class="ballot-summary-stat">Modified: <strong>${modifiedBallots}</strong></span>
                    <span class="ballot-summary-stat">Viewing: <strong>${currentBallotIndex + 1} of ${totalBallots}</strong></span>
                </div>

                <div class="govuk-inset-text" style="margin-top: 10px; font-size: 0.85em;">
                    <strong>Keyboard shortcuts:</strong>
                    <span style="display: block; margin-top: 5px;">
                        <kbd style="background: #f3f2f1; padding: 2px 6px; border: 1px solid #b1b4b6; border-radius: 3px; font-family: monospace;">←</kbd><kbd style="background: #f3f2f1; padding: 2px 6px; border: 1px solid #b1b4b6; border-radius: 3px; font-family: monospace;">→</kbd> or <kbd style="background: #f3f2f1; padding: 2px 6px; border: 1px solid #b1b4b6; border-radius: 3px; font-family: monospace;">Enter</kbd><kbd style="background: #f3f2f1; padding: 2px 6px; border: 1px solid #b1b4b6; border-radius: 3px; font-family: monospace;">Shift+Enter</kbd> Navigate between ballots
                    </span>
                </div>
            `;
            
            // Attach event listeners to the buttons

            
            content.innerHTML = '';
            
            if (totalBallots === 0) {
                content.innerHTML = '<p class="govuk-body">No ballots to review.</p>';
                return;
            }
            
            const ballot = parsedData.ballots[currentBallotIndex];
            const hasOverride = parsedData.ballotOverrides.has(ballot.voter);
            
            // Create ballot review card
            const card = document.createElement('div');
            card.className = 'ballot-review-card';
            if (hasOverride) {
                card.classList.add('ballot-modified');
            }
            
            // Header with voter name and modified indicator
            const header = document.createElement('div');
            header.className = 'ballot-review-header';
            header.innerHTML = `
                <span>Ballot from: ${escapeHtml(ballot.voter)}</span>
                ${hasOverride ? '<span class="modified-badge">✎ Modified</span>' : ''}
            `;
            card.appendChild(header);
            
            // Body with row-by-row layout for perfect alignment
            const body = document.createElement('div');
            body.className = 'ballot-review-body';
            
            // Add column headers as first row
            const headerRow = document.createElement('div');
            headerRow.className = 'ballot-row';
            headerRow.innerHTML = `
                <div style="background: #2b2b2b; color: #f8f8f2; padding: 10px 15px; font-weight: bold;">
                    Original Ballot
                </div>
                <div style="background: #1d70b8; color: white; padding: 10px 15px; font-weight: bold;">
                    Structured Ballot (Editable) - Voter: ${escapeHtml(ballot.voter)}
                </div>
            `;
            body.appendChild(headerRow);
            
            // Get original text lines
            const originalText = parsedData.originalBallotText.get(ballot.voter);
            let originalLines: string[] = [];
            if (originalText) {
                originalLines = originalText.split('\n');
            } else {
                originalLines = [ballot.voter, ...ballot.rankings];
            }
            
            const structuredBallot = getStructuredBallot(ballot.voter);
            
            // NEW APPROACH: Iterate through ORIGINAL lines for left side,
            // and ALL structured ballot rankings for right side
            
            // First, collect all original lines (including voter name)
            const originalContentLines: Array<{text: string, isTimestamp: boolean, isVoter: boolean, origName: string | null}> = [];
            for (let i = 0; i < originalLines.length; i++) {
                const line = originalLines[i];
                const trimmedLine = line.trim();
                
                if (!trimmedLine) continue;
                
                const isVoterLine = (i === 0);
                
                const isTimestampLine = /—\s*(\d{2}\/\d{2}\/\d{4}|Yesterday at|Today at)/i.test(line);
                
                // Try to match this line to an original ballot ranking
                let matchedOrigName: string | null = null;
                if (!isTimestampLine && !isVoterLine) {
                    for (let origName of ballot.rankings) {
                        if (trimmedLine === origName || line.includes(origName)) {
                            matchedOrigName = origName;
                            break;
                        }
                    }
                }
                
                originalContentLines.push({
                    text: trimmedLine,
                    isTimestamp: isTimestampLine,
                    isVoter: isVoterLine,
                    origName: matchedOrigName
                });
            }
            
            // Build mappings for structured ballot
            // Map from origName to list of indices in structuredBallot
            const origNameToStructuredIndices = new Map<string, number[]>();
            for (let i = 0; i < structuredBallot.length; i++) {
                const ranking = structuredBallot[i];
                for (let origName of ballot.rankings) {
                    const match = parsedData.nameMatches.get(origName);
                    if (match === ranking.candidate) {
                        if (!origNameToStructuredIndices.has(origName)) {
                            origNameToStructuredIndices.set(origName, []);
                        }
                        origNameToStructuredIndices.get(origName)!.push(i);
                    }
                }
            }
            
            // Track which structured ballot indices we've rendered
            const renderedStructuredIndices = new Set<number>();
            
            // Render rows by pairing original lines with structured rankings
            for (let origLine of originalContentLines) {
                const row = document.createElement('div');
                row.className = 'ballot-row';
                
                // Left side: Original line
                const originalDiv = document.createElement('div');
                originalDiv.className = 'ballot-row-original';
                if (origLine.isTimestamp) {
                    originalDiv.style.color = '#66d9ef';
                    originalDiv.style.fontWeight = 'bold';
                } else if (origLine.isVoter) {
                    originalDiv.style.color = '#50fa7b';
                    originalDiv.style.fontWeight = 'bold';
                }
                originalDiv.textContent = origLine.text;
                
                // Right side: Structured element
                const structuredDiv = document.createElement('div');
                structuredDiv.className = 'ballot-row-structured';
                
                if (origLine.isVoter) {
                    // Voter line - empty spacer on right
                    structuredDiv.innerHTML = `<span class="rank-number"></span>`;
                } else if (origLine.isTimestamp) {
                    // Timestamp spacer on right
                    structuredDiv.classList.add('spacer');
                    structuredDiv.innerHTML = `
                        <span class="rank-number"></span>
                        <span class="spacer-label" style="font-style: italic; color: #66d9ef;">${escapeHtml(origLine.text)}</span>
                    `;
                } else if (origLine.origName) {
                    // This original line corresponds to a ballot ranking
                    const indices = origNameToStructuredIndices.get(origLine.origName) || [];
                    const unrenderedIndex = indices.find(idx => !renderedStructuredIndices.has(idx));
                    
                    if (unrenderedIndex !== undefined) {
                        // Valid ranking - create editable row
                        const ranking = structuredBallot[unrenderedIndex];
                        const rankIndex = unrenderedIndex;
                        renderedStructuredIndices.add(rankIndex);
                        
                        if (hasOverride) structuredDiv.classList.add('modified');
                        
                        const rankNum = document.createElement('span');
                        rankNum.className = 'rank-number';
                        rankNum.textContent = `${ranking.rank}.`;
                        rankNum.style.fontWeight = 'bold';
                        rankNum.style.color = '#1d70b8';
                        rankNum.style.width = '30px';
                        rankNum.style.flexShrink = '0';
                        
                        const moveUpBtn = document.createElement('button');
                        moveUpBtn.type = 'button';
                        moveUpBtn.className = 'rank-move-btn';
                        moveUpBtn.innerHTML = '↑';
                        moveUpBtn.disabled = rankIndex === 0;
                        moveUpBtn.addEventListener('click', () => {
                            moveRanking(ballot.voter, rankIndex, rankIndex - 1);
                        });
                        
                        const moveDownBtn = document.createElement('button');
                        moveDownBtn.type = 'button';
                        moveDownBtn.className = 'rank-move-btn';
                        moveDownBtn.innerHTML = '↓';
                        moveDownBtn.disabled = rankIndex === structuredBallot.length - 1;
                        moveDownBtn.addEventListener('click', () => {
                            moveRanking(ballot.voter, rankIndex, rankIndex + 1);
                        });
                        
                        const dropdown = document.createElement('select');
                        dropdown.className = 'rank-dropdown';
                        dropdown.style.flex = '1';
                        
                        // Add "Not a candidate" option
                        const notCandidateOption = document.createElement('option');
                        notCandidateOption.value = '';
                        notCandidateOption.textContent = '-- Not a candidate --';
                        dropdown.appendChild(notCandidateOption);
                        
                        for (let candidate of parsedData.candidates) {
                            const option = document.createElement('option');
                            option.value = candidate;
                            option.textContent = candidate;
                            if (ranking.candidate === candidate) option.selected = true;
                            dropdown.appendChild(option);
                        }
                        dropdown.addEventListener('change', () => {
                            if (dropdown.value === '') {
                                // Remove this ranking
                                removeRanking(ballot.voter, rankIndex);
                            } else {
                                changeRankingCandidate(ballot.voter, rankIndex, dropdown.value);
                            }
                        });
                        
                        const removeBtn = document.createElement('button');
                        removeBtn.type = 'button';
                        removeBtn.className = 'rank-remove';
                        removeBtn.innerHTML = '×';
                        removeBtn.addEventListener('click', () => {
                            removeRanking(ballot.voter, rankIndex);
                        });
                        
                        structuredDiv.appendChild(rankNum);
                        structuredDiv.appendChild(moveUpBtn);
                        structuredDiv.appendChild(moveDownBtn);
                        structuredDiv.appendChild(dropdown);
                        structuredDiv.appendChild(removeBtn);
                    } else {
                        // Invalid/duplicate/removed ranking - show as spacer WITH controls
                        const match = parsedData.nameMatches.get(origLine.origName);
                        
                        // Determine label
                        let labelText = '';
                        if (match === '__NOT_A_BALLOT__') {
                            labelText = `Removed: ${origLine.origName}`;
                        } else if (match === null) {
                            labelText = `Invalid: ${origLine.origName}`;
                        } else {
                            labelText = `Duplicate: ${origLine.origName}`;
                        }
                        
                        // Create a fake "ranking" for this invalid/duplicate line
                        // so operator can convert it to a valid ranking
                        const rankNum = document.createElement('span');
                        rankNum.className = 'rank-number';
                        rankNum.textContent = '—';
                        rankNum.style.color = '#999';
                        rankNum.style.width = '30px';
                        rankNum.style.flexShrink = '0';
                        
                        const dropdown = document.createElement('select');
                        dropdown.className = 'rank-dropdown';
                        dropdown.style.flex = '1';
                        dropdown.style.fontStyle = 'italic';
                        dropdown.style.color = '#999';
                        
                        // Default option showing why it's invalid
                        const defaultOption = document.createElement('option');
                        defaultOption.value = '';
                        defaultOption.textContent = labelText;
                        dropdown.appendChild(defaultOption);
                        
                        // Add all candidates as options
                        for (let candidate of parsedData.candidates) {
                            const option = document.createElement('option');
                            option.value = candidate;
                            option.textContent = candidate;
                            dropdown.appendChild(option);
                        }
                        
                        dropdown.addEventListener('change', () => {
                            if (dropdown.value) {
                                // Convert invalid/duplicate line to a valid ranking
                                addRanking(ballot.voter, dropdown.value);
                            }
                        });
                        
                        structuredDiv.appendChild(rankNum);
                        structuredDiv.appendChild(dropdown);
                    }
                } else {
                    // Empty spacer
                    structuredDiv.innerHTML = `<span class="rank-number"></span>`;
                }
                
                row.appendChild(originalDiv);
                row.appendChild(structuredDiv);
                body.appendChild(row);
            }
            
            // Add any structured ballot rankings that weren't rendered yet (manually added)
            for (let i = 0; i < structuredBallot.length; i++) {
                if (renderedStructuredIndices.has(i)) continue;
                
                const ranking = structuredBallot[i];
                const row = document.createElement('div');
                row.className = 'ballot-row';
                
                // Left side: Empty (no original line for this)
                const originalDiv = document.createElement('div');
                originalDiv.className = 'ballot-row-original';
                originalDiv.innerHTML = '<span style="color: #666; font-style: italic;">(manually added)</span>';
                
                // Right side: Full controls
                const structuredDiv = document.createElement('div');
                structuredDiv.className = 'ballot-row-structured';
                if (hasOverride) structuredDiv.classList.add('modified');
                
                const rankNum = document.createElement('span');
                rankNum.className = 'rank-number';
                rankNum.textContent = `${ranking.rank}.`;
                rankNum.style.fontWeight = 'bold';
                rankNum.style.color = '#1d70b8';
                rankNum.style.width = '30px';
                rankNum.style.flexShrink = '0';
                
                const moveUpBtn = document.createElement('button');
                moveUpBtn.type = 'button';
                moveUpBtn.className = 'rank-move-btn';
                moveUpBtn.innerHTML = '↑';
                moveUpBtn.disabled = i === 0;
                moveUpBtn.addEventListener('click', () => {
                    moveRanking(ballot.voter, i, i - 1);
                });
                
                const moveDownBtn = document.createElement('button');
                moveDownBtn.type = 'button';
                moveDownBtn.className = 'rank-move-btn';
                moveDownBtn.innerHTML = '↓';
                moveDownBtn.disabled = i === structuredBallot.length - 1;
                moveDownBtn.addEventListener('click', () => {
                    moveRanking(ballot.voter, i, i + 1);
                });
                
                const dropdown = document.createElement('select');
                dropdown.className = 'rank-dropdown';
                dropdown.style.flex = '1';
                
                // Add "Not a candidate" option
                const notCandidateOption = document.createElement('option');
                notCandidateOption.value = '';
                notCandidateOption.textContent = '-- Not a candidate --';
                dropdown.appendChild(notCandidateOption);
                
                for (let candidate of parsedData.candidates) {
                    const option = document.createElement('option');
                    option.value = candidate;
                    option.textContent = candidate;
                    if (ranking.candidate === candidate) option.selected = true;
                    dropdown.appendChild(option);
                }
                dropdown.addEventListener('change', () => {
                    if (dropdown.value === '') {
                        removeRanking(ballot.voter, i);
                    } else {
                        changeRankingCandidate(ballot.voter, i, dropdown.value);
                    }
                });
                
                const removeBtn = document.createElement('button');
                removeBtn.type = 'button';
                removeBtn.className = 'rank-remove';
                removeBtn.innerHTML = '×';
                removeBtn.addEventListener('click', () => {
                    removeRanking(ballot.voter, i);
                });
                
                structuredDiv.appendChild(rankNum);
                structuredDiv.appendChild(moveUpBtn);
                structuredDiv.appendChild(moveDownBtn);
                structuredDiv.appendChild(dropdown);
                structuredDiv.appendChild(removeBtn);
                
                row.appendChild(originalDiv);
                row.appendChild(structuredDiv);
                body.appendChild(row);
            }
            
            
            // Add "Add Ranking" and "Reset" buttons at the bottom
            const actionsRow = document.createElement('div');
            actionsRow.className = 'ballot-row';
            actionsRow.innerHTML = `
                <div class="ballot-row-original" style="background: #1d1d1d;"></div>
                <div class="ballot-row-structured" style="background: #f8f8f8; justify-content: space-between;">
                    <select class="add-ranking-dropdown" style="flex: 1; margin-right: 10px;">
                        <option value="">-- Select candidate to add --</option>
                        ${parsedData.candidates.filter(c => !structuredBallot.find(r => r.candidate === c)).map(c => `<option value="${escapeHtml(c)}">${escapeHtml(c)}</option>`).join('')}
                    </select>
                    <button type="button" class="add-ranking" style="margin-right: 10px;">+ Add Ranking</button>
                    ${hasOverride ? '<button type="button" class="reset-ballot-btn">↻ Reset to Auto-Mapped</button>' : ''}
                </div>
            `;
            body.appendChild(actionsRow);
            
            // Attach event listeners to the action buttons
            const addDropdown = actionsRow.querySelector('.add-ranking-dropdown') as HTMLSelectElement;
            const addBtn = actionsRow.querySelector('.add-ranking') as HTMLButtonElement;
            const resetBtn = actionsRow.querySelector('.reset-ballot-btn') as HTMLButtonElement;
            
            if (addBtn && addDropdown) {
                addBtn.addEventListener('click', () => {
                    if (addDropdown.value) {
                        addRanking(ballot.voter, addDropdown.value);
                    }
                });
            }
            
            if (resetBtn) {
                resetBtn.addEventListener('click', () => {
                    parsedData.ballotOverrides.delete(ballot.voter);
                    renderBallotReview();
                });
            }
            
            card.appendChild(body);
            content.appendChild(card);
            
            // Navigation buttons
            const navDiv = document.createElement('div');
            navDiv.className = 'ballot-nav-buttons icenia-button-group';
            
            const prevBtn = document.createElement('button');
            prevBtn.type = 'button';
            prevBtn.className = 'icenia-btn icenia-btn-secondary';
            prevBtn.textContent = '← Previous Ballot';
            prevBtn.disabled = currentBallotIndex === 0;
            prevBtn.addEventListener('click', () => {
                if (currentBallotIndex > 0) {
                    currentBallotIndex--;
                    renderBallotReview();
                }
            });
            
            const nextBtn = document.createElement('button');
            nextBtn.type = 'button';
            nextBtn.className = 'icenia-btn';
            nextBtn.textContent = currentBallotIndex === totalBallots - 1 ? 'Ready to Calculate' : 'Next Ballot →';
            nextBtn.addEventListener('click', () => {
                if (currentBallotIndex < totalBallots - 1) {
                    currentBallotIndex++;
                    renderBallotReview();
                } else {
                    // On last ballot - proceed to calculate
                    calculateResults();
                }
            });
            
            navDiv.appendChild(prevBtn);
            navDiv.appendChild(nextBtn);
            content.appendChild(navDiv);
        }
        
        // Global keyboard navigation
        document.addEventListener('keydown', function(e) {
            // Don't interfere if user is typing in dropdown or another input
            if (e.target instanceof HTMLSelectElement || e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement) {
                return;
            }
            
            // Don't interfere if user is focused on a button (they might press Enter/Space on it)
            if (e.target instanceof HTMLButtonElement) {
                return;
            }
            
            // Handle duplicate voters keyboard navigation
            const duplicateVoters = document.getElementById('duplicate-voters');
            if (duplicateVoters && duplicateVoters.style.display === 'block') {
                if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    navigateDuplicateBallotOption('up');
                } else if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    navigateDuplicateBallotOption('down');
                } else if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    // Proceed to next duplicate or ballot review
                    if (currentDuplicateIndex < allDuplicateVoters.length - 1) {
                        currentDuplicateIndex++;
                        renderCurrentDuplicateVoter();
                    } else {
                        proceedToBallotReview();
                    }
                } else if (e.key === 'Enter' && e.shiftKey) {
                    e.preventDefault();
                    // Go back to previous duplicate
                    if (currentDuplicateIndex > 0) {
                        currentDuplicateIndex--;
                        renderCurrentDuplicateVoter();
                    }
                } else if (e.key === 'ArrowLeft') {
                    e.preventDefault();
                    if (currentDuplicateIndex > 0) {
                        currentDuplicateIndex--;
                        renderCurrentDuplicateVoter();
                    }
                } else if (e.key === 'ArrowRight') {
                    e.preventDefault();
                    if (currentDuplicateIndex < allDuplicateVoters.length - 1) {
                        currentDuplicateIndex++;
                        renderCurrentDuplicateVoter();
                    } else {
                        proceedToBallotReview();
                    }
                }
                return;
            }
            
            // Handle ballot review keyboard navigation
            const ballotReview = document.getElementById('ballot-review');
            if (ballotReview && ballotReview.style.display === 'block') {
                if (e.key === 'ArrowLeft' || (e.key === 'Enter' && e.shiftKey)) {
                    e.preventDefault();
                    if (currentBallotIndex > 0) {
                        currentBallotIndex--;
                        renderBallotReview();
                    }
                } else if (e.key === 'ArrowRight' || e.key === 'Enter') {
                    e.preventDefault();
                    if (currentBallotIndex < parsedData.ballots.length - 1) {
                        currentBallotIndex++;
                        renderBallotReview();
                    }
                }
                return;
            }
            
            // Handle name matching keyboard navigation
            const nameMatching = document.getElementById('name-matching');
            if (!nameMatching || nameMatching.style.display !== 'block') return;
            
            // Only navigate if we're not in the confirmation screen
            if (parsedData.currentNameIndex >= parsedData.uniqueNames.length) return;
            
            // 'W' key to focus dropdown
            if (e.key === 'w' || e.key === 'W') {
                const currentItem = document.querySelector('.name-match-item');
                if (currentItem) {
                    const dropdown = (currentItem as any).__dropdown;
                    if (dropdown) {
                        e.preventDefault();
                        dropdown.focus();
                    }
                }
                return;
            }
            
            // Arrow keys for navigation
            if (e.key === 'ArrowLeft' && parsedData.currentNameIndex > 0) {
                e.preventDefault();
                // Mark current name as reviewed before navigating
                const currentName = parsedData.uniqueNames[parsedData.currentNameIndex];
                parsedData.reviewedNames.add(currentName);
                
                parsedData.currentNameIndex--;
                renderCurrentName();
            } else if (e.key === 'ArrowRight' && parsedData.currentNameIndex < parsedData.uniqueNames.length) {
                e.preventDefault();
                // Mark current name as reviewed before navigating
                const currentName = parsedData.uniqueNames[parsedData.currentNameIndex];
                parsedData.reviewedNames.add(currentName);
                
                parsedData.currentNameIndex++;
                renderCurrentName();
            }
            
            // Enter and Shift+Enter for navigation
            if (e.key === 'Enter' && !e.shiftKey && parsedData.currentNameIndex < parsedData.uniqueNames.length) {
                e.preventDefault();
                // Mark current name as reviewed before navigating
                const currentName = parsedData.uniqueNames[parsedData.currentNameIndex];
                parsedData.reviewedNames.add(currentName);
                
                parsedData.currentNameIndex++;
                renderCurrentName();
            } else if (e.key === 'Enter' && e.shiftKey && parsedData.currentNameIndex > 0) {
                e.preventDefault();
                // Mark current name as reviewed before navigating
                const currentName = parsedData.uniqueNames[parsedData.currentNameIndex];
                parsedData.reviewedNames.add(currentName);
                
                parsedData.currentNameIndex--;
                renderCurrentName();
            }
            
            // Number keys 1-9 to quickly select match buttons
            const numMatch = e.key.match(/^[1-9]$/);
            if (numMatch) {
                const index = parseInt(e.key) - 1;
                const matchButtons = document.querySelectorAll<HTMLButtonElement>('.match-option');
                if (matchButtons[index] && !matchButtons[index].classList.contains('invalid') && !matchButtons[index].classList.contains('not-ballot')) {
                    e.preventDefault();
                    matchButtons[index].click();
                }
            }
            
            // 'N' key for "Not a candidate" button
            if (e.key === 'n' || e.key === 'N') {
                const matchOptions = document.querySelectorAll<HTMLButtonElement>('.match-option');
                // Find the "Not a candidate" button (should be the second-to-last button)
                const invalidBtn = Array.from(matchOptions).find(btn => 
                    btn.textContent?.includes('Not a candidate')
                );
                if (invalidBtn) {
                    e.preventDefault();
                    invalidBtn.click();
                }
            }
            
            // 'M' key for "Not a ballot entry" button
            if (e.key === 'm' || e.key === 'M') {
                const matchOptions = document.querySelectorAll<HTMLButtonElement>('.match-option');
                // Find the "Not a ballot entry" button (should be the last button)
                const notBallotBtn = Array.from(matchOptions).find(btn => 
                    btn.textContent?.includes('Not a ballot entry')
                );
                if (notBallotBtn) {
                    e.preventDefault();
                    notBallotBtn.click();
                }
            }
        });
        
        // Back to discord edit
        document.getElementById('back-to-discord')?.addEventListener('click', function() {
            const nameMatching = document.getElementById('name-matching');
            const discordMode = document.getElementById('discord-mode');
            if (nameMatching) nameMatching.style.display = 'none';
            if (discordMode) discordMode.style.display = 'block';
        });
        
        // Shared function to calculate and display results
        function calculateResults() {
            // Convert ballots using the name matches (or overrides if they exist)
            const candidates = parsedData.candidates;
            const ballots: Ballot[] = [];
            
            for (let rawBallot of parsedData.ballots) {
                let rankings: string[] = [];
                
                // Check if there's a manual override for this ballot
                const override = parsedData.ballotOverrides.get(rawBallot.voter);
                
                if (override) {
                    // Use the manually edited ballot
                    rankings = override
                        .filter(r => r.candidate && r.candidate !== '__NOT_A_BALLOT__')
                        .map(r => r.candidate);
                } else {
                    // Use automated mapping
                    for (let foundName of rawBallot.rankings) {
                        const matchedCandidate = parsedData.nameMatches.get(foundName);
                        // Skip null (invalid candidate), __NOT_A_BALLOT__, and duplicates
                        if (matchedCandidate && matchedCandidate !== '__NOT_A_BALLOT__' && !rankings.includes(matchedCandidate)) {
                            rankings.push(matchedCandidate);
                        }
                    }
                }
                
                if (rankings.length > 0) {
                    const ballot = ballotFromNames(rawBallot.voter, rankings, candidates);
                    if (ballot) {
                        ballots.push(ballot);
                    }
                }
            }
            
            if (ballots.length === 0) {
                alert('No valid ballots after name matching');
                return;
            }
            
            // Run STV
            let logText = '';
            const logCallback = (text, type) => {
                logText += text;
                if (type === 'win') {
                    logText = logText.replace(text, `<span class="stv-log-win">${text}</span>`);
                } else if (type === 'elim') {
                    logText = logText.replace(text, `<span class="stv-log-elim">${text}</span>`);
                }
            };
            
            const winners = STV(ballots, parsedData.seats, candidates, logCallback);
            
            // Display results
            const logEl = document.getElementById('log');
            const winnersEl = document.getElementById('winners');
            const resultsEl = document.getElementById('results');
            const nameMatchingEl = document.getElementById('name-matching');
            const ballotReviewEl = document.getElementById('ballot-review');
            const resultsSeatsEl = document.getElementById('results-seats') as HTMLInputElement;
            
            if (logEl) logEl.innerHTML = logText;
            if (winnersEl) winnersEl.innerHTML = 
                `<strong>The winners are:</strong> ${winners.join(', ')}`;
            if (resultsSeatsEl) resultsSeatsEl.value = parsedData.seats.toString();
            if (resultsEl) resultsEl.style.display = 'block';
            if (nameMatchingEl) nameMatchingEl.style.display = 'none';
            if (ballotReviewEl) ballotReviewEl.style.display = 'none';
            const importSection = document.getElementById('import-section');
            if (importSection) importSection.style.display = 'none';
        }
        
        // Confirm matches - now proceeds to ballot review instead of calculating immediately
        document.getElementById('confirm-matches')?.addEventListener('click', function() {
            // Check that all names have been matched
            const nameMatchList = document.getElementById('name-match-list');
            if (!nameMatchList) return;
            const items = nameMatchList.querySelectorAll('.name-match-item');
            
            for (let item of items) {
                const foundNameEl = item.querySelector('.found-name');
                if (!foundNameEl || !foundNameEl.textContent) continue;
                const foundName = foundNameEl.textContent;
                if (!parsedData.nameMatches.has(foundName)) {
                    alert(`Please select a match for "${foundName}" or mark it as invalid`);
                    return;
                }
            }
            
            // Proceed to ballot review (showConfirmation now shows ballot review)
            showConfirmation();
        });
        
        // Export results button
        document.getElementById('export-results')?.addEventListener('click', exportElection);
        
        // Export for RCVis button
        document.getElementById('export-rcvis')?.addEventListener('click', exportForRCVis);
        
        // Return to start button
        document.getElementById('return-to-start')?.addEventListener('click', function() {
            const resultsEl = document.getElementById('results');
            const importSection = document.getElementById('import-section');
            const simpleMode = document.getElementById('simple-mode');
            const discordMode = document.getElementById('discord-mode');
            const nameMatching = document.getElementById('name-matching');
            const ballotReview = document.getElementById('ballot-review');
            const duplicateVoters = document.getElementById('duplicate-voters');
            
            // Hide all sections first
            if (resultsEl) resultsEl.style.display = 'none';
            if (nameMatching) nameMatching.style.display = 'none';
            if (ballotReview) ballotReview.style.display = 'none';
            if (duplicateVoters) duplicateVoters.style.display = 'none';
            
            // Show import section
            if (importSection) importSection.style.display = 'block';
            
            // Update radio button to match current mode
            const radioToCheck = document.querySelector(`input[name="input-mode"][value="${inputMode}"]`) as HTMLInputElement;
            if (radioToCheck) {
                radioToCheck.checked = true;
            }
            
            // Show the appropriate input mode
            if (inputMode === 'simple') {
                if (simpleMode) simpleMode.style.display = 'block';
                if (discordMode) discordMode.style.display = 'none';
            } else {
                if (simpleMode) simpleMode.style.display = 'none';
                if (discordMode) discordMode.style.display = 'block';
            }
        // Note: All data (candidates, ballots, name matches, overrides, learned correlations) are retained
            // User can now modify inputs and rerun with all mappings intact
        });
        
        // Recalculate button on results screen
        document.getElementById('recalculate-results')?.addEventListener('click', function() {
            const resultsSeatsEl = document.getElementById('results-seats') as HTMLInputElement;
            if (!resultsSeatsEl) return;
            
            const newSeats = parseInt(resultsSeatsEl.value);
            if (isNaN(newSeats) || newSeats < 1) {
                alert('Please enter a valid number of winners (at least 1)');
                return;
            }
            
            // Update seats in parsedData
            parsedData.seats = newSeats;
            
            // Recalculate with new number of winners
            calculateResults();
            
            // Note: All data (candidates, ballots, name matches, overrides, learned correlations) are retained
            // User can now modify inputs and rerun with all mappings intact
        });
        
        // ===== SIMPLE MODE UI LOGIC =====
        
        // Simple mode calculate button
        document.getElementById('calculate')?.addEventListener('click', function() {
            const candidatesEl = document.getElementById('candidates') as HTMLTextAreaElement;
            const ballotsEl = document.getElementById('ballots') as HTMLTextAreaElement;
            const seatsEl = document.getElementById('seats') as HTMLInputElement;
            
            if (!candidatesEl || !ballotsEl || !seatsEl) return;
            
            const candidatesText = candidatesEl.value;
            const ballotsText = ballotsEl.value;
            const seats = parseInt(seatsEl.value);
            
            // Parse candidates
            const candidates = candidatesText.split('\n')
                .map(c => c.trim())
                .filter(c => c.length > 0);
            
            if (candidates.length === 0) {
                alert('Please enter at least one candidate');
                return;
            }
            
            if (seats < 1 || seats > candidates.length) {
                alert('Number of seats must be between 1 and the number of candidates');
                return;
            }
            
            // Parse ballots
            const ballotLines = ballotsText.split('\n')
                .map(l => l.trim())
                .filter(l => l.length > 0);
            
            if (ballotLines.length === 0) {
                alert('Please enter at least one ballot');
                return;
            }
            
            const ballots: Ballot[] = [];
            for (let line of ballotLines) {
                const colonIdx = line.indexOf(':');
                if (colonIdx === -1) {
                    alert(`Invalid ballot format: ${line}`);
                    return;
                }
                
                const voterName = line.substring(0, colonIdx).trim();
                const rankings = line.substring(colonIdx + 1)
                    .split(',')
                    .map(c => c.trim())
                    .filter(c => c.length > 0);
                
                const ballot = ballotFromNames(voterName, rankings, candidates);
                if (ballot) {
                    ballots.push(ballot);
                } else {
                    alert(`Invalid ballot for ${voterName}`);
                    return;
                }
            }
            
            // Run STV
            let logText = '';
            const logCallback = (text, type) => {
                logText += text;
                if (type === 'win') {
                    logText = logText.replace(text, `<span class="stv-log-win">${text}</span>`);
                } else if (type === 'elim') {
                    logText = logText.replace(text, `<span class="stv-log-elim">${text}</span>`);
                }
            };
            
            const winners = STV(ballots, seats, candidates, logCallback);
            
            // Display results
            const logEl = document.getElementById('log');
            const winnersEl = document.getElementById('winners');
            const resultsEl = document.getElementById('results');
            
            if (logEl) logEl.innerHTML = logText;
            if (winnersEl) winnersEl.innerHTML = 
                `<strong>The winners are:</strong> ${winners.join(', ')}`;
            if (resultsEl) resultsEl.style.display = 'block';
        });
        
        // Load example data button
        document.getElementById('loadExample')?.addEventListener('click', function() {
            const exampleCandidates = `DinoComparator
Markstefr
CreepilyCreep
Dr_Bacon_hair
Ratat0ing
Complexii
Zolo
pemcgee
minemaster
hsmnewfriend
JoshHillman`;
            
            const exampleBallots = `recycler: Ratat0ing, Dr_Bacon_hair, hsmnewfriend, JoshHillman, minemaster, DinoComparator, Zolo
alzubloxxer11: Dr_Bacon_hair, hsmnewfriend, Ratat0ing, CreepilyCreep, Complexii, JoshHillman, minemaster
stefanmakker: hsmnewfriend, Ratat0ing, Dr_Bacon_hair, pemcgee, Complexii, minemaster, JoshHillman
lopsterbisque: Ratat0ing, CreepilyCreep, Complexii, Zolo, Markstefr, pemcgee, Dr_Bacon_hair, hsmnewfriend
binchymonkey: Markstefr, Ratat0ing, JoshHillman
dr_bacon_hair: minemaster, hsmnewfriend, Dr_Bacon_hair, Zolo, JoshHillman, Ratat0ing, CreepilyCreep, Markstefr, pemcgee, Complexii
lucinnefo: JoshHillman, Dr_Bacon_hair, CreepilyCreep, DinoComparator, pemcgee, Complexii, hsmnewfriend, Markstefr
ratat0ing: Ratat0ing, CreepilyCreep, hsmnewfriend, Zolo, Complexii, Dr_Bacon_hair, minemaster
darkhelmet: Dr_Bacon_hair, Zolo, hsmnewfriend
zolo: Zolo, Dr_Bacon_hair, hsmnewfriend, Complexii, CreepilyCreep, Ratat0ing, minemaster, Markstefr
cubine: Dr_Bacon_hair, CreepilyCreep
lena: Dr_Bacon_hair, Ratat0ing, minemaster
markstfr: Markstefr, minemaster, Dr_Bacon_hair, Ratat0ing, CreepilyCreep, hsmnewfriend, JoshHillman, Zolo, pemcgee, Complexii
yodabird: Complexii, CreepilyCreep, Ratat0ing, Zolo, hsmnewfriend, JoshHillman, DinoComparator, Dr_Bacon_hair, pemcgee, Markstefr, minemaster
joshhillman: JoshHillman, Dr_Bacon_hair, CreepilyCreep, Ratat0ing, Complexii, minemaster, pemcgee, DinoComparator, hsmnewfriend, Markstefr, Zolo
peemcgee: pemcgee, Ratat0ing, JoshHillman, CreepilyCreep, Dr_Bacon_hair
jaimie: Dr_Bacon_hair, CreepilyCreep, hsmnewfriend, Zolo, minemaster
sdorr: minemaster, hsmnewfriend, Dr_Bacon_hair, Zolo
mushroomcultist: minemaster, hsmnewfriend, Dr_Bacon_hair, Zolo
dinocomparator: DinoComparator, Ratat0ing, CreepilyCreep, minemaster, JoshHillman, hsmnewfriend, Complexii, Zolo, Dr_Bacon_hair, Markstefr
gold: Complexii, CreepilyCreep, Ratat0ing, Zolo, hsmnewfriend, JoshHillman, DinoComparator, Dr_Bacon_hair, pemcgee, Markstefr, minemaster
mushroomstew: Complexii, Zolo, JoshHillman, hsmnewfriend, Dr_Bacon_hair, minemaster, CreepilyCreep, Ratat0ing
minemaster: minemaster, hsmnewfriend, Dr_Bacon_hair, Zolo, CreepilyCreep, Ratat0ing, Markstefr
gjum: CreepilyCreep, Ratat0ing, Complexii, hsmnewfriend, Zolo, Dr_Bacon_hair, minemaster, pemcgee
creepilycreep: CreepilyCreep, Ratat0ing, Complexii, Dr_Bacon_hair, Zolo, minemaster, pemcgee, JoshHillman
complexii: Complexii, Ratat0ing, CreepilyCreep, Zolo, pemcgee, hsmnewfriend, Dr_Bacon_hair
juniortide: Dr_Bacon_hair, Zolo, CreepilyCreep, Complexii, JoshHillman, Ratat0ing, pemcgee, minemaster, hsmnewfriend, DinoComparator, Markstefr
lordchieftan: Ratat0ing, CreepilyCreep, Complexii, hsmnewfriend, Zolo, pemcgee, Dr_Bacon_hair, JoshHillman, minemaster, DinoComparator, Markstefr
raeders: Dr_Bacon_hair, minemaster, Ratat0ing, Zolo, JoshHillman, hsmnewfriend
speedyjustice: minemaster, hsmnewfriend, Dr_Bacon_hair, Markstefr, CreepilyCreep
kiwi: minemaster, hsmnewfriend, Dr_Bacon_hair, Markstefr
hsmnewfriend: minemaster, hsmnewfriend, Dr_Bacon_hair, Markstefr, Zolo, pemcgee, JoshHillman, Complexii, CreepilyCreep, DinoComparator
chrischrispie: Complexii, CreepilyCreep, Ratat0ing, Zolo, hsmnewfriend, JoshHillman, DinoComparator, Dr_Bacon_hair, pemcgee, Markstefr, minemaster
Entrie: minemaster, hsmnewfriend, Dr_Bacon_hair, Markstefr, CreepilyCreep, Ratat0ing
Kronprinzkaiser: minemaster, hsmnewfriend, Dr_Bacon_hair, Markstefr, CreepilyCreep, Ratat0ing
okiinawa: minemaster, hsmnewfriend, Dr_Bacon_hair, Markstefr, CreepilyCreep, Ratat0ing
vilyanz: minemaster, Dr_Bacon_hair, Complexii, hsmnewfriend, Zolo, Markstefr
escarchaking333: Ratat0ing, CreepilyCreep, Dr_Bacon_hair, Zolo, minemaster, pemcgee, JoshHillman
sage: CreepilyCreep, hsmnewfriend, pemcgee, Dr_Bacon_hair, JoshHillman, minemaster
xcios: Ratat0ing, CreepilyCreep, Complexii, Dr_Bacon_hair, hsmnewfriend, Markstefr, DinoComparator, Zolo, minemaster
shadysauce: minemaster, Dr_Bacon_hair, hsmnewfriend, Zolo, Complexii
august: minemaster, Ratat0ing, Complexii, Zolo, pemcgee, CreepilyCreep, hsmnewfriend, Markstefr, Dr_Bacon_hair, JoshHillman, DinoComparator
silenthunterx: Dr_Bacon_hair, hsmnewfriend, Markstefr, Ratat0ing, pemcgee, Zolo, DinoComparator
vedel: minemaster, hsmnewfriend, Dr_Bacon_hair, Markstefr, CreepilyCreep, Ratat0ing`;
            
            const candidatesEl = document.getElementById('candidates') as HTMLTextAreaElement;
            const ballotsEl = document.getElementById('ballots') as HTMLTextAreaElement;
            const seatsEl = document.getElementById('seats') as HTMLInputElement;
            
            if (candidatesEl) candidatesEl.value = exampleCandidates;
            if (ballotsEl) ballotsEl.value = exampleBallots;
            if (seatsEl) seatsEl.value = '5';
        });
    </script>
</PageLayout>
