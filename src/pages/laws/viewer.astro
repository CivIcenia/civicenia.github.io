---
import PageLayout from "@layouts/page.astro";

const title = "Document Viewer";
---

<PageLayout title={title}>
  <div class="govuk-grid-row">
    <div class="govuk-grid-column-full">
      <h1 class="govuk-heading-xl">Document Viewer</h1>
      
      <div id="viewer-container" class="viewer-container">
        <div id="loading-message" class="govuk-body">Loading document...</div>
        <div id="error-message" class="govuk-error-message" style="display: none;"></div>
        
        <!-- Viewer toggle controls -->
        <div id="viewer-controls" class="viewer-controls" style="display: none;">
          <button class="viewer-toggle active" data-viewer="google" type="button">Google Viewer</button>
          <button class="viewer-toggle" data-viewer="office" type="button">Office Viewer</button>
        </div>
        
        <!-- Client-side renderer container (used locally) -->
        <div id="docx-container" style="display: none;"></div>
        
        <!-- External viewer iframe (used in production) -->
        <iframe 
          id="doc-iframe" 
          title="Document Viewer"
          width="100%" 
          height="800" 
          frameborder="0" 
          allowfullscreen
          style="display: none;"
        ></iframe>
        
        <div id="actions" style="margin-top: 15px; display: none; text-align: right;">
           <a id="download-link" href="#" class="govuk-button" target="_blank">Download Document</a>
           <a id="download-pdf-link" href="#" class="govuk-button govuk-button--secondary" target="_blank" style="display:none; margin-left:8px;">Download PDF</a>
        </div>
      </div>
    </div>
  </div>
</PageLayout>

<script>
  // Load docx-preview from CDN to avoid bundling the massive library
  // This prevents OOM errors during build
  let docxPreviewCache: any = null;
  let jszipLoaded = false;
  
  // Load JSZip first - required dependency for docx-preview
  async function loadJSZip(): Promise<void> {
    if (jszipLoaded) return;
    
    return new Promise((resolve, reject) => {
      const script = document.createElement('script');
      script.src = 'https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js';
      script.onload = () => {
        if ((window as any).JSZip) {
          jszipLoaded = true;
          resolve();
        } else {
          reject(new Error('JSZip loaded but not found on window'));
        }
      };
      script.onerror = () => reject(new Error('Failed to load JSZip from CDN'));
      document.head.appendChild(script);
    });
  }
  
  async function loadDocxPreviewFromCDN(): Promise<any> {
    if (docxPreviewCache) return docxPreviewCache;
    
    // Ensure JSZip is loaded first
    await loadJSZip();
    
    return new Promise((resolve, reject) => {
      const script = document.createElement('script');
      script.src = 'https://cdn.jsdelivr.net/npm/docx-preview@0.3.7/dist/docx-preview.min.js';
      script.onload = () => {
        // docx-preview attaches to window.docx
        const docx = (window as any).docx;
        if (docx && docx.renderAsync) {
          docxPreviewCache = docx;
          resolve(docx);
        } else {
          reject(new Error('docx-preview loaded but renderAsync not found'));
        }
      };
      script.onerror = () => reject(new Error('Failed to load docx-preview from CDN'));
      document.head.appendChild(script);
    });
  }
  
  // Dynamic import for docx-preview to work as a module
  async function initViewer() {
    const params = new URLSearchParams(window.location.search);
    const file = params.get('file');
    // Use Office as default for desktop, Google for mobile
    let currentViewer = params.get('viewer');
    if (!currentViewer) {
      // if (window.innerWidth < 740) {
        currentViewer = 'google';
      // } else {
      //   currentViewer = 'office';
      // }
    }
    
    const iframe = document.getElementById('doc-iframe') as HTMLIFrameElement;
    const docxContainer = document.getElementById('docx-container') as HTMLDivElement;
    const loadingMsg = document.getElementById('loading-message');
    const errorMsg = document.getElementById('error-message');
    const actions = document.getElementById('actions');
    const downloadLink = document.getElementById('download-link') as HTMLAnchorElement;
    const viewerControls = document.getElementById('viewer-controls');
    const toggleButtons = document.querySelectorAll('.viewer-toggle');
    
    const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';

        const downloadPdfLink = document.getElementById('download-pdf-link') as HTMLAnchorElement;
    if (!file) {
      if (loadingMsg) loadingMsg.style.display = 'none';
      if (errorMsg) {
        errorMsg.textContent = 'Error: No file specified. Please provide a "file" query parameter.';
        errorMsg.style.display = 'block';
      }
      return;
    }

    // Construct full URL
    let fullUrl = file;
    if (file.startsWith('/')) {
      fullUrl = window.location.origin + file;
    } else if (!file.startsWith('http')) {
      fullUrl = window.location.origin + '/' + file;
    }

    // Update download link
    if (downloadLink) {
      downloadLink.href = fullUrl;
    }
    if (actions) {
      actions.style.display = 'block';
    }

    

        // If the file is a .docx or .doc, check if a PDF exists in the same directory
        if (downloadPdfLink && (file.toLowerCase().endsWith('.docx') || file.toLowerCase().endsWith('.doc'))) {
          // Replace extension with .pdf
          let pdfPath = file.replace(/\.(docx|doc)$/i, '.pdf');
          let pdfUrl = pdfPath;
          if (pdfPath.startsWith('/')) {
            pdfUrl = window.location.origin + pdfPath;
          } else if (!pdfPath.startsWith('http')) {
            pdfUrl = window.location.origin + '/' + pdfPath;
          }

          // Check if the PDF actually exists by making a HEAD request
          fetch(pdfUrl, { method: 'HEAD' }).then(resp => {
            if (resp.ok) {
              downloadPdfLink.href = pdfUrl;
              downloadPdfLink.style.display = '';
            }
          });
        }
    // Function to load viewer with specified provider
    function loadExternalViewer(viewer: string) {
      const encodedUrl = encodeURIComponent(fullUrl);
      let viewerUrl = '';

      if (viewer === 'office') {
        // Microsoft Office Online Viewer
        viewerUrl = `https://view.officeapps.live.com/op/embed.aspx?src=${encodedUrl}`;
      } else {
        // Google Docs Viewer (default)
        viewerUrl = `https://docs.google.com/gview?url=${encodedUrl}&embedded=true`;
      }

      if (iframe) {
        // Show loading message when switching
        if (loadingMsg) loadingMsg.style.display = 'block';
        iframe.style.display = 'none';
        
        iframe.src = viewerUrl;
        iframe.onload = () => {
          if (loadingMsg) loadingMsg.style.display = 'none';
          iframe.style.display = 'block';
        };
        // Fallback timeout
        setTimeout(() => {
          if (loadingMsg) loadingMsg.style.display = 'none';
          iframe.style.display = 'block';
        }, 2000);
      }
    }
    
    // Set up toggle button handlers
    function setupToggleButtons() {
      toggleButtons.forEach(button => {
        // Set initial active state
        if (button.getAttribute('data-viewer') === currentViewer) {
          button.classList.add('active');
        } else {
          button.classList.remove('active');
        }
        
        // Add click handler
        button.addEventListener('click', () => {
          const viewer = button.getAttribute('data-viewer');
          if (!viewer || viewer === currentViewer) return;
          
          currentViewer = viewer;
          
          // Update active state
          toggleButtons.forEach(btn => btn.classList.remove('active'));
          button.classList.add('active');
          
          // Reload viewer with new provider
          loadExternalViewer(viewer);
        });
      });
    }
    
    // Detect if the file is a .docx document
    const isDocx = file.toLowerCase().endsWith('.docx');
    // Use client-side renderer for localhost OR when explicitly requested
    if (isLocalhost && isDocx) {
      try {
        // Load docx-preview from CDN to avoid bundling the massive library
        const docxPreviewModule = await loadDocxPreviewFromCDN();
        
        const response = await fetch(fullUrl);
        if (!response.ok) throw new Error(`Failed to fetch document: ${response.status}`);
        
        const blob = await response.blob();
        
        await docxPreviewModule.renderAsync(blob, docxContainer, undefined, {
          className: 'docx-preview',
          inWrapper: true,
          ignoreWidth: false,
          ignoreHeight: false,
          ignoreFonts: false,
          breakPages: true,
          useBase64URL: true,
          renderHeaders: true,
          renderFooters: true,
          renderFootnotes: true,
          renderEndnotes: true,
        });
        
        if (loadingMsg) loadingMsg.style.display = 'none';
        docxContainer.style.display = 'block';
      } catch (err) {
        console.error('Error rendering docx:', err);
        if (loadingMsg) loadingMsg.style.display = 'none';
        if (errorMsg) {
          errorMsg.textContent = `Error loading document: ${err instanceof Error ? err.message : 'Unknown error'}. Try downloading the file instead.`;
          errorMsg.style.display = 'block';
        }
      }
    } else {
      // Show toggle controls for external viewers
      if (viewerControls) {
        viewerControls.style.display = 'flex';
      }
      
      // Set up toggle buttons
      setupToggleButtons();
      
      // Load initial viewer
      loadExternalViewer(currentViewer);
    }
  }
  
  // Run on DOM ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initViewer);
  } else {
    initViewer();
  }
</script>

<style>
  .viewer-container {
    min-height: 600px;
    background: #f3f2f1;
    padding: 20px;
    border: 1px solid #ccc;
  }
  
  .viewer-controls {
    display: flex;
    gap: 8px;
    margin-bottom: 15px;
    padding: 10px;
    background: white;
    border-radius: 4px;
  }
  
  .viewer-toggle {
    padding: 8px 16px;
    background-color: #f6f8fa;
    color: #24292e;
    border: 1px solid #d1d5da;
    border-radius: 4px;
    font-size: 14px;
    cursor: pointer;
    transition: all 0.2s ease;
  }
  
  .viewer-toggle:hover {
    background-color: #e1e4e8;
    border-color: #959da5;
  }
  
  .viewer-toggle.active {
    background-color: #0366d6;
    color: white;
    border-color: #0366d6;
  }
  
  .viewer-toggle.active:hover {
    background-color: #0255b3;
    border-color: #0255b3;
  }
  
  /* Styles for client-side docx-preview */
  #docx-container {
    background: white;
    padding: 20px;
    min-height: 800px;
    overflow: auto;
  }
  
  #docx-container :global(.docx-wrapper) {
    background: white;
    padding: 20px;
  }
  
  #docx-container :global(.docx-wrapper > section.docx) {
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
    margin-bottom: 20px;
  }
</style>
